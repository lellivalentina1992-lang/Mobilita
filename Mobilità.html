<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>App Mobilit√† e Orientamento - Versione Distribuibile</title>
  <style>
/* GESTIONE API KEY */
#apiKeySetup {
  background: #fff;
  max-width: 700px;
  margin: 40px auto;
  padding: 30px;
  border-radius: 12px;
  box-shadow: 0 4px 20px rgba(0,0,0,.15);
  z-index: 10001;
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
}
#apiKeySetup h2 { color: #667eea; margin-bottom: 20px; font-size: 1.8em; }
#apiKeySetup .info-box {
  background: #e3f2fd;
  border-left: 4px solid #2196f3;
  padding: 15px;
  margin: 20px 0;
  border-radius: 6px;
  line-height: 1.6;
}
#apiKeySetup .warning-box {
  background: #fff3cd;
  border-left: 4px solid #ff9800;
  padding: 15px;
  margin: 20px 0;
  border-radius: 6px;
  line-height: 1.6;
}
#apiKeySetup input[type="text"],
#apiKeySetup input[type="password"] {
  width: 100%;
  padding: 14px;
  border: 2px solid #dee2e6;
  border-radius: 8px;
  font-size: 16px;
  margin: 10px 0;
  font-family: monospace;
}
#apiKeySetup .button-group { display: flex; gap: 10px; margin-top: 20px; }
#apiKeySetup .button-group button { flex: 1; }
#apiKeySetup ol { margin: 15px 0 15px 25px; line-height: 1.8; }
#apiKeySetup ol li { margin: 8px 0; }
#apiKeySetup a { color: #667eea; font-weight: 600; text-decoration: none; }
#apiKeySetup a:hover { text-decoration: underline; }
.api-status {
  display: inline-block;
  padding: 6px 12px;
  border-radius: 20px;
  font-size: 0.9em;
  font-weight: 600;
  margin-left: 10px;
}
.api-status.active { background: #d4edda; color: #155724; }
.api-status.inactive { background: #f8d7da; color: #721c24; }
.show-key-toggle {
  cursor: pointer;
  color: #667eea;
  font-size: 0.9em;
  margin-top: 5px;
  display: inline-block;
  text-decoration: underline;
}
body.api-setup-active { overflow: hidden; }
body.api-setup-active::before {
  content: '';
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.5);
  z-index: 10000;
}
.settings-icon {
  position: fixed;
  bottom: 20px;
  right: 20px;
  width: 60px;
  height: 60px;
  background: linear-gradient(135deg,#667eea,#764ba2);
  border-radius: 50%;
  display: none;
  align-items: center;
  justify-content: center;
  color: white;
  font-size: 24px;
  cursor: pointer;
  box-shadow: 0 4px 15px rgba(0,0,0,.3);
  z-index: 1000;
  transition: transform .2s;
}
.settings-icon:hover { transform: scale(1.1) rotate(90deg); }
.btn-danger { background: linear-gradient(135deg,#dc3545,#e74c3c); }

/* STILI ORIGINALI */
/* Stili identici a prima */
    *{margin:0;padding:0;box-sizing:border-box}
    body{font-family:system-ui,Segoe UI,Arial,sans-serif;background:#f8f9fb}
    .header{background:linear-gradient(135deg,#667eea,#764ba2);color:#fff;padding:30px 20px;text-align:center;box-shadow:0 2px 10px rgba(0,0,0,.2)}
    .header h1{font-size:2.1em;margin-bottom:6px}.header p{opacity:.95}
    .container{max-width:1400px;margin:0 auto;padding:20px}
    .section-divider{background:#fff;margin:24px 0 16px;padding:14px 22px;border-radius:10px;border-left:5px solid #667eea;box-shadow:0 2px 8px rgba(0,0,0,.08)}
    .section-divider h2{color:#667eea;font-size:1.5em;margin:0}.section-divider p{color:#6c757d;margin:5px 0 0}
    .card{background:#fff;border-radius:12px;padding:22px;margin-bottom:18px;box-shadow:0 2px 8px rgba(0,0,0,.08)}
    .search-box{display:flex;gap:10px;margin-bottom:15px;flex-wrap:wrap}
    .search-box input{flex:1;min-width:260px;padding:14px 18px;border:2px solid #dee2e6;border-radius:8px;font-size:16px}
    .search-box select{padding:14px 18px;border:2px solid #dee2e6;border-radius:8px;font-size:16px;background-color:#fff;font-family:inherit}
    .btn{padding:12px 16px;background:linear-gradient(135deg,#667eea,#764ba2);color:#fff;border:none;border-radius:8px;font-size:15px;font-weight:600;cursor:pointer;transition:all .2s;white-space:nowrap;text-decoration:none;display:inline-block}
    .btn:disabled{background:#adb5bd;cursor:not-allowed}.btn:not(:disabled):hover{transform:translateY(-2px);box-shadow:0 4px 12px rgba(102,126,234,.3)}
    .btn-green{background:linear-gradient(135deg,#28a745,#20c997)}.btn-secondary{background:linear-gradient(135deg,#17a2b8,#20c997)}
    .btn-ghost{background:#fff;color:#667eea;border:2px solid #667eea}
    .options-grid{display:grid;grid-template-columns:220px 1fr auto;gap:15px;align-items:start}
    .option-label{font-weight:600;color:#495057;margin-bottom:8px;display:block}
    .cats-wrapper{max-height:280px;overflow:auto;border:1px solid #dee2e6;border-radius:8px;padding:10px}
    .cats-grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(220px,1fr));gap:8px}
    .cat-item{display:flex;align-items:center;gap:8px;padding:6px;border-radius:6px}
    .cat-item:focus-within{outline:3px solid rgba(102,126,234,.35);background:#f6f8ff}
    /* Stile per nascondere categorie filtrate */
    .cat-item.hidden{display:none}
    .summary{margin-top:10px;padding:10px;border:2px dashed #dee2e6;border-radius:8px;background:#fafbff}
    .map-grid{display:grid;grid-template-columns:1fr 1fr;gap:15px;margin:16px 0}
    .map-box{background:#fff;border-radius:12px;overflow:hidden;box-shadow:0 2px 8px rgba(0,0,0,.08);height:500px;position:relative}
    .map-label{position:absolute;top:15px;left:15px;background:#fff;padding:10px 18px;border-radius:8px;font-weight:700;color:#667eea;z-index:1000;box-shadow:0 2px 10px rgba(0,0,0,.15);font-size:15px}
    #map,#streetview{width:100%;height:100%}
    .sv-controls{position:absolute;top:60px;right:15px;z-index:1001;display:flex;flex-direction:column;gap:6px}
    .control-row{display:flex;gap:6px;justify-content:center}
    .control-btn{width:78px;height:48px;background:#fff;border:2px solid #667eea;border-radius:8px;cursor:pointer;font-size:14px;font-weight:700;display:flex;align-items:center;justify-content:center;transition:all .2s;box-shadow:0 2px 8px rgba(0,0,0,.15);color:#667eea}
    .control-btn:hover,.control-btn:focus{background:#667eea;color:#fff;outline:3px solid #28a745}
    .sv-live{position:absolute;bottom:15px;left:15px;right:15px;background:rgba(255,255,255,.95);padding:12px 15px;border-radius:8px;z-index:1000;box-shadow:0 2px 10px rgba(0,0,0,.2);font-size:13px;line-height:1.5}
    .osm-results{margin-top:10px;padding:12px;border:2px dashed #ddd;border-radius:8px;background:#fff}
    .notification{position:fixed;top:20px;right:20px;background:#fff;padding:16px 24px;border-radius:10px;box-shadow:0 4px 20px rgba(0,0,0,.25);z-index:10004;animation:slideIn .3s ease;font-weight:500;max-width:400px}
    @keyframes slideIn{from{transform:translateX(400px);opacity:0}to{transform:translateX(0);opacity:1}}
    .notification.success{border-left:5px solid #28a745}.notification.error{border-left:5px solid #dc3545}.notification.info{border-left:5px solid #17a2b8}
    /* Fix Autocomplete Google Places */
    .pac-container{z-index:10006 !important;font-family:system-ui,Segoe UI,Arial,sans-serif;border-radius:8px;box-shadow:0 4px 20px rgba(0,0,0,.15);margin-top:2px}
    .pac-item{padding:8px 12px;font-size:14px;cursor:pointer}
    .pac-item:hover{background-color:#f0f0f0}
    .pac-item-query{font-weight:600;color:#667eea}
    .tools-sticky{position:sticky;top:10px;z-index:5;background:#fff;padding-top:5px}
    .modal{position:fixed;inset:0;background:rgba(0,0,0,.35);display:none;align-items:center;justify-content:center;z-index:10005}
    .modal.show{display:flex}
    .modal-content{background:#fff;max-width:600px;width:92%;border-radius:12px;box-shadow:0 10px 30px rgba(0,0,0,.3);overflow:hidden}
    .modal-header{padding:14px 18px;font-weight:700;color:#667eea;border-bottom:1px solid #eee;font-size:1.1em}
    #modalBody{padding:16px;max-height:60vh;overflow-y:auto}
    .modal-buttons{display:flex;gap:10px;justify-content:flex-end;margin-top:12px;padding:12px 16px;border-top:1px solid #eee}
    .modal-info p{margin-bottom:8px;font-size:1.05em;line-height:1.5}
    .place-card{border-bottom:1px solid #eee;padding:10px 0}
    .place-actions{margin-top:10px}
    .place-actions select{padding:8px;font-size:14px;border-radius:6px;border:1px solid #ccc}
    #navigationView{position:fixed;inset:0;background:#f8f9fb;z-index:10003;display:none;flex-direction:column;padding:20px}
    #navHeader{display:flex;justify-content:space-between;align-items:center;padding-bottom:15px;border-bottom:2px solid #dee2e6}
    #navHeader h2{color:#667eea}
    #navSummaryInfo{text-align:center;font-size:1.2em;font-weight:600;color:#495057;margin:10px 0}
    #navStepInfo{font-size:1.1em;font-weight:600;color:#495057;text-align:center;margin:10px 0 20px}
    #navInstruction{font-size:1.4em;line-height:1.6;font-weight:500;text-align:center;padding:20px;background:#fff;border-radius:12px;box-shadow:0 2px 8px rgba(0,0,0,.08);min-height:100px;outline:none}
    #navInstruction:focus{outline:3px solid #667eea;outline-offset:2px}
    #navTransitInfo{font-size:1.1em;text-align:center;padding:15px;background:#e9ecef;border:2px solid #dee2e6;border-radius:8px;margin-top:15px;line-height:1.6}
    .nav-explore-tools{margin:20px 0;display:flex;gap:10px;justify-content:center;flex-wrap:wrap}
    #navGoogleMapsLink{margin:10px auto 0;display:block;width:fit-content;text-align:center}
    .nav-controls{margin-top:auto;padding-top:20px;border-top:2px solid #dee2e6;display:flex;justify-content:space-between;gap:15px}
    .nav-controls .btn{flex-grow:1;font-size:1.1em;padding:16px}
    .explore-results-list{display:flex;flex-direction:column;gap:12px;max-height:40vh;overflow-y:auto}
    .explore-results-list .place-card{padding:10px;border:1px solid #eee;border-radius:8px;background:#fafbff}
    .explore-results-list .place-card small{font-size:0.95em}
    .explore-results-list .place-card strong{font-size:1.05em}
    .explore-results-list .place-card .btn-ghost{padding:5px;font-size:12px;margin-top:5px}
    .orientation-results-box {
        border: 2px solid #ddd;
        background-color: #f8f9fb;
        padding: 1.5rem;
        margin-top: 1rem;
        min-height: 50px;
        border-radius: 8px;
        font-size: 1.1em;
        line-height: 1.6;
    }
    .error-message { color: #dc3545; font-weight: bold; }
    .success-message { color: #28a745; font-weight: bold; }
    .info-message { color: #17a2b8; font-weight: bold; }
    .output-line { display: block; margin-bottom: 0.5em; }
    .reliability-high { font-weight: bold; color: #28a745; }
    .reliability-medium { font-weight: bold; color: #ffc107; }
    .reliability-low { font-weight: bold; color: #dc3545; }
    .warning-message { color: #ff9800; font-weight: bold; }
    
    /* üÜï STILI EXPERT MODE */
    .expert-mode-badge {
        background: linear-gradient(135deg, #ff6b6b, #feca57);
        color: white;
        padding: 8px 16px;
        border-radius: 20px;
        font-size: 0.85em;
        font-weight: 700;
        display: inline-block;
        margin-left: 10px;
        box-shadow: 0 2px 8px rgba(255,107,107,0.3);
    }
    
    .transparency-report {
        background: linear-gradient(135deg, #e3f2fd, #fff3e0);
        border: 2px solid #2196f3;
        border-radius: 10px;
        padding: 15px;
        margin: 15px 0;
        font-size: 0.95em;
        line-height: 1.7;
    }
    
    .transparency-report strong {
        color: #1976d2;
        font-size: 1.05em;
    }
    
    .sv-candidate-marker {
        background: #ff6b6b !important;
        border: 3px solid white !important;
        box-shadow: 0 0 0 2px #ff6b6b;
    }
    
    .sv-selected-marker {
        background: #28a745 !important;
        border: 3px solid white !important;
        box-shadow: 0 0 0 2px #28a745, 0 0 15px rgba(40,167,69,0.5);
        animation: pulse 2s infinite;
    }
    
    @keyframes pulse {
        0%, 100% { transform: scale(1); }
        50% { transform: scale(1.15); }
    }
    
    .interpolation-warning {
        background: #fff3cd;
        border-left: 5px solid #ffc107;
        padding: 12px;
        margin: 10px 0;
        border-radius: 5px;
        font-size: 0.95em;
    }
    
    .vector-info {
        background: #e8f5e9;
        border-left: 5px solid #4caf50;
        padding: 12px;
        margin: 10px 0;
        border-radius: 5px;
        font-size: 0.95em;
    }
    
    /* STILI RAY CASTING - ANALISI SICUREZZA ATTRAVERSAMENTI */
    .safety-alert {
        margin-top: 15px;
        padding: 12px 16px;
        border-radius: 8px;
        font-size: 1.05em;
        line-height: 1.5;
        border-left: 4px solid;
    }
    
    .safety-alert.safe {
        background: #d4edda;
        border-color: #28a745;
        color: #155724;
    }
    
    .safety-alert.warning {
        background: #fff3cd;
        border-color: #ffc107;
        color: #856404;
    }
    
    .safety-alert.danger {
        background: #f8d7da;
        border-color: #dc3545;
        color: #721c24;
        font-weight: 600;
    }
    
    .safety-alert.unknown {
        background: #e2e3e5;
        border-color: #6c757d;
        color: #383d41;
    }
    
    .raycasting-loading {
        display: inline-block;
        margin-left: 8px;
        font-size: 0.9em;
        color: #6c757d;
        font-style: italic;
    }
    
    .search-radius-control {
        margin: 15px 0;
        padding: 15px;
        background: #f1f3f5;
        border-radius: 8px;
    }
    
    .search-radius-control label {
        display: block;
        margin-bottom: 8px;
        font-weight: 600;
        color: #495057;
    }
    
    .search-radius-control input[type="range"] {
        width: 100%;
        margin: 10px 0;
    }
    
    .search-radius-control .range-value {
        text-align: center;
        font-size: 1.2em;
        font-weight: bold;
        color: #667eea;
    }
    .cat-item.hidden{display:none}
    /* Nascondi visivamente ma mantieni per screen reader */
    .sr-only {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0,0,0,0);
        white-space: nowrap;
        border-width: 0;
    }
    /* Skip Links */
    .skip-links {
        position: absolute;
        top: -100px;
        left: 0;
        z-index: 100000;
    }
    .skip-link {
        position: absolute;
        padding: 10px 20px;
        background: #000;
        color: #fff;
        text-decoration: none;
        font-weight: bold;
        border: 2px solid #fff;
        border-radius: 0 0 8px 0;
    }
    .skip-link:focus {
        top: 0;
        left: 0;
        outline: 3px solid #ffcc00;
        outline-offset: 2px;
    }
    /* Modalit√† Alto Contrasto */
    @media (prefers-contrast: high) {
        body { background: #000; color: #fff; }
        .card, .modal-content, .orientation-results-box { 
            background: #000; 
            border: 3px solid #fff;
            color: #fff;
        }
        .btn { 
            background: #fff; 
            color: #000; 
            border: 3px solid #fff;
        }
        .btn:hover, .btn:focus { 
            background: #ffcc00; 
            color: #000;
            border-color: #ffcc00;
        }
        input, select { 
            background: #000; 
            color: #fff; 
            border: 3px solid #fff;
        }
        .header { background: #000; border-bottom: 3px solid #fff; }
    }
    @media (max-width:1024px){.map-grid,.options-grid{grid-template-columns:1fr}}
  
.guide-icon {
  position: fixed;
  bottom: 90px;
  right: 20px;
  width: 60px;
  height: 60px;
  background: linear-gradient(135deg, #28a745, #20c997);
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  color: white;
  font-size: 28px;
  cursor: pointer;
  box-shadow: 0 4px 15px rgba(0,0,0,.3);
  z-index: 1000;
  transition: transform .2s;
}
.guide-icon:hover {
  transform: scale(1.1);
}

.guide-modal .modal-content {
  max-width: 900px;
  max-height: 85vh;
  overflow-y: auto;
}

.guide-section {
  margin: 25px 0;
  padding: 20px;
  background: #f8f9fa;
  border-left: 4px solid #28a745;
  border-radius: 8px;
}

.guide-section h3 {
  color: #28a745;
  margin-top: 0;
  margin-bottom: 15px;
  font-size: 1.3em;
}

.guide-section h4 {
  color: #495057;
  margin-top: 20px;
  margin-bottom: 10px;
  font-size: 1.1em;
}

.guide-step {
  margin: 12px 0;
  padding-left: 20px;
  line-height: 1.8;
}

.guide-tip {
  background: #d1ecf1;
  border-left: 4px solid #17a2b8;
  padding: 15px;
  margin: 15px 0;
  border-radius: 6px;
}

.guide-warning {
  background: #fff3cd;
  border-left: 4px solid #ff9800;
  padding: 15px;
  margin: 15px 0;
  border-radius: 6px;
}

.guide-code {
  background: #2d2d2d;
  color: #f8f8f2;
  padding: 15px;
  border-radius: 6px;
  font-family: monospace;
  font-size: 0.9em;
  margin: 10px 0;
  overflow-x: auto;
}

.guide-kbd {
  background: #e9ecef;
  border: 1px solid #adb5bd;
  border-radius: 4px;
  padding: 2px 6px;
  font-family: monospace;
  font-size: 0.9em;
}

</style>
</head>
<body class="api-setup-active">

<div id="apiKeySetup">
  <h2>üîë Configurazione API Key Google Maps</h2>
  
  <div class="info-box">
    <strong>‚ÑπÔ∏è Privacy</strong><br>
    La tua chiave API sar√† salvata <strong>solo nel tuo browser</strong> (localStorage).
  </div>
  
  <div class="warning-box">
    <strong>‚ö†Ô∏è Come ottenere la API Key (5 minuti):</strong>
    <ol>
      <li>Vai su <a href="https://console.cloud.google.com/google/maps-apis" target="_blank" rel="noopener">Google Cloud Console</a></li>
      <li>Crea un progetto</li>
      <li>Abilita: Maps JavaScript API, Places API, Directions API, Geocoding API</li>
      <li>Vai su "Credenziali" ‚Üí "Crea credenziali" ‚Üí "Chiave API"</li>
      <li>Copia la chiave qui sotto</li>
    </ol>
    <small>üí∞ quote gratuite mensili (vedi dettagli sopra).</small>
  </div>
  
  <label for="apiKeyInput" style="font-weight:600;display:block;margin-top:20px">Inserisci la tua API Key:</label>
  <input type="password" id="apiKeyInput" placeholder="AIzaSy..." autocomplete="off">
  <span class="show-key-toggle" id="toggleKeyBtn">üëÅÔ∏è Mostra/Nascondi</span>
  
  <div class="button-group">
    <button class="btn btn-green" id="saveKeyBtn">üíæ Salva e Avvia App</button>
    <button class="btn btn-secondary" id="testKeyBtn">üß™ Testa Validit√†</button>
  </div>
  
  <div id="apiKeyStatus" style="margin-top:20px;text-align:center"></div>
</div>

<!-- Skip Links per navigazione rapida -->
  <div class="skip-links">
    <a href="#mainContent" class="skip-link">Salta al contenuto principale</a>
    <a href="#searchSection" class="skip-link">Salta alla ricerca luoghi</a>
    <a href="#mapSection" class="skip-link">Salta alla mappa</a>
    <a href="#orientationSection" class="skip-link">Salta all'orientamento</a>
  </div>

  <!-- Regione di annunci live per screen reader -->
  <div id="sr-announcements" class="sr-only" role="status" aria-live="polite" aria-atomic="true"></div>

  <div id="mainAppWrapper">
    <div class="container" id="mainContainer">
      <header class="header" id="topHeader" role="banner">
        <h1>üö∂ App Mobilit√† e Orientamento</h1>
        <p>Assistente testuale per l'esplorazione urbana e l'orientamento civico</p>
        <div style="margin-top:10px">
          <span style="background:rgba(255,255,255,0.2);padding:5px 15px;border-radius:20px;display:inline-block;font-size:0.9em;font-weight:600"></span>
          <span class="expert-mode-badge">EXPERT MODE</span>
        </div>
      </header>

      <main role="main" id="mainContent">

      <section aria-labelledby="section1-heading" role="search">
      <div class="section-divider">
        <h2 id="section1-heading">üìç Sezione 1: Punto di Partenza</h2>
        <p>Inserisci un indirizzo completo per iniziare.</p>
      </div>
      <div class="card">
        <div class="search-box">
          <input type="text" id="addressInput" placeholder="Es: Via Nazionale 6, Roma" aria-label="Inserisci indirizzo di partenza" aria-describedby="addressInputHelp">
          <span id="addressInputHelp" class="sr-only">Inserisci un indirizzo completo con via, numero civico e citt√†</span>
          <button id="searchButton" class="btn" onclick="searchLocation()" aria-label="Cerca l'indirizzo inserito">üîç Cerca</button>
          <!-- Pulsante GPS rimosso -->
          <!-- Pulsante GPS rimosso -->
        </div>
        
        <!-- üÜï CONTROLLO RAGGIO DI RICERCA EXPERT MODE -->
        <div class="search-radius-control">
          <label for="searchRadius">üîç Raggio di Ricerca Street View (Expert Mode)</label>
          <input type="range" id="searchRadius" min="30" max="100" value="60" step="10" 
                 oninput="document.getElementById('radiusValue').textContent = this.value"
                 aria-label="Seleziona raggio di ricerca in metri">
          <div class="range-value"><span id="radiusValue">60</span> metri</div>
          <small style="color: #6c757d; display: block; margin-top: 5px;">
            üí° Pi√π alto = trova pi√π punti ma potrebbe essere meno preciso. Consigliato: 50-70m
          </small>
        </div>
      </div>
      </section>

      <section aria-labelledby="section2-heading" id="mapSection" style="display:none;">
      <div class="section-divider">
        <h2 id="section2-heading">üó∫Ô∏è Sezione 2: Mappa e Street View</h2>
        <p>Esplora l'area con la mappa 2D o con la visuale a livello della strada.</p>
      </div>
      <div class="map-grid" id="mapGrid" style="display:none;">
        <div class="map-box">
          <div class="map-label" aria-hidden="true" tabindex="-1">üó∫Ô∏è MAPPA</div>
          <div id="map"></div>
        </div>
        <div class="map-box">
          <div class="map-label" aria-hidden="true" tabindex="-1">üëÅÔ∏è STREET VIEW</div>
          <div id="streetview" tabindex="0" role="application" aria-label="Google Street View"></div>
          
          <div class="sv-controls" aria-label="Controlli Street View">
            <div class="control-row">
              <button class="control-btn" onclick="movePov('up')" title="Guarda in alto">SU</button>
            </div>
            <div class="control-row">
              <button class="control-btn" onclick="movePov('left')" title="Guarda a sinistra">SINISTRA</button>
              <button class="control-btn" onclick="moveForward()" title="Vai avanti">AVANTI</button>
              <button class="control-btn" onclick="movePov('right')" title="Guarda a destra">DESTRA</button>
            </div>
            <div class="control-row">
              <button class="control-btn" onclick="movePov('down')" title="Guarda in basso">GI√ô</button>
            </div>
            <div class="control-row" style="margin-top: 10px;">
              <button class="control-btn" onclick="moveBackward()" title="Vai indietro">INDIETRO</button>
            </div>
            <div class="control-row" style="margin-top: 10px;">
              <button class="control-btn" onclick="resetStreetView()" title="Resetta alla posizione iniziale" style="background: #ffc107; border-color: #ffc107; color: #000;">üîÑ RESET</button>
            </div>
          </div>

          <div id="svInfo" class="sv-live" role="status" aria-live="polite" aria-atomic="true" style="display:none">
            <div><strong>üìç Indirizzo:</strong> <span id="svAddress">-</span></div>
            <div><strong>üß≠ Direzione:</strong> <span id="svDirection">-</span></div>
          </div>
        </div>
      </div>
      
      <div class="card" id="staticLinkCard" style="display:none; margin-top: -10px; text-align: center;">
        <p style="margin-bottom: 10px; color: #6c757d;">Usa questo link per aprire l'immagine statica di Street View (per screenshot):</p>
        <a id="staticStreetViewLink" href="#" target="_blank" class="btn btn-secondary">üîó Apri Immagine Street View Statica</a>
      </div>

      <div class="card" id="orientationResultCard" style="display:none; margin-top: 10px; background: linear-gradient(135deg, #e3f2fd, #f3e5f5); border-left: 5px solid #667eea;">
        <h3 style="margin: 0 0 15px 0; color: #667eea;">üß≠ Orientamento Edificio</h3>
        
        <div style="margin-bottom: 15px;">
          <button class="btn" onclick="runCivicAnalysisCascade()" aria-label="üîÑ Ricalcola Orientamento" style="font-size: 1.05em; padding: 14px 20px;">
            üéØ Analizza Orientamento
          </button>
          <p style="margin: 8px 0 0 0; font-size: 0.9em; color: #666;">
            Sistema intelligente a 4 tentativi: Street View diretto, vicini stesso lato, vicini lato opposto, calcolo geometrico
          </p>
        </div>
        
        <!-- üÜï RAPPORTO DI TRASPARENZA EXPERT MODE -->
        <div id="transparencyReport" class="transparency-report" style="display:none">
          <strong>üìä Rapporto di Trasparenza (Expert Mode)</strong>
          <div id="transparencyContent" style="margin-top:10px"></div>
        </div>
        
        <div id="orientation-status" class="orientation-results-box" style="background: white; margin: 0;" aria-live="polite">
          Premi il pulsante qui sopra per analizzare l'orientamento dell'edificio.
        </div>
        
        <div id="turn-instruction-wrapper" style="margin-top: 15px; display: none;">
          <label for="desired-direction" class="option-label">Per andare verso:</label>
          <select id="desired-direction" style="padding: 10px; border-radius: 6px; border: 2px solid #dee2e6; font-size: 15px; margin-bottom: 10px; width: 100%; max-width: 250px;">
            <option value="">-- Seleziona direzione --</option>
            <option value="N">Nord</option>
            <option value="NE">Nord-Est</option>
            <option value="E">Est</option>
            <option value="SE">Sud-Est</option>
            <option value="S">Sud</option>
            <option value="SW">Sud-Ovest</option>
            <option value="W">Ovest</option>
            <option value="NW">Nord-Ovest</option>
          </select>
          
          <div id="turn-instruction-status" class="orientation-results-box" style="background: white; margin-top: 10px;" aria-live="polite">
            Seleziona una direzione qui sopra per vedere come girare quando esci dall'edificio.
          </div>
        </div>
      </div>
      </section>

      <section aria-labelledby="section3-heading" role="region" id="searchSection" style="display:none;">
      <div class="section-divider">
        <h2 id="section3-heading">üîé Sezione 3: Cerca nelle Vicinanze</h2>
        <p>Usa i pulsanti per ottenere informazioni sull'area intorno al punto di partenza.</p>
      </div>
      <div class="card" id="searchCard" style="display:none;">
        <div class="options-grid">
          <div>
            <label class="option-label" for="radiusInput">Raggio (metri):</label>
            <input type="number" id="radiusInput" value="500" min="100" max="5000" step="100">
          </div>
          <div>
            <label class="option-label" for="categorySearch">Cerca Categorie:</label>
            <input type="search" id="categorySearch" oninput="filterCategories()" placeholder="Cerca es. farmacia, bar..." 
                   style="width: 100%; padding: 10px; margin-bottom: 10px; border: 2px solid #dee2e6; border-radius: 8px; font-size: 15px;">
            
            <label class="option-label">Categorie Google Places:</label>
            <div class="cats-wrapper"><div id="catsGrid" class="cats-grid"></div></div>
            <div id="catsSummary" class="summary">Nessuna categoria selezionata (user√≤ le quotidiane).</div>
          </div>
          <div class="tools-sticky">
            <div id="tools-group" style="display:flex;flex-direction:column;gap:8px">
              <button class="btn" onclick="searchPlaces()">üîé Cerca Luoghi (Google)</button>
              <button class="btn btn-secondary" onclick="fetchWeather()">‚òÄÔ∏è Meteo Ora</button>
              <button class="btn btn-secondary" onclick="fetchTransitlandStops()">üöå Fermate Reali (Proxy)</button>
              <button class="btn btn-secondary" onclick="listOSMIntersections()">üß≠ Incroci (Proxy)</button>
              <button class="btn btn-secondary" onclick="listOSMPlacesAll()">üó∫Ô∏è POI OSM (Proxy)</button>
              <button class="btn btn-ghost" onclick="prepareSocialPrompt()">üí¨ Ricerca Social (Prompt)</button>
              <button class="btn btn-ghost" onclick="prepareStopsNearbyPrompt()">üöè Fermate Vicine (Prompt)</button>
              <button class="btn btn-ghost" onclick="prepareTransportAnalysisPrompt()">üöå Analisi Trasporto (Prompt)</button>
              </div>
          </div>
        </div>
        <div id="weatherResults" class="osm-results" style="display:none"></div>
      </div>

      <div class="section-divider" id="resultsSection" style="display:none;">
        <h2>üìã Sezione 4: Risultati della Ricerca</h2>
        <p>Scegli un'azione dal menu a tendina per ogni luogo.</p>
      </div>
      <div class="card" id="resultsCard" style="display:none;">
        <div class="places-container" id="placesList"></div>
      </div>

      <div class="section-divider" id="customRouteSection" style="display:none;">
        <h2>üéØ Sezione 5: Percorso Personalizzato</h2>
        <p>Inserisci una destinazione qualsiasi per avere le istruzioni di percorso.</p>
      </div>
      <div class="card" id="customRouteCard" style="display:none;">
        <div class="search-box">
          <input type="text" id="customDest" placeholder="Es: Piazza del Duomo, Roma">
          
          <select id="customRouteMode" onchange="toggleMoovitButton()">
            <option value="WALKING">üö∂ A piedi</option>
            <option value="TRANSIT">üöå Mezzi Pubblici</option>
            <option value="BICYCLING">üö¥ In Bici</option>
            <option value="DRIVING">üöó In Auto</option>
          </select>

          <button class="btn btn-green" onclick="calculateCustomRoute()">Calcola Percorso</button>
          
          <!-- Pulsante Moovit - visibile solo con Mezzi Pubblici -->
          <button id="moovitButton" class="btn" onclick="openMoovitModal()" style="display:none; background: linear-gradient(135deg, #50c878, #32a852);" title="Apri percorso in Moovit">
            üöç Apri in Moovit
          </button>
        </div>
      </div>
      </section>

    </div> <div id="modal" class="modal" role="dialog" aria-modal="true" aria-labelledby="modalHeader">
      <div class="modal-content">
        <div id="modalHeader" class="modal-header"></div>
        <div id="modalBody"></div>
      </div>
    </div>

    <div id="navigationView" role="dialog" aria-modal="true" aria-labelledby="navTitle">
      <div id="navHeader">
        <h2 id="navTitle">Navigazione Passo-Passo</h2>
        <button class="btn" onclick="exitNavigation()" aria-label="Esci dalla modalit√† di navigazione">Esci da Navigazione</button>
      </div>
      
      <div id="navSummaryInfo" role="status" aria-live="polite" style="text-align: center; font-size: 1.2em; font-weight: 600; color: #495057; margin: 10px 0;"></div>
      
      <div id="navStepInfo" role="status" aria-live="polite">Passo 1 di N</div>
      <div id="navInstruction" tabindex="0" role="status" aria-live="assertive" aria-atomic="true">
          Istruzione di navigazione...
        </div>
      <div id="navTransitInfo" role="status" aria-live="polite" style="display:none;">Dettagli mezzo pubblico...</div>
      
      <div class="nav-explore-tools" role="group" aria-label="Strumenti esplorazione durante navigazione">
        <button class="btn btn-secondary" onclick="exploreStep('google')">üì° Esplora Servizi (Google)</button>
        <button class="btn btn-secondary" onclick="exploreStep('osm')">üß≠ Esplora Incroci (OSM)</button>
        <!-- Pulsante Transitland rimosso (richiede proxy) -->
        <button class="btn btn-secondary" onclick="exploreStep('osm_poi')">üó∫Ô∏è Esplora POI (OSM)</button>
        <button id="navFindAddressBtn" class="btn btn-ghost" onclick="findAddressForCurrentStep()">üìç Trova Indirizzo Passo</button>
        <button id="navReturnButton" class="btn btn-green" onclick="calculateReturnTrip()" style="display:none; width: 100%; margin-top: 10px;">
          ‚èé TORNA AL PUNTO DI PARTENZA (A PIEDI)
        </button>
      </div>

      <a id="navGoogleMapsLink" class="btn btn-ghost" href="#" target="_blank" rel="noopener noreferrer" aria-label="Apri questo passo su Google Maps in una nuova scheda">üó∫Ô∏è Vedi Passo su Google Maps</a>
      <div class="nav-controls" role="group" aria-label="Controlli navigazione">
        <button id="navPrevButton" class="btn" onclick="navPrevStep()" aria-label="Vai al passo precedente. Scorciatoia: Control pi√π freccia sinistra">‚¨ÖÔ∏è Passo Precedente</button>
        <button id="navNextButton" class="btn" onclick="navNextStep()" aria-label="Vai al passo successivo. Scorciatoia: Control pi√π freccia destra">Passo Successivo ‚û°Ô∏è</button>
      </div>
    </div>

    <!-- ============================================================ -->
    <!-- SEZIONE 7: CONFRONTO CIVICI (SCIENTIFICO) - FASE 1+2+3 -->
    <!-- ============================================================ -->
    <section aria-labelledby="section7-heading" style="margin-top: 30px;">
      <div class="section-divider" style="border-left: 5px solid #ff9800;">
        <h2 id="section6-heading" style="color: #e65100;">‚öñÔ∏è Sezione 6: Confronto Civici (Scientifico)</h2>
        <p>Usa la matematica e la validazione incrociata per capire se due civici sono sullo stesso marciapiede.</p>
      </div>
      
      <div class="card" style="background: #fff8e1; border-left: 4px solid #ff9800;">
        <h3 style="color: #e65100; margin: 0 0 15px 0;">üî¨ Analisi Multi-Metodo</h3>
        <p style="color: #666; margin-bottom: 20px; line-height: 1.6;">
          Questo strumento combina <strong>3 metodi scientifici</strong>:
        </p>
        <ul style="color: #666; margin-bottom: 20px; line-height: 1.8;">
          <li>üìä <strong>Check Precisione</strong> - Verifica se i civici sono esatti o interpolati</li>
          <li>üìê <strong>Calcolo Geometrico</strong> - Prodotto vettoriale con geometria OpenStreetMap</li>
          <li>üëÅÔ∏è <strong>Validazione Street View</strong> - Conferma visiva prospettica</li>
        </ul>
        
        <div class="options-grid" style="grid-template-columns: 1fr 1fr auto; gap: 15px; margin-bottom: 20px;">
          <div>
            <label class="option-label" for="addressA">Civico A (Riferimento):</label>
            <input type="text" 
                   id="addressA" 
                   placeholder="Es: Via Po 18, Torino" 
                   style="width: 100%; padding: 12px; border: 2px solid #ffcc80; border-radius: 8px; font-size: 1em;"
                   aria-describedby="addressA-help">
            <small id="addressA-help" style="color: #666; font-size: 0.85em;">Inserisci indirizzo completo con civico</small>
          </div>
          
          <div>
            <label class="option-label" for="addressB">Civico B (Destinazione):</label>
            <input type="text" 
                   id="addressB" 
                   placeholder="Es: Via Po 25, Torino" 
                   style="width: 100%; padding: 12px; border: 2px solid #ffcc80; border-radius: 8px; font-size: 1em;"
                   aria-describedby="addressB-help">
            <small id="addressB-help" style="color: #666; font-size: 0.85em;">Deve essere sulla stessa via di A</small>
          </div>
          
          <div style="align-self: end;">
            <button class="btn" 
                    onclick="runComparison()" 
                    style="background: linear-gradient(135deg, #ff9800, #f57c00); padding: 14px 24px; font-size: 1.05em; font-weight: bold;"
                    aria-label="Avvia confronto scientifico tra i due civici">
              üìê Calcola Posizione
            </button>
          </div>
        </div>
        
        <div id="comparison-results" 
             class="orientation-results-box" 
             style="margin-top: 15px; background: white; border: 2px solid #ffcc80; border-radius: 12px; padding: 20px; min-height: 100px;" 
             role="region"
             aria-live="polite"
             aria-label="Risultati confronto civici">
          <div style="text-align: center; color: #999; padding: 40px 20px;">
            <p style="font-size: 1.1em; margin: 0 0 10px 0;">üîç Pronto per l'analisi</p>
            <p style="margin: 0; font-size: 0.9em;">
              Inserisci due indirizzi sulla <strong>stessa via</strong> per confrontarli scientificamente.
            </p>
          </div>
        </div>
        
        <!-- Help Box -->
        <details style="margin-top: 20px;">
          <summary style="cursor: pointer; color: #e65100; font-weight: bold; padding: 10px; background: #fff3e0; border-radius: 8px;">
            üí° Come funziona il confronto?
          </summary>
          <div style="margin-top: 10px; padding: 15px; background: white; border-left: 4px solid #ff9800; border-radius: 8px;">
            <p style="margin: 0 0 10px 0;"><strong>Quando usarlo:</strong></p>
            <ul style="margin: 0 0 15px 0; padding-left: 20px; line-height: 1.8;">
              <li><strong>Il Vicino di Casa:</strong> Sei al civico 20 (dove c'√® Street View) e devi andare al 24 (dove non c'√®). Vuoi sapere se devi attraversare.</li>
              <li><strong>La Verifica Scientifica:</strong> Street View sembra ambiguo? Vuoi una conferma matematica.</li>
              <li><strong>Pianificazione a Tavolino:</strong> Sei a casa e vuoi capire la conformazione di una via inserendo due civici.</li>
            </ul>
            
            <p style="margin: 0 0 10px 0;"><strong>I 3 metodi combinati:</strong></p>
            <ol style="margin: 0; padding-left: 20px; line-height: 1.8;">
              <li><strong>Check Precisione:</strong> Verifica se Google conosce esattamente i civici (ROOFTOP) o li ha "indovinati" (INTERPOLATED)</li>
              <li><strong>Calcolo Geometrico:</strong> Usa il prodotto vettoriale con la geometria OpenStreetMap per determinare matematicamente su quale lato sono i civici</li>
              <li><strong>Validazione Street View:</strong> Controlla visivamente se i due punti si "guardano" in modo parallelo (stesso lato) o opposto (lati opposti)</li>
            </ol>
            
            <p style="margin: 15px 0 0 0; padding: 10px; background: #e8f5e9; border-radius: 6px; font-size: 0.9em;">
              <strong>‚úÖ Risultato:</strong> Riceverai un verdetto con score combinato (0-100) e segnalazione di eventuali discordanze tra i metodi!
            </p>
          </div>
        </details>
      </div>
    </section>
  
  </main>
  </div>

<div class="settings-icon" id="settingsIcon" title="Gestisci API Key">‚öôÔ∏è</div>

<!-- Pulsante Guida -->
<div class="guide-icon" id="guideIcon" title="Guida completa all'uso dell'app">üìñ</div>

<div id="apiKeyModal" class="modal">
  <div class="modal-content">
    <div class="modal-header">üîë Gestione API Key</div>
    <div style="padding:20px">
      <p><strong>Stato:</strong> <span id="currentApiStatus"></span></p>
      <p style="margin-top:15px"><strong>Chiave:</strong></p>
      <input type="password" id="newApiKeyInput" placeholder="Nuova API Key..." style="width:100%;padding:12px;border:2px solid #dee2e6;border-radius:8px;margin-top:10px;font-family:monospace">
      <span class="show-key-toggle" id="toggleNewKeyBtn">üëÅÔ∏è Mostra/Nascondi</span>
      
      <div class="modal-buttons">
        <button class="btn btn-green" id="updateKeyBtn">üíæ Aggiorna</button>
        <button class="btn btn-danger" id="removeKeyBtn">üóëÔ∏è Rimuovi</button>
        <button class="btn btn-ghost" id="closeModalBtn">‚ùå Chiudi</button>
      </div>
    </div>
  </div>
</div>

<script>
// ===== CODICE APP ORIGINALE (deve essere PRIMA della gestione API) =====
// ===============================================================================
    //  - ROUTES FIX (CHIAMATE MULTIPLE)
    // ===============================================================================
    // 
    // üÜï MODIFICHE  - SOLUZIONE DEFINITIVA LINEE:
    //
    // 1. CHIAMATA SEPARATA PER OGNI FERMATA
    //    - Prima: 1 chiamata per 20 fermate ‚Üí nessuna linea
    //    - Ora: 1 + N chiamate (es. 1 + 20) ‚Üí tutte le linee recuperate!
    //
    // 2. FUNZIONE fetchRoutesForStop()
    //    - Prova 3 endpoint diversi per ogni fermata
    //    - Fallback multipli per massima compatibilit√†
    //    - Gestione timeout e errori per ogni chiamata
    //
    // 3. PROMISE.ALL per Parallelizzazione
    //    - Tutte le chiamate route in parallelo
    //    - Veloce quanto possibile (non sequenziale)
    //    - Progress logging per vedere l'avanzamento
    //
    // 4. SEMPRE LE LINEE
    //    - "Linee non disponibili" ‚Üí solo se API non risponde
    //    - "Recupero in corso..." ‚Üí mentre carica
    //    - "40, 60, H, 170" ‚Üí quando recuperate!
    //
    // ‚ö†Ô∏è NOTA: Pi√π lento della  ma FUNZIONA!
    //    - 20 fermate = 21 chiamate API totali
    //    - Tempo stimato: 5-10 secondi con buona connessione
    //    - Vale la pena per avere le linee!
    //
    // -------------------------------------------------------------------------------
    // 
    // üîÑ MODIFICHE  (Improvements & Hardening):
    //
    // 1. SAFE FETCH con TIMEOUT
    //    - Tutte le chiamate di rete ora usano safeFetch()
    //    - Timeout esplicito di 7 secondi
    //    - Messaggi di errore uniformi e chiari
    //
    // 2. DEBUG MODE
    //    - Costante DEBUG = false per disabilitare log in produzione
    //    - debugLog() per log condizionali
    //    - Puoi impostare DEBUG = true per troubleshooting
    //
    // 3. FUNZIONI HELPER CENTRALIZZATE
    //    - getReliabilityLabel(score) per etichette consistenti
    //    - announceError/Success/Warning() per screen reader
    //    - addLowReliabilityWarning() per disclaimer standard
    //
    // -------------------------------------------------------------------------------
    // 
    // üîÑ MODIFICHE  (Transitland Fix):
    //
    // 1. SEPARAZIONE INDIRIZZO/FERMATA
    //    - Le fermate Transitland ora usano coordinate DIRETTE (non pi√π geocoding Google)
    //    - Questo elimina confusione con piazze, civici, ecc.
    //
    // 2. CALCOLO DISTANZA SEMPRE VISIBILE
    //    - Ogni fermata mostra SEMPRE la distanza dalla posizione corrente
    //    - Non pi√π "Distanza: ‚Äî" ma valori reali calcolati
    //
    // 3. LINEE CHE PASSANO ALLA FERMATA
    //    - Ogni fermata mostra le linee (40, 60, H, ecc.)
    //    - Con  funziona davvero!
    //
    // 4. ETICHETTA DIREZIONE COMPRENSIBILE
    //    - Ogni fermata mostra "lato N/S/E/O della strada" o "direzione X"
    //    - Facilita la distinzione tra fermate sulla stessa via
    //
    // 5. FERMATA COME PUNTO DI PARTENZA
    //    - Quando selezioni una fermata come partenza, usa le sue coordinate esatte
    //    - Street View, orientamento, tutto centrato sulla fermata (non su geocoding)
    //
    // ===============================================================================
    
    // ---------------
    // VARIABILI GLOBALI
    // ---------------
    
    // NOTA: Inserisci qui la tua chiave API Google
    // PROXY_BASE_URL rimosso - uso API dirette
    
    // ... (CATEGORIE E LABEL OMESSE) ...
    const CATEGORIES =['accounting','administrative_area_level_1','administrative_area_level_2','administrative_area_level_3','administrative_area_level_4','administrative_area_level_5','airport','amusement_park','aquarium','art_gallery','atm','bakery','bank','bar','beauty_salon','bicycle_store','book_store','bowling_alley','bus_station','cafe','campground','car_dealer','car_rental','car_repair','car_wash','casino','cemetery','church','city_hall','clothing_store','colloquial_area','convenience_store','country','courthouse','dentist','department_store','doctor','drugstore','electrician','electronics_store','embassy','establishment','finance','fire_station','floor','florist','food','funeral_home','furniture_store','gas_station','general_contractor','geocode','grocery_or_supermarket','gym','hair_care','hardware_store','health','hindu_temple','home_goods_store','hospital','insurance_agency','intersection','jewelry_store','laundry','lawyer','library','light_rail_station','liquor_store','local_government_office','locality','locksmith','lodging','meal_delivery','meal_takeaway','mosque','movie_rental','movie_theater','moving_company','museum','natural_feature','neighborhood','night_club','painter','park','parking','pet_store','pharmacy','physiotherapist','place_of_worship','plumber','point_of_interest','police','political','post_box','post_office','postal_code','postal_code_prefix','postal_code_suffix','postal_town','premise','primary_school','real_estate_agency','restaurant','roofing_contractor','room','route','rv_park','school','secondary_school','shoe_store','shopping_mall','spa','stadium','storage','store','street_address','street_number','sublocality','sublocality_level_1','sublocality_level_2','sublocality_level_3','sublocality_level_4','sublocality_level_5','subpremise','subway_station','supermarket','synagogue','taxi_stand','tourist_attraction','town_square','train_station','transit_station','travel_agency','university','veterinary_care','zoo'];
    const LABELS = {'accounting':'Commercialista','administrative_area_level_1':'Regione','administrative_area_level_2':'Provincia','administrative_area_level_3':'Comune','administrative_area_level_4':'Circoscrizione','administrative_area_level_5':'Quartiere','airport':'Aeroporto','amusement_park':'Parco divertimenti','aquarium':'Acquario','art_gallery':'Galleria d\'arte','atm':'Bancomat','bakery':'Panetteria/Pasticceria','bank':'Banca','bar':'Bar','beauty_salon':'Salone di bellezza','bicycle_store':'Negozio di biciclette','book_store':'Libreria','bowling_alley':'Bowling','bus_station':'Stazione autobus','cafe':'Caff√®','campground':'Campeggio','car_dealer':'Concessionario auto','car_rental':'Noleggio auto','car_repair':'Autofficina','car_wash':'Autolavaggio','casino':'Casin√≤','cemetery':'Cimitero','church':'Chiesa','city_hall':'Municipio','clothing_store':'Negozio di abbigliamento','colloquial_area':'Area informale','convenience_store':'Mini market','country':'Nazione','courthouse':'Tribunale','dentist':'Dentista','department_store':'Grandi magazzini','doctor':'Medico','drugstore':'Drugstore','electrician':'Elettricista','electronics_store':'Negozio di elettronica','embassy':'Ambasciata','establishment':'Attivit√† commerciale','finance':'Finanza','fire_station':'Vigili del fuoco','floor':'Piano (edificio)','florist':'Fioraio','food':'Cibo','funeral_home':'Impresa funebre','furniture_store':'Negozio di mobili','gas_station':'Distributore di benzina','general_contractor':'Impresa edile','geocode':'Geocodifica','grocery_or_supermarket':'Alimentari o Supermercato','gym':'Palestra','hair_care':'Parrucchiere','hardware_store':'Ferramenta','health':'Salute','hindu_temple':'Tempio ind√π','home_goods_store':'Negozio di articoli per la casa','hospital':'Ospedale','insurance_agency':'Agenzia assicurativa','intersection':'Incrocio','jewelry_store':'Gioielleria','laundry':'Lavanderia','lawyer':'Avvocato','library':'Biblioteca','light_rail_station':'Stazione metro leggera','liquor_store':'Negozio di liquori','local_government_office':'Ufficio governativo locale','locality':'Localit√† (Citt√†)','locksmith':'Fabbro','lodging':'Alloggio','meal_delivery':'Consegna pasti','meal_takeaway':'Cibo d\'asporto','mosque':'Moschea','movie_rental':'Noleggio film','movie_theater':'Cinema','moving_company':'Ditta di traslochi','museum':'Museo','natural_feature':'Elemento naturale','neighborhood':'Quartiere','night_club':'Night club','painter':'Imbianchino','park':'Parco','parking':'Parcheggio','pet_store':'Negozio di animali','pharmacy':'Farmacia','physiotherapist':'Fisioterapista','place_of_worship':'Luogo di culto','plumber':'Idraulista','point_of_interest':'Punto di interesse','police':'Polizia','political':'Sede politica','post_box':'Casella postale','post_office':'Ufficio postale','postal_code':'Codice postale','postal_code_prefix':'Prefisso codice postale','postal_code_suffix':'Suffisso codice postale','postal_town':'Citt√† postale','premise':'Sede/Stabile','primary_school':'Scuola elementare','real_estate_agency':'Agenzia immobiliare','restaurant':'Ristorante','roofing_contractor':'Copritetto','room':'Stanza','route':'Strada (percorso)','rv_park':'Area camper','school':'Scuola','secondary_school':'Scuola media/superiore','shoe_store':'Negozio di scarpe','shopping_mall':'Centro commerciale','spa':'Spa','stadium':'Stadio','storage':'Deposito','store':'Negozio','street_address':'Indirizzo stradale','street_number':'Numero civico','sublocality':'Sottolocalit√†','sublocality_level_1':'Sottolocalit√† L1','sublocality_level_2':'Sottolocalit√† L2','sublocality_level_3':'Sottolocalit√† L3','sublocality_level_4':'Sottolocalit√† L4','sublocality_level_5':'Sottolocalit√† L5','subpremise':'Sub-sede','subway_station':'Stazione metro','supermarket':'Supermercato','synagogue':'Sinoga','taxi_stand':'Stazione taxi','tourist_attraction':'Attrazione turistica','town_square':'Piazza cittadina','train_station':'Stazione ferroviaria','transit_station':'Stazione mezzi pubblici','travel_agency':'Agenzia di viaggi','university':'Universit√†','veterinary_care':'Veterinario','zoo':'Zoo'};
    const DAILY_DEFAULT = ['atm','bank','bar','cafe','restaurant','supermarket','pharmacy','hospital','bus_station','subway_station','train_station','transit_station','post_office','store','bakery'];
    
    let geocoder, service, directionsService, autocomplete, map, streetView;
    let currentLocation = null;
    let currentlyDisplayedPlaces = [];
    let cityGuess = null;
    let currentRouteSteps = [];
    let currentStepIndex = 0;
    
    // üÜï VARIABILI EXPERT MODE
    let allSVCandidates = []; // Tutti i punti Street View trovati
    let selectedSVPoint = null; // Il punto selezionato dall'algoritmo
    let targetLocation = null; // La destinazione cercata (geocoded)
    let candidateMarkers = []; // Marker sulla mappa per visualizzare i candidati
    let targetAddressType = null; // ROOFTOP o INTERPOLATED
    let buildingDirectionFromStreet = null; // Direzione calcolata

    // ========================
    // CONFIGURAZIONE DEBUG
    // ========================
    
    // Imposta a true per vedere log dettagliati nella console
    const DEBUG = true;
    
    // Funzione helper per log condizionali
    function debugLog(...args) {
      if (DEBUG) console.log(...args);
    }

    // ========================
    // UTILITY RETE
    // ========================
    
    /**
     * Wrapper sicuro per fetch con timeout e gestione errori uniforme
     * @param {string} url - URL da chiamare
     * @param {object} options - Opzioni fetch
     * @param {number} timeoutMs - Timeout in millisecondi (default: 7000)
     * @param {string} serviceName - Nome del servizio per messaggi errore
     * @returns {Promise<Response>}
     */
    async function safeFetch(url, options = {}, timeoutMs = 7000, serviceName = 'servizio') {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), timeoutMs);
      
      try {
        const response = await fetch(url, {
          ...options,
          signal: controller.signal
        });
        clearTimeout(timeoutId);
        
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        return response;
      } catch (error) {
        clearTimeout(timeoutId);
        
        if (error.name === 'AbortError') {
          throw new Error(`‚ö†Ô∏è ${serviceName} non risponde (timeout dopo ${timeoutMs/1000}s). Il risultato potrebbe essere incompleto.`);
        }
        
        throw new Error(`‚ö†Ô∏è ${serviceName} non disponibile: ${error.message}`);
      }
    }
    
    // ========================
    // UTILITY ACCESSIBILIT√Ä
    // ========================
    
    /**
     * Ottiene un'etichetta consistente per il livello di affidabilit√†
     * @param {number} score - Punteggio da 0 a 100
     * @returns {object} - {label, color, emoji}
     */
    function getReliabilityLabel(score) {
      if (score >= 80) {
        return { label: 'ALTA', color: '#28a745', emoji: 'üü¢', class: 'reliability-high' };
      } else if (score >= 50) {
        return { label: 'MEDIA', color: '#ffc107', emoji: 'üü°', class: 'reliability-medium' };
      } else {
        return { label: 'BASSA', color: '#dc3545', emoji: 'üî¥', class: 'reliability-low' };
      }
    }
    
    /**
     * Annuncia un errore allo screen reader con formato consistente
     */
    function announceError(message) {
      announceToScreenReader(`Errore: ${message}`, 'assertive');
      debugLog('‚ùå ERROR:', message);
    }
    
    /**
     * Annuncia un successo allo screen reader con formato consistente
     */
    function announceSuccess(message) {
      announceToScreenReader(`Completato: ${message}`, 'polite');
      debugLog('‚úÖ SUCCESS:', message);
    }
    
    /**
     * Annuncia un warning allo screen reader con formato consistente
     */
    function announceWarning(message) {
      announceToScreenReader(`Attenzione: ${message}`, 'polite');
      debugLog('‚ö†Ô∏è WARNING:', message);
    }
    
    /**
     * Annuncia un messaggio allo screen reader tramite regione live nascosta
     */
    function announceToScreenReader(message, priority = 'polite') {
      const announcer = document.getElementById('sr-announcements');
      if (announcer) {
        announcer.setAttribute('aria-live', priority);
        announcer.textContent = message;
        // Resetta dopo un po' per permettere nuovi annunci
        setTimeout(() => {
          announcer.textContent = '';
        }, 100);
      }
    }
    
    /**
     * Mostra un disclaimer standard quando i risultati hanno bassa affidabilit√†
     */
    function addLowReliabilityWarning() {
      return `<div style="background: #fff3cd; border-left: 4px solid #ffc107; padding: 12px; margin-top: 15px; border-radius: 6px;">
        ‚ö†Ô∏è <strong>Importante:</strong> Queste indicazioni potrebbero essere imprecise. 
        Verifica sempre con bastone e orientamento sul posto.
      </div>`;
    }
    
    /**
     * Sanitizza testo per uso sicuro in HTML
     * NOTA: Usa questa funzione quando inserisci testo proveniente da fonti esterne
     * @param {string} text - Testo da sanitizzare
     * @returns {string} - Testo con caratteri HTML escaped
     */
    function sanitizeHTML(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // ========================
    // UTILITY GENERICHE
    // ========================
    
    /**
     * Funzione chiamata dal pulsante "Calcola Posizione" della Sezione 7
     * Collega l'interfaccia utente alle funzioni scientifiche Fase 1+2+3
     */
    async function runComparison() {
        const addrA = document.getElementById('addressA').value.trim();
        const addrB = document.getElementById('addressB').value.trim();
        const resDiv = document.getElementById('comparison-results');
        
        // Validazione input
        if (!addrA || !addrB) {
            const html = `
                <div style="border-left: 5px solid #dc3545; padding: 15px; background: #fff; border-radius: 8px;">
                    <h4 style="color: #dc3545; margin: 0 0 10px 0;">‚ùå Input Mancante</h4>
                    <p style="margin: 0;">Inserisci <strong>entrambi gli indirizzi</strong> per avviare il confronto.</p>
                </div>
            `;
            updateStatus(resDiv, html, 'error', true);
            announceToScreenReader('Errore: inserisci entrambi gli indirizzi', 'assertive');
            return;
        }
        
        // Messaggio di caricamento
        updateStatus(resDiv, 'üîÑ Avvio analisi multi-metodo...', 'info');
        announceToScreenReader('Analisi avviata. Attendere.', 'polite');
        
        try {
            // Chiama la funzione "Ferrari" che √® gi√† nel codice (Fase 1+2+3)
            await compareTwoAddresses(addrA, addrB, resDiv);
            
            // Scroll verso i risultati per accessibilit√†
            resDiv.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            
        } catch (error) {
            console.error('Errore durante il confronto:', error);
            const html = `
                <div style="border-left: 5px solid #dc3545; padding: 15px; background: #fff; border-radius: 8px;">
                    <h4 style="color: #dc3545; margin: 0 0 10px 0;">‚ùå Errore Tecnico</h4>
                    <p style="margin: 0;">Si √® verificato un errore durante l'analisi: ${error.message}</p>
                    <p style="margin: 10px 0 0 0; font-size: 0.9em; color: #666;">
                        Verifica che gli indirizzi siano corretti e riprova.
                    </p>
                </div>
            `;
            updateStatus(resDiv, html, 'error', true);
            announceToScreenReader('Errore durante l\'analisi. Controlla gli indirizzi.', 'assertive');
        }
    }

    // ================================================================
    // FINE FUNZIONE SEZIONE 7
    // ================================================================

    /**
     * Sposta il focus su un elemento specifico
     */
    function moveFocusTo(elementId) {
      const element = document.getElementById(elementId);
      if (element) {
        element.focus();
        // Scroll to element if needed
        element.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
      }
    }

    /**
     * Imposta stato di caricamento su un elemento con feedback accessibile
     */
    function setLoadingState(elementId, isLoading, loadingText = 'Caricamento in corso...') {
      const element = document.getElementById(elementId);
      if (!element) return;
      
      if (isLoading) {
        element.setAttribute('aria-busy', 'true');
        if (loadingText) {
          const originalContent = element.innerHTML;
          element.setAttribute('data-original-content', originalContent);
          element.innerHTML = `<span class="loading-indicator">${loadingText}</span>`;
          announceToScreenReader(loadingText);
        }
      } else {
        element.setAttribute('aria-busy', 'false');
        const originalContent = element.getAttribute('data-original-content');
        if (originalContent) {
          element.removeAttribute('data-original-content');
        }
      }
    }

    let currentStepStartPoint = null;
    let finalDestinationPoint = null;
    let finalDestinationAddress = '';
    let originalStartPoint = null;
    let currentRouteAlternativesResult = null;
        
    let lastStreetViewLocation = null; // Coordinate dello Street View usato
    let lastStreetViewDistance = null; // Distanza dall'indirizzo allo Street View
    let lastCalculatedAddress = null; // Indirizzo per cui √® stato calcolato l'orientamento
    const RELIABILITY_THRESHOLD_METERS = 30; 
    const cardinalToDegrees = {
        'N': 0, 'NE': 45, 'E': 90, 'SE': 135, 'S': 180, 'SW': 225, 'W': 270, 'NW': 315
    };
    
    // ---------------
    // FUNZIONI DI AVVIO
    // ---------------
    
    function initMap() {
      // Verifica caricamento librerie Google Maps
      if (typeof google === 'undefined' || !google.maps) {
        notify('‚ùå Errore: Google Maps non caricato correttamente', 'error');
        announceToScreenReader('Errore nel caricamento di Google Maps', 'assertive');
        return;
      }
      
      if (!google.maps.geometry || !google.maps.geometry.spherical) {
        notify('‚ùå Errore: Libreria Geometry non caricata', 'error');
        announceToScreenReader('Errore: libreria Geometry mancante', 'assertive');
        return;
      }
      
      if (!google.maps.places || !google.maps.places.PlacesService) {
        notify('‚ùå Errore: Libreria Places non caricata', 'error');
        announceToScreenReader('Errore: libreria Places mancante', 'assertive');
        return;
      }
      
      const defaultPos = {lat: 41.9028, lng: 12.4964};
      map = new google.maps.Map(document.getElementById('map'), {center: defaultPos, zoom: 15});
      streetView = new google.maps.StreetViewPanorama(document.getElementById('streetview'), {position: defaultPos, pov: {heading: 0, pitch: 0}});
      map.setStreetView(streetView);
      geocoder = new google.maps.Geocoder();
      service = new google.maps.places.PlacesService(map);
      directionsService = new google.maps.DirectionsService();
      google.maps.event.addListener(streetView, 'position_changed', updateStreetViewInfo);
      google.maps.event.addListener(streetView, 'pov_changed', updateStreetViewInfo);
      
      buildCategoriesCheckboxes();
      initAutocomplete();
      
      document.getElementById('orientation-status').textContent = "Pronto. Inserisci un indirizzo nella Sezione 1.";
      
      notify('‚úÖ App pronta e API caricate.', 'success');
      announceToScreenReader('Applicazione caricata e pronta all\'uso', 'polite');
    }
    
    // Rendi initMap accessibile globalmente IMMEDIATAMENTE per il callback di Google Maps
    window.initMap = initMap;

    // ---------------
    // FUNZIONI HELPER
    // ... (tutte le funzioni helper come notify, formatDistance, openModal, ecc. restano invariate) ...
    // ---------------
    function notify(msg, type='info') {
      document.querySelectorAll('.notification').forEach(n => n.remove());
      const n = document.createElement('div');
      n.className = `notification ${type}`;
      n.textContent = msg;
      n.setAttribute('role', 'alert');
      n.setAttribute('aria-live', 'assertive');
      document.body.appendChild(n);
      
      // Annuncia anche tramite screen reader
      announceToScreenReader(msg, 'assertive');
      
      setTimeout(() => n.remove(), 5000);
    }

    function formatDistance(m) {
      if (!Number.isFinite(m)) return '‚Äî';
      return m >= 1000 ? (m/1000).toFixed(1).replace('.', ',') + ' km' : Math.round(m) + ' m';
    }

    function openModal(title, body) {
      const modal = document.getElementById('modal');
      document.getElementById('modalHeader').textContent = title;
      document.getElementById('modalBody').innerHTML = body;
      modal.classList.add('show');
      const f = modal.querySelector('button, textarea, input');
      if (f) f.focus();
    }

    function closeModal() {
      document.getElementById('modal').classList.remove('show');
    }

    async function copyText(text) {
      if (!navigator.clipboard) {
        try {
          const el = document.createElement('textarea');
          el.value = text;
          el.setAttribute('readonly', '');
          el.style.position = 'absolute';
          el.style.left = '-9999px';
          document.body.appendChild(el);
          el.select();
          document.execCommand('copy');
          document.body.removeChild(el);
          return true;
        } catch (e) { return false; }
      }
      try {
        await navigator.clipboard.writeText(text);
        return true;
      } catch (e) { return false; }
    }

    function getCardinalDirectionShort(heading) {
      if (heading == null || !Number.isFinite(heading)) return 'ND';
      const d = ['N', 'NE', 'E', 'SE', 'S', 'SO', 'O', 'NO'];
      const i = Math.round(((heading %= 360) < 0 ? heading + 360 : heading) / 45) % 8;
      return d[i];
    }

    function getCardinalDirectionLong(heading) {
        if (heading == null || !Number.isFinite(heading)) return 'Sconosciuta';
        const normalizedHeading = (heading % 360 + 360) % 360;
        const directions = ['Nord', 'Nord-Est', 'Est', 'Sud-Est', 'Sud', 'Sud-Ovest', 'Ovest', 'Nord-Ovest'];
        const index = Math.round(normalizedHeading / 45) % 8;
        return directions[index];
    }

    function haversineDistance(coords1, coords2) {
        const R = 6371e3; 
        const lat1 = coords1.lat * Math.PI / 180;
        const lat2 = coords2.lat * Math.PI / 180;
        const deltaLat = (coords2.lat - coords1.lat) * Math.PI / 180;
        const deltaLng = (coords2.lng - coords1.lng) * Math.PI / 180;
        const a = Math.sin(deltaLat / 2) * Math.sin(deltaLat / 2) +
                  Math.cos(lat1) * Math.cos(lat2) *
                  Math.sin(deltaLng / 2) * Math.sin(deltaLng / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return R * c; // in metri
    }

    function updateStatus(targetDiv, message, type = 'info', isHtml = false) {
        console.log(`Stato (${targetDiv.id}):`, message);
         if (isHtml) {
            targetDiv.innerHTML = message;
        } else {
            targetDiv.innerText = message;
        }
        targetDiv.classList.remove('error-message', 'success-message', 'info-message');
        if (type === 'error') targetDiv.classList.add('error-message');
        else if (type === 'success') targetDiv.classList.add('success-message');
        else if (type === 'info') targetDiv.classList.add('info-message');
    }

    // ---------------
    // FUNZIONALIT√Ä MOBILIT√Ä (Sez. 1-5)
    // ---------------
    

      // üÜï Funzione per aggiornare il location bias dell'autocomplete
      window.updateAutocompleteBias = function() {
        if (autocomplete && window.currentPosition) {
          const newLocation = new google.maps.LatLng(
            window.currentPosition.lat,
            window.currentPosition.lng
          );
          autocomplete.setBounds(
            new google.maps.Circle({
              center: newLocation,
              radius: 5000
            }).getBounds()
          );
          console.log('‚úÖ Autocomplete aggiornato con nuova posizione');
        }
      };
      
    function initAutocomplete() {
      console.log('üîç initAutocomplete chiamata');
      console.log('üìç Controllo elementi DOM...');
      
      // Opzioni base autocomplete
      const acOptions = {
        fields: ['geometry', 'formatted_address', 'name', 'address_components'],
        types: ['geocode', 'establishment'],
        componentRestrictions: {country: ['it']}
      };
      
      // üÜï Se abbiamo una posizione di partenza, usa quella per ordinare i suggerimenti per vicinanza
      if (window.currentPosition && window.currentPosition.lat && window.currentPosition.lng) {
        acOptions.location = new google.maps.LatLng(
          window.currentPosition.lat, 
          window.currentPosition.lng
        );
        acOptions.radius = 5000; // Raggio di 5km per dare priorit√† ai risultati vicini
        console.log('üìç Autocomplete configurato con location bias:', window.currentPosition);
      }

      // Autocomplete Sezione 1
      const input = document.getElementById('addressInput');
      console.log('üìç addressInput trovato:', input);
      console.log('üìç addressInput visibile:', input ? (input.offsetParent !== null) : 'N/A');
      if (!input) {
        console.error('‚ùå Input addressInput non trovato!');
        return;
      }
      
      if (!window.google || !google.maps || !google.maps.places) {
        console.error('‚ùå Google Maps Places non disponibile per autocomplete');
        notify('‚ö†Ô∏è Autocomplete non disponibile', 'error');
        return;
      }
      
      // Aggiungi attributi ARIA per autocomplete
      input.setAttribute('aria-autocomplete', 'list');
      input.setAttribute('aria-haspopup', 'listbox');
      input.setAttribute('aria-expanded', 'false');
      
      try {
        autocomplete = new google.maps.places.Autocomplete(input, acOptions);
        console.log('‚úÖ Autocomplete creato:', autocomplete);
        debugLog('‚úÖ Autocomplete inizializzato correttamente');
      } catch (error) {
        console.error('‚ùå Errore inizializzazione autocomplete:', error);
        notify('‚ö†Ô∏è Errore autocomplete: ' + error.message, 'error');
        return;
      }
      
      // Aggiorna aria-expanded quando l'autocomplete si apre/chiude
      input.addEventListener('focus', () => {
        input.setAttribute('aria-expanded', 'true');
      });
      input.addEventListener('blur', () => {
        setTimeout(() => input.setAttribute('aria-expanded', 'false'), 200);
      });
      
      input.addEventListener('keydown', e => {
        if (e.key === 'Enter') {
          e.preventDefault();
          searchLocation();
        }
      });
      
      autocomplete.addListener('place_changed', () => {
        const place = autocomplete.getPlace();
        if (place.geometry && place.geometry.location) {
          const coords = {lat: place.geometry.location.lat(), lng: place.geometry.location.lng()};
          const address = place.formatted_address || place.name;
          
          setPosition(
            coords, 
            address,
            place.address_components
          );
          
          notify('‚úÖ Indirizzo selezionato!', 'success');
          
          // üß≠ CALCOLO AUTOMATICO ORIENTAMENTO (senza await - fire and forget)
          notify('üß≠ Calibrando orientamento...', 'info');
          calculateOrientationAutomatically(coords, address)
            .catch(error => {
              console.warn("Orientamento automatico fallito:", error);
            });
        }
      });

      // Autocomplete Sezione 5
      const destInput = document.getElementById('customDest');
      const destAutocomplete = new google.maps.places.Autocomplete(destInput, acOptions);
      destInput.addEventListener('keydown', e => {
        if (e.key === 'Enter') {
          e.preventDefault();
          calculateCustomRoute();
        }
      });
    }

    function buildCategoriesCheckboxes() {
      const grid = document.getElementById('catsGrid');
      grid.innerHTML = '';
      const sorted = [...CATEGORIES].sort((a, b) => (LABELS[a] || a).localeCompare(LABELS[b] || b, 'it'));
      sorted.forEach(type => {
        const id = 'cat-' + type;
        const wrap = document.createElement('div');
        wrap.className = 'cat-item';
        const cb = document.createElement('input');
        cb.type = 'checkbox';
        cb.id = id;
        cb.value = type;
        cb.addEventListener('change', updateCatsSummary);
        const label = document.createElement('label');
        label.setAttribute('for', id);
        label.textContent = LABELS[type] || type;
        wrap.appendChild(cb);
        wrap.appendChild(label);
        grid.appendChild(wrap);
      });
      updateCatsSummary();
    }

    function filterCategories() {
      const query = document.getElementById('categorySearch').value.toLowerCase().trim();
      const items = document.querySelectorAll('#catsGrid .cat-item');
      items.forEach(item => {
        const label = item.querySelector('label').textContent.toLowerCase();
        if (label.includes(query)) {
          item.style.display = 'flex';
          item.classList.remove('hidden');
        } else {
          item.style.display = 'none';
          item.classList.add('hidden');
        }
      });
    }

    function getSelectedTypes() {
      return [...document.querySelectorAll('#catsGrid .cat-item:not(.hidden) input:checked')].map(c => c.value);
    }

    function updateCatsSummary() {
      const summary = document.getElementById('catsSummary');
      const types = getSelectedTypes();
      if (types.length === 0) {
        summary.innerHTML = 'Nessuna categoria selezionata <strong>(user√≤ le quotidiane)</strong>.';
      } else {
        const names = types.map(t => LABELS[t] || t).sort((a, b) => a.localeCompare(b, 'it'));
        summary.innerHTML = `<strong>Categorie (${types.length}):</strong> ${names.slice(0, 5).join(', ')} ${types.length > 5 ? '...' : ''}`;
      }
    }

    function setPosition(coords, title, address_components = null) {
      currentLocation = coords;
      document.getElementById('addressInput').value = title;
      map.setCenter(coords);
      streetView.setPosition(coords);
      
      const setCity = (components) => {
        if (components) {
          cityGuess = components.find(c => c.types.includes('locality'))?.long_name || null;
        }
      };

      if (address_components) {
        setCity(address_components);
      } else {
        geocoder.geocode({location: coords}, (res, st) => {
          if (st === 'OK' && res?.[0]?.address_components) {
            setCity(res[0].address_components);
          }
        });
      }
      
      document.getElementById('mapSection').style.display = 'block';
      document.getElementById('mapGrid').style.display = 'grid';

      const linkEl = document.getElementById('staticStreetViewLink');
      const linkCard = document.getElementById('staticLinkCard');
      const staticUrl = `https://maps.googleapis.com/maps/api/streetview?size=600x400&location=${coords.lat},${coords.lng}&fov=90&heading=0&pitch=0&key=${window.userApiKey}`;
      linkEl.href = staticUrl;
      linkCard.style.display = 'block';
      
      document.getElementById('searchSection').style.display = 'block';
      document.getElementById('searchCard').style.display = 'block';
      document.getElementById('customRouteSection').style.display = 'block';
      document.getElementById('customRouteCard').style.display = 'block';
      document.getElementById('orientationResultCard').style.display = 'block';
    }

    // ===============================
    // üÜï EXPERT MODE: FUNZIONI AVANZATE
    // ===============================
    
    /**
     * Trova tutti i punti Street View candidati in un raggio specifico
     * Usa una griglia di punti per massimizzare la copertura
     */
    async function findAllStreetViewCandidates(targetLat, targetLng, radiusMeters = 60) {
      const sv = new google.maps.StreetViewService();
      const candidates = [];
      
      // Generiamo una griglia di punti da testare
      const numPoints = 12; // Punti sulla circonferenza
      const angleStep = 360 / numPoints;
      
      // Aggiungi il punto centrale
      candidates.push({
        position: { lat: targetLat, lng: targetLng },
        angle: 0,
        distance: 0,
        label: 'Centro'
      });
      
      // Aggiungi punti sulla circonferenza
      for (let i = 0; i < numPoints; i++) {
        const angle = i * angleStep;
        const rad = (angle * Math.PI) / 180;
        const R = 6371000; // Raggio terra in metri
        
        const lat = targetLat + (radiusMeters / R) * (180 / Math.PI) * Math.cos(rad);
        const lng = targetLng + (radiusMeters / R) * (180 / Math.PI) / Math.cos(targetLat * Math.PI / 180) * Math.sin(rad);
        
        candidates.push({
          position: { lat, lng },
          angle: angle,
          distance: radiusMeters,
          label: `${Math.round(angle)}¬∞`
        });
      }
      
      // Testa ogni candidato
      const results = [];
      for (const candidate of candidates) {
        try {
          const data = await new Promise((resolve, reject) => {
            sv.getPanorama({
              location: candidate.position,
              radius: 25, // Raggio ristretto per ogni punto
              source: google.maps.StreetViewSource.OUTDOOR
            }, (data, status) => {
              if (status === 'OK') resolve(data);
              else reject(status);
            });
          });
          
          if (data && data.location) {
            const svLat = data.location.latLng.lat();
            const svLng = data.location.latLng.lng();
            const distFromTarget = calculateDistance(targetLat, targetLng, svLat, svLng);
            
            results.push({
              panoId: data.location.pano,
              position: { lat: svLat, lng: svLng },
              description: data.location.description || 'Senza nome',
              distance: distFromTarget,
              searchAngle: candidate.angle,
              searchDistance: candidate.distance
            });
          }
        } catch (e) {
          // Punto non trovato, continua
        }
      }
      
      return results;
    }

    /**
     * Seleziona il miglior punto Street View secondo la logica Expert Mode:
     * PRIORIT√Ä A: Stesso nome della via
     * PRIORIT√Ä B: Pi√π vicino in assoluto
     */
    function selectBestStreetViewPoint(candidates, targetAddress, targetStreetName) {
      if (candidates.length === 0) return null;
      
      // Rimuovi duplicati (stesso pano ID)
      const uniqueCandidates = [];
      const seenPanos = new Set();
      for (const c of candidates) {
        if (!seenPanos.has(c.panoId)) {
          seenPanos.add(c.panoId);
          uniqueCandidates.push(c);
        }
      }
      
      // PRIORIT√Ä A: Cerca punti con lo stesso nome della via
      const matchingStreet = uniqueCandidates.filter(c => {
        const candidateStreet = extractStreetName(c.description);
        return candidateStreet && targetStreetName && candidateStreet.includes(targetStreetName);
      });
      
      if (matchingStreet.length > 0) {
        // Prendi il pi√π vicino tra quelli sulla via giusta
        matchingStreet.sort((a, b) => a.distance - b.distance);
        return {
          point: matchingStreet[0],
          reason: 'street_match',
          allCandidates: uniqueCandidates
        };
      }
      
      // PRIORIT√Ä B: Nessun match, prendi il pi√π vicino in assoluto
      uniqueCandidates.sort((a, b) => a.distance - b.distance);
      return {
        point: uniqueCandidates[0],
        reason: 'closest',
        allCandidates: uniqueCandidates
      };
    }

    /**
     * Estrae il nome della via da un indirizzo completo
     */
    function extractStreetName(address) {
      if (!address) return null;
      
      // Rimuovi numero civico e citt√†
      let streetName = address.split(',')[0].trim();
      
      // Rimuovi numeri civici comuni (anche con lettere)
      streetName = streetName.replace(/\s+\d+[A-Za-z]?\s*$/, '');
      streetName = streetName.replace(/^\d+[A-Za-z]?\s+/, '');
      
      return streetName.toLowerCase();
    }

    /**
     * Calcola la distanza tra due coordinate (in metri)
     */
    function calculateDistance(lat1, lon1, lat2, lon2) {
      const R = 6371e3; // metri
      const œÜ1 = lat1 * Math.PI / 180;
      const œÜ2 = lat2 * Math.PI / 180;
      const ŒîœÜ = (lat2 - lat1) * Math.PI / 180;
      const ŒîŒª = (lon2 - lon1) * Math.PI / 180;

      const a = Math.sin(ŒîœÜ / 2) * Math.sin(ŒîœÜ / 2) +
                Math.cos(œÜ1) * Math.cos(œÜ2) *
                Math.sin(ŒîŒª / 2) * Math.sin(ŒîŒª / 2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

      return R * c;
    }

    /**
     * Calcola il bearing (direzione) tra due punti
     */
    function calculateBearing(lat1, lon1, lat2, lon2) {
      const œÜ1 = lat1 * Math.PI / 180;
      const œÜ2 = lat2 * Math.PI / 180;
      const ŒîŒª = (lon2 - lon1) * Math.PI / 180;

      const y = Math.sin(ŒîŒª) * Math.cos(œÜ2);
      const x = Math.cos(œÜ1) * Math.sin(œÜ2) - Math.sin(œÜ1) * Math.cos(œÜ2) * Math.cos(ŒîŒª);
      const Œ∏ = Math.atan2(y, x);

      return (Œ∏ * 180 / Math.PI + 360) % 360;
    }

    /**
     * Mostra il Rapporto di Trasparenza Expert Mode
     */
    function displayTransparencyReport(selected, targetAddress, targetStreetName, addressType) {
      const reportDiv = document.getElementById('transparencyReport');
      const contentDiv = document.getElementById('transparencyContent');
      
      if (!selected) {
        reportDiv.style.display = 'none';
        return;
      }
      
      const targetStreetDisplay = targetStreetName || '(nome via non rilevato)';
      const foundStreetDisplay = extractStreetName(selected.point.description) || '(nome via non rilevato)';
      
      let html = `
        <div style="margin-bottom:10px">
          <strong>üéØ Indirizzo cercato:</strong> ${targetAddress}<br>
          <strong>üìç Street View trovato:</strong> ${selected.point.description}<br>
          <strong>üìè Distanza:</strong> ${Math.round(selected.point.distance)} metri
        </div>
      `;
      
      // Check nome via
      if (selected.reason === 'street_match') {
        html += `
          <div style="background:#d4edda;border:2px solid #28a745;padding:10px;border-radius:6px;margin:10px 0">
            ‚úÖ <strong>Match perfetto:</strong> Il punto trovato √® sulla stessa via che hai cercato.<br>
            Via cercata: <em>${targetStreetDisplay}</em><br>
            Via trovata: <em>${foundStreetDisplay}</em>
          </div>
        `;
      } else {
        html += `
          <div style="background:#fff3cd;border:2px solid #ffc107;padding:10px;border-radius:6px;margin:10px 0">
            ‚ö†Ô∏è <strong>Attenzione:</strong> Il punto di osservazione √® su una strada diversa!<br>
            Via cercata: <em>${targetStreetDisplay}</em><br>
            Via trovata: <em>${foundStreetDisplay}</em><br>
            <small style="display:block;margin-top:5px">
              Questo pu√≤ accadere agli incroci o in zone con copertura limitata. 
              L'orientamento sar√† meno affidabile.
            </small>
          </div>
        `;
      }
      
      // Check interpolazione
      if (addressType === 'RANGE_INTERPOLATED' || addressType === 'GEOMETRIC_CENTER') {
        html += `
          <div class="interpolation-warning">
            ‚ö†Ô∏è <strong>Nota Importante:</strong> La posizione del civico cercato √® una <strong>stima di Google</strong>, 
            non una certezza (tipo: ${addressType}). La posizione reale potrebbe essere diversa di 10-30 metri. 
            Prendi la direzione come indicativa.
          </div>
        `;
      } else if (addressType === 'ROOFTOP') {
        html += `
          <div style="background:#d4edda;border:2px solid #28a745;padding:10px;border-radius:6px;margin:10px 0">
            ‚úÖ <strong>Posizione precisa:</strong> Il civico cercato ha coordinate esatte (ROOFTOP). 
            L'orientamento √® molto affidabile.
          </div>
        `;
      }
      
      // Mostra tutti i candidati trovati
      if (selected.allCandidates && selected.allCandidates.length > 1) {
        html += `
          <div style="margin-top:15px;padding-top:15px;border-top:1px solid #ddd">
            <strong>üîç Punti trovati (${selected.allCandidates.length}):</strong><br>
            <small style="color:#666">Il sistema ha trovato questi punti e ha scelto il migliore secondo la logica Expert Mode:</small>
            <ul style="margin:8px 0;padding-left:20px;font-size:0.9em">
        `;
        
        selected.allCandidates.slice(0, 5).forEach((c, i) => {
          const isSelected = c.panoId === selected.point.panoId;
          html += `
            <li style="margin:5px 0;${isSelected ? 'font-weight:bold;color:#28a745' : ''}">
              ${isSelected ? '‚úÖ SELEZIONATO: ' : ''}
              ${c.description} - ${Math.round(c.distance)}m
            </li>
          `;
        });
        
        if (selected.allCandidates.length > 5) {
          html += `<li style="font-style:italic">...e altri ${selected.allCandidates.length - 5} punti</li>`;
        }
        
        html += `</ul></div>`;
      }
      
      contentDiv.innerHTML = html;
      reportDiv.style.display = 'block';
      announceToScreenReader('Rapporto di trasparenza aggiornato');
    }

    /**
     * Mostra i punti candidati sulla mappa
     */
    function displayCandidatesOnMap(candidates, selectedPoint) {
      // Rimuovi vecchi marker
      if (candidateMarkers && candidateMarkers.length > 0) {
        candidateMarkers.forEach(m => m.setMap(null));
      }
      candidateMarkers = [];
      
      if (!candidates || candidates.length === 0) return;
      
      candidates.forEach(c => {
        const isSelected = selectedPoint && c.panoId === selectedPoint.panoId;
        
        const marker = new google.maps.Marker({
          position: c.position,
          map: map,
          icon: {
            path: google.maps.SymbolPath.CIRCLE,
            scale: isSelected ? 12 : 8,
            fillColor: isSelected ? '#28a745' : '#ff6b6b',
            fillOpacity: 1,
            strokeColor: '#fff',
            strokeWeight: isSelected ? 4 : 3
          },
          title: `${c.description} (${Math.round(c.distance)}m)`,
          zIndex: isSelected ? 1000 : 100
        });
        
        const infoWindow = new google.maps.InfoWindow({
          content: `
            <div style="padding:5px">
              <strong>${isSelected ? '‚úÖ SELEZIONATO' : '‚ùå Non selezionato'}</strong><br>
              ${c.description}<br>
              Distanza: ${Math.round(c.distance)}m
            </div>
          `
        });
        
        marker.addListener('click', () => {
          infoWindow.open(map, marker);
        });
        
        candidateMarkers.push(marker);
      });
    }

    /**
     * Calcola l'orientamento usando il metodo vettoriale puro
     */
    function calculateVectorOrientation() {
      const orientationStatusDiv = document.getElementById('orientation-status');
      
      if (!selectedSVPoint || !targetLocation) {
        orientationStatusDiv.innerHTML = `
          <span class="info-message">Cerca un indirizzo nella Sezione 1 per calcolare l'orientamento.</span>
        `;
        return;
      }
      
      const svLat = selectedSVPoint.position.lat;
      const svLng = selectedSVPoint.position.lng;
      const targetLat = targetLocation.lat;
      const targetLng = targetLocation.lng;
      
      // Calcolo vettore puro: da Street View verso Target
      const vectorBearing = calculateBearing(svLat, svLng, targetLat, targetLng);
      buildingDirectionFromStreet = vectorBearing;
      
      const distance = calculateDistance(svLat, svLng, targetLat, targetLng);
      const cardinalDir = getCardinalDirectionLong(vectorBearing);
      
      // Check tipo di luogo
      let contextWarning = '';
      const addressLower = (selectedSVPoint.description || '').toLowerCase();
      if (addressLower.includes('piazza') || addressLower.includes('rotonda') || addressLower.includes('incrocio')) {
        contextWarning = `
          <div style="background:#fff3cd;border:2px solid #ffc107;padding:10px;border-radius:6px;margin:10px 0">
            ‚ö†Ô∏è <strong>Sei in una piazza/rotonda/incrocio.</strong> L'orientamento "destra/sinistra" 
            potrebbe non essere affidabile. Usa i <strong>punti cardinali</strong> come riferimento.
          </div>
        `;
      }
      
      const html = `
        <span class="success-message">‚úÖ Orientamento calcolato (Expert Mode)</span><br><br>
        
        <div class="vector-info">
          <strong>üß≠ Calcolo Vettoriale Puro:</strong><br>
          Dal punto Street View trovato (${selectedSVPoint.description}), 
          il tuo obiettivo si trova in direzione <strong>${cardinalDir}</strong> (${Math.round(vectorBearing)}¬∞).<br>
          <small style="display:block;margin-top:5px;color:#666">
            Distanza: ${Math.round(distance)} metri
          </small>
        </div>
        
        ${contextWarning}
        
        <div style="margin-top:15px;padding:10px;background:#f8f9fa;border-radius:6px">
          <strong>üí° Come usare questa informazione:</strong><br>
          ‚Ä¢ Questa direzione √® calcolata geometricamente, indipendente dall'orientamento del portone<br>
          ‚Ä¢ Seleziona una "Direzione Desiderata" qui sotto per calcolare la svolta necessaria<br>
          ‚Ä¢ Il calcolo terr√† conto automaticamente della rotazione di 180¬∞ (uscita dal portone)
        </div>
      `;
      
      orientationStatusDiv.innerHTML = html;
      announceToScreenReader(`Orientamento calcolato: ${cardinalDir}`);
      
      // Ricalcola svolta se gi√† selezionata
      const desiredDir = document.getElementById('desired-direction').value;
      if (desiredDir) {
        calculateAndShowTurnInstruction();
      }
    }

    /**
     * Ottiene la direzione cardinale lunga da gradi
     */
    async function searchLocation() {
      const query = (document.getElementById('addressInput').value || '').trim();
      if (!query) return notify('‚ö†Ô∏è Inserisci un indirizzo', 'error');
      
      notify('üîç Cercando indirizzo...', 'info');
      
      geocoder.geocode({address: query}, async (res, st) => {
        if (st === 'OK' && res?.[0]) {
          const loc = res[0].geometry.location;
          const coords = {lat: loc.lat(), lng: loc.lng()};
          const formattedAddress = res[0].formatted_address || query;
          
          setPosition(
            coords, 
            formattedAddress,
            res[0].address_components
          );
          notify('‚úÖ Indirizzo trovato!', 'success');
          
          // üß≠ CALCOLO AUTOMATICO ORIENTAMENTO
          notify('üß≠ Calibrando orientamento...', 'info');
          
          try {
            await calculateOrientationAutomatically(coords, formattedAddress);
          } catch (error) {
            console.warn("Orientamento automatico fallito:", error);
            // Non blocchiamo se l'orientamento fallisce
          }
          
        } else {
          notify('‚ùå Indirizzo non trovato: ' + st, 'error');
        }
      });
    }

    // üß≠üÜï FUNZIONE EXPERT MODE: Calcolo Automatico Orientamento
    async function calculateOrientationAutomatically(coords, address) {
      const targetLoc = new google.maps.LatLng(coords.lat, coords.lng);
      
      // üÜï STEP 1: Ottieni tipo di geocodifica (ROOFTOP vs INTERPOLATED)
      geocoder.geocode({location: coords}, (results, status) => {
        if (status === 'OK' && results[0]) {
          targetAddressType = results[0].geometry.location_type;
        }
      });
      
      // Salva target location
      targetLocation = coords;
      
      // üÜï STEP 2: Ricerca multi-punto Street View (Expert Mode)
      const searchRadius = parseInt(document.getElementById('searchRadius').value) || 60;
      notify(`üîç Ricerca ${searchRadius}m raggio (Expert Mode)...`, 'info');
      
      const candidates = await findAllStreetViewCandidates(coords.lat, coords.lng, searchRadius);
      
      if (candidates.length === 0) {
        showStreetViewNotFoundModal(coords, address);
        return;
      }
      
      // üÜï STEP 3: Selezione Best Point (priorit√† nome via)
      const targetStreetName = extractStreetName(address);
      const selection = selectBestStreetViewPoint(candidates, address, targetStreetName);
      
      if (!selection) {
        showStreetViewNotFoundModal(coords, address);
        return;
      }
      
      selectedSVPoint = selection.point;
      allSVCandidates = selection.allCandidates;
      
      // üÜï STEP 4: Aggiorna Street View e Mappa
      streetView.setPosition(selectedSVPoint.position);
      streetView.setPov({ heading: 0, pitch: 0 });
      
      // Salva dati per compatibilit√†
      lastStreetViewLocation = selectedSVPoint.position;
      lastStreetViewDistance = selectedSVPoint.distance;
      lastCalculatedAddress = address;
      
      // üÜï STEP 5: Display Transparency Report
      displayTransparencyReport(selection, address, targetStreetName, targetAddressType);
      displayCandidatesOnMap(allSVCandidates, selectedSVPoint);
      
      // üÜï STEP 6: Calcolo Orientamento Vettoriale Puro
      calculateVectorOrientation();
      
      const matchMsg = selection.reason === 'street_match' ? '‚úÖ Via coincidente' : '‚ö†Ô∏è Via diversa';
      notify(`‚úÖ Expert Mode: ${candidates.length} punti trovati. ${matchMsg}`, 'success');
      
      // Aggiorna display Sezione 6
      updateSection6Display();
    }
    
    // ‚ú® FUNZIONE: Aggiorna Display Sezione 6
    function updateSection6Display() {
      if (buildingDirectionFromStreet === null) {
        document.getElementById('orientation-status').innerHTML = 
          'Pronto. Inserisci un indirizzo nella Sezione 1.';
        document.getElementById('turn-instruction-wrapper').style.display = 'none';
        return;
      }
      
      const exitingDirection = (buildingDirectionFromStreet + 180) % 360;
      
      // Prepara link a Google Maps per lo Street View usato
      let svLink = '';
      if (lastStreetViewLocation) {
        svLink = `<a href="https://www.google.com/maps/@?api=1&map_action=pano&viewpoint=${lastStreetViewLocation.lat},${lastStreetViewLocation.lng}&heading=${Math.round(buildingDirectionFromStreet)}" target="_blank" style="color: #2196f3; text-decoration: underline;">Apri Street View usato</a>`;
      }
      
      document.getElementById('orientation-status').innerHTML = `
        <span class="success-message">‚úÖ Orientamento calcolato</span>
        <span class="output-line" style="font-size: 1.2em; font-weight: bold; margin: 10px 0; display: block;">Quando esci dall'edificio, guardi verso <strong>${getCardinalDirectionLong(exitingDirection)}</strong></span>
        
        <details style="margin-top: 15px;">
          <summary style="cursor: pointer; padding: 10px; background: #f5f5f5; border-radius: 6px; font-weight: bold; color: #667eea;">üìä Informazioni tecniche</summary>
          <div style="margin-top: 10px; padding: 12px; background: #fafafa; border-radius: 6px; font-size: 0.9em; line-height: 1.6;">
            <div style="margin-bottom: 10px;"><strong>Indirizzo analizzato:</strong><br>${lastCalculatedAddress || 'Non disponibile'}</div>
            <div style="margin-bottom: 10px;"><strong>Coordinate Street View:</strong><br>
              Lat: ${lastStreetViewLocation ? lastStreetViewLocation.lat.toFixed(6) : 'N/D'}<br>
              Lng: ${lastStreetViewLocation ? lastStreetViewLocation.lng.toFixed(6) : 'N/D'}
              ${svLink ? '<br>' + svLink : ''}
            </div>
            <div><strong>Distanza:</strong> ${lastStreetViewDistance ? lastStreetViewDistance.toFixed(1) + ' metri' : 'Non disponibile'}</div>
          </div>
        </details>
      `;
      
      // Mostra il selettore di direzione
      document.getElementById('turn-instruction-wrapper').style.display = 'block';
    }
    
    // Funzione invertOrientation rimossa - l'app deve essere precisa, non richiedere correzioni manuali

    // üö® MODALE: Street View Non Trovato
    function showStreetViewNotFoundModal(coords, address) {
      buildingDirectionFromStreet = null;
      
      
      const modalBody = document.getElementById('modalBody');
      modalBody.innerHTML = `
        <div style="padding: 15px;">
          <h3 style="color: #dc3545; margin-bottom: 15px;">‚ö†Ô∏è Street View Non Disponibile</h3>
          <p><strong>Indirizzo cercato:</strong><br>${address}</p>
          <p style="margin-top: 15px;">
            Non √® disponibile Street View entro 200 metri da questo punto.<br>
            <strong>L'orientamento automatico non pu√≤ essere calcolato.</strong>
          </p>
          <p style="margin-top: 15px; color: #666;">
            üí° <strong>Suggerimento:</strong> Prova con un indirizzo pi√π preciso (es. con numero civico) 
            o con un punto di riferimento vicino a una strada principale.
          </p>
          <div style="margin-top: 20px; padding: 12px; background: #fff3cd; border-radius: 6px;">
            <strong>Puoi:</strong><br>
            ‚Ä¢ Cercare un altro indirizzo nella Sezione 1<br>
            ‚Ä¢ Usare la Sezione 6 per analisi manuale<br>
            ‚Ä¢ Procedere con la navigazione (senza orientamento iniziale)
          </div>
        </div>
      `;
      
      document.getElementById('modalHeader').textContent = 'Street View Non Disponibile';
      document.getElementById('modal').classList.add('show');
      
      notify('‚ö†Ô∏è Orientamento non disponibile per questo punto', 'error');
    }

    // üö® MODALE: Street View Troppo Lontano
    function showStreetViewTooFarModal(coords, address, svData, distance) {
      const svLat = svData.location.lat;
      const svLng = svData.location.lng;
      
      const modalBody = document.getElementById('modalBody');
      modalBody.innerHTML = `
        <div style="padding: 15px;">
          <h3 style="color: #ffc107; margin-bottom: 15px;">‚ö†Ô∏è Street View Trovato Ma Distante</h3>
          <p><strong>Indirizzo cercato:</strong><br>${address}</p>
          <p style="margin-top: 15px;">
            Street View pi√π vicino trovato a <strong>${distance.toFixed(0)} metri</strong> di distanza.<br>
            Questa distanza √® troppo elevata per un orientamento affidabile.
          </p>
          <div style="margin-top: 20px; padding: 12px; background: #e3f2fd; border-radius: 6px;">
            <strong>üìç Street View trovato a:</strong><br>
            Lat: ${svLat.toFixed(6)}, Lng: ${svLng.toFixed(6)}<br>
            <a href="https://www.google.com/maps/@?api=1&map_action=pano&viewpoint=${svLat},${svLng}" target="_blank" style="color: #2196f3;">
              üîó Apri in Google Maps Street View
            </a>
          </div>
          <div style="margin-top: 15px;">
            <strong>Vuoi usare questo punto Street View come partenza?</strong><br>
            <button class="btn" onclick="acceptNearbyStreetView(${svLat}, ${svLng})" style="margin-top: 10px;">
              ‚úÖ S√¨, Usa Questo Punto
            </button>
            <button class="btn btn-ghost" onclick="closeModal()" style="margin-top: 10px; margin-left: 10px;">
              ‚ùå No, Cerca Altro Indirizzo
            </button>
          </div>
        </div>
      `;
      
      document.getElementById('modalHeader').textContent = 'Street View Distante';
      document.getElementById('modal').classList.add('show');
      
      notify('‚ö†Ô∏è Street View trovato a ' + distance.toFixed(0) + 'm - Vuoi usarlo?', 'info');
    }

    // ‚úÖ FUNZIONE: Accetta Street View Vicino
    async function acceptNearbyStreetView(lat, lng) {
      closeModal();
      
      const coords = {lat, lng};
      
      // Ottieni indirizzo del punto Street View
      geocoder.geocode({location: coords}, async (res, st) => {
        const address = (st === 'OK' && res?.[0]) ? res[0].formatted_address : `Lat: ${lat.toFixed(4)}, Lng: ${lng.toFixed(4)}`;
        
        setPosition(coords, address);
        document.getElementById('addressInput').value = address;
        notify('‚úÖ Punto Street View impostato come partenza', 'success');
        
        // Ricalcola orientamento
        notify('üß≠ Calibrando orientamento...', 'info');
        await calculateOrientationAutomatically(coords, address);
      });
    }

    async function getCurrentLocation() {
      if (!navigator.geolocation) return notify('‚ùå Geolocalizzazione non supportata', 'error');
      
      notify('üì° Rilevamento posizione...', 'info');
      navigator.geolocation.getCurrentPosition(async pos => {
        const coords = {lat: pos.coords.latitude, lng: pos.coords.longitude};
        geocoder.geocode({location: coords}, async (res, st) => {
          let address;
          if (st === 'OK' && res?.[0]) {
            address = res[0].formatted_address;
            setPosition(coords, address, res[0].address_components);
            notify('‚úÖ Posizione rilevata', 'success');
          } else {
            address = `Lat: ${coords.lat.toFixed(4)}, Lon: ${coords.lng.toFixed(4)}`;
            setPosition(coords, address);
            notify('‚úÖ Posizione rilevata (senza indirizzo)', 'info');
          }
          
          // üß≠ CALCOLO AUTOMATICO ORIENTAMENTO
          notify('üß≠ Calibrando orientamento...', 'info');
          try {
            await calculateOrientationAutomatically(coords, address);
          } catch (error) {
            console.warn("Orientamento automatico fallito:", error);
          }
        });
      }, () => notify('‚ùå Impossibile ottenere la posizione', 'error'));
    }

    function whereAmI() {
      let locationToGeocode = currentLocation;
      if (streetView && streetView.getPosition()) {
          const svPos = streetView.getPosition();
          locationToGeocode = { lat: svPos.lat(), lng: svPos.lng() };
      }

      if (!locationToGeocode) {
        notify('‚ö†Ô∏è Posizione non ancora impostata. Usa "Cerca" o "Rileva Posizione" prima.', 'error');
        return;
      }
      
      notify('üì° Trovo l\'indirizzo per il punto attuale...', 'info');
      
      geocoder.geocode({location: locationToGeocode}, (res, st) => {
        if (st === 'OK' && res?.[0]) {
          document.getElementById('addressInput').value = res[0].formatted_address;
          currentLocation = locationToGeocode;
          notify('‚úÖ Indirizzo aggiornato in Sez. 1. Puoi modificarlo e cercarlo.', 'success');
        } else {
          notify('‚ùå Impossibile trovare un indirizzo per questo punto.', 'error');
        }
      });
    }
    
    // Variabile per tracciare l'ultima direzione annunciata
    let lastAnnouncedHeading = null;
    
    function updateStreetViewInfo() {
      const info = document.getElementById('svInfo');
      if (!streetView) return;
      const pos = streetView.getPosition(), pov = streetView.getPov();
      if (!pos || !pov) return;

      currentLocation = {lat: pos.lat(), lng: pos.lng()};

      const heading = (pov.heading % 360 + 360) % 360;
      const roundedHeading = Math.round(heading);
      const cardinalDir = getCardinalDirectionShort(heading);
      
      document.getElementById('svDirection').textContent = `${cardinalDir} (${roundedHeading}¬∞)`;

      // Annuncia solo se la direzione cardinale √® cambiata significativamente
      if (lastAnnouncedHeading === null || Math.abs(heading - lastAnnouncedHeading) > 30) {
        announceToScreenReader(`Direzione: ${cardinalDir}`, 'polite');
        lastAnnouncedHeading = heading;
      }

      info.style.display = 'block';
      geocoder.geocode({location: pos}, (res, st) => {
        document.getElementById('svAddress').textContent = (st === 'OK' && res?.[0]) ? res[0].formatted_address : 'Indirizzo non disponibile';
      });
    }

    function movePov(dir) {
      if (!streetView) return;
      const p = streetView.getPov(), s = 20;
      if (dir === 'up') streetView.setPov({heading: p.heading, pitch: Math.min(90, p.pitch + s)});
      if (dir === 'down') streetView.setPov({heading: p.heading, pitch: Math.max(-90, p.pitch - s)});
      if (dir === 'left') streetView.setPov({heading: p.heading - 20, pitch: p.pitch});
      if (dir === 'right') streetView.setPov({heading: p.heading + 20, pitch: p.pitch});
    }

    function moveForward() {
      const pov = streetView.getPov(), links = streetView.getLinks();
      if (!links || !links.length) return notify('‚ö†Ô∏è Non √® possibile avanzare.', 'error');
      let best = null, min = 60;
      links.forEach(l => {
        let d = Math.abs(pov.heading - l.heading);
        if (d > 180) d = 360 - d;
        if (d < min) { min = d; best = l; }
      });
      if (best) streetView.setPano(best.pano);
      else notify('‚ö†Ô∏è Nessun collegamento nella direzione di marcia.', 'error');
    }

    function moveBackward() {
      const pov = streetView.getPov(), links = streetView.getLinks();
      if (!links || !links.length) return notify('‚ö†Ô∏è Non √® possibile tornare indietro.', 'error');
      const back = (pov.heading + 180) % 360;
      let best = null, min = 90;
      links.forEach(l => {
        let d = Math.abs(back - l.heading);
        if (d > 180) d = 360 - d;
        if (d < min) { min = d; best = l; }
      });
      if (best) streetView.setPano(best.pano);
      else notify('‚ö†Ô∏è Nessun collegamento dietro.', 'error');
    }
    
    function resetStreetView() {
      if (!currentLocation) {
        notify('‚ö†Ô∏è Nessuna posizione iniziale impostata.', 'error');
        return;
      }
      
      // Ritorna alla posizione iniziale
      streetView.setPosition(currentLocation);
      streetView.setPov({
        heading: 0,
        pitch: 0
      });
      notify('‚úÖ Street View resettato alla posizione iniziale', 'success');
    }
    
    function findAddressForPoint(lat, lng) {
      if (!geocoder) return notify('‚ö†Ô∏è Geocoder non pronto.', 'error');
      
      notify('üì° Ricerca indirizzo dettagliato...', 'info');
      const searchPoint = new google.maps.LatLng(lat, lng);
      
      geocoder.geocode({location: {lat: lat, lng: lng}}, (results, status) => {
        if (status === 'OK' && results?.length > 0) {
          let nearbyResults = results.filter(r => 
            r.geometry?.location && 
            google.maps.geometry.spherical.computeDistanceBetween(searchPoint, r.geometry.location) <= 10 &&
            !r.types.includes('plus_code')
          );
          
          if (nearbyResults.length === 0) {
            return openModal('Nessun Indirizzo Vicino', `<div class="modal-info"><p>Nessun indirizzo trovato entro 10 metri.</p><p style="margin-top:10px"><small>Coordinate: ${lat.toFixed(6)}, ${lng.toFixed(6)}</small></p></div><div class="modal-buttons"><button class="btn" onclick="closeModal()">Chiudi</button></div>`);
          }
          
          let bestResult = nearbyResults.find(r => 
            r.types.includes('street_address') || 
            r.address_components?.some(c => c.types.includes('street_number'))
          ) || nearbyResults.find(r => 
            r.address_components?.some(c => 
              c.types.includes('route') && (c.long_name.toLowerCase().includes('piazza') || c.long_name.toLowerCase().includes('largo'))
            ) || r.types.includes('premise') || r.types.includes('town_square')
          ) || nearbyResults.find(r => 
            r.types.includes('point_of_interest') || r.types.includes('establishment') || r.types.includes('premise')
          ) || nearbyResults.find(r => 
            r.types.includes('route') || r.address_components?.some(c => c.types.includes('route'))
          ) || nearbyResults[0];
          
          const distance = google.maps.geometry.spherical.computeDistanceBetween(searchPoint, bestResult.geometry.location);
          let formattedAddress = bestResult.formatted_address.replace('/', ' e ');
          
          let infoHtml = `<div class="modal-info">
            <p><strong>üìç Indirizzo trovato:</strong><br>${formattedAddress}</p>
            <p style="margin-top:8px;font-size:0.9em;color:#666"><strong>Distanza:</strong> ${distance.toFixed(1)} metri</p>`;
          
          const alternatives = nearbyResults.filter(r => r !== bestResult).slice(0, 2);
          if (alternatives.length > 0) {
            infoHtml += `<p style="margin-top:10px"><strong>Alternative vicine:</strong></p><ul style="margin-left:20px;line-height:1.8">`;
            alternatives.forEach(r => {
              const altDist = google.maps.geometry.spherical.computeDistanceBetween(searchPoint, r.geometry.location);
              infoHtml += `<li style="font-size:0.95em">${r.formatted_address.replace('/', ' e ')} <span style="color:#666">(${altDist.toFixed(1)}m)</span></li>`;
            });
            infoHtml += `</ul>`;
          }
          
          infoHtml += `</div><div class="modal-buttons"><button class="btn" onclick="closeModal()">Chiudi</button></div>`;
          openModal('Indirizzo Dettagliato', infoHtml);
        } else {
          notify('‚ùå Indirizzo non trovato: ' + status, 'error');
          openModal('Errore Indirizzo', `<div class="modal-info"><p>Impossibile trovare un indirizzo.</p><p style="margin-top:10px"><small>Coordinate: ${lat.toFixed(6)}, ${lng.toFixed(6)}</small></p></div><div class="modal-buttons"><button class="btn" onclick="closeModal()">Chiudi</button></div>`);
        }
      });
    }

    function displayUnifiedResults(places, title) {
      document.getElementById('resultsSection').style.display = 'block';
      document.getElementById('resultsCard').style.display = 'block';
      const c = document.getElementById('placesList');
      document.querySelector('#resultsSection h2').textContent = `üìã Sezione 4: ${title} (${places.length})`;
      currentlyDisplayedPlaces = places;
      c.innerHTML = (places?.length > 0) ? places.map((p, i) => {
        let optionsHtml = `<option value="">-- Scegli azione --</option>
                           <option value="walk">üö∂ A piedi</option>
                           <option value="transit">üöå Mezzi</option>
                           <option value="bicycle">üö¥ In Bici</option>
                           <option value="drive">üöó In Auto</option>`;
        if (p.source === 'google') {
          optionsHtml += `<option value="details">‚ÑπÔ∏è Dettagli</option>
                          <option value="maps">üó∫Ô∏è Apri su Google Maps</option>`;
        }
        if (p.coords) {
          optionsHtml += `<option value="set_start">üö© Imposta come Partenza</option>`;
          optionsHtml += `<option value="find_address">üìç Trova Indirizzo</option>`;
          if (p.source !== 'google') {
            optionsHtml += `<option value="open_maps_coords">üó∫Ô∏è Apri su Google Maps</option>`;
          }
        }
        return `<div class="place-card">
          <strong>${p.name}</strong><br>
          <small>${p.details}</small>
          <div class="place-actions">
            <select onchange="handleRouteAction(${i}, this.value)" aria-label="Azioni per ${p.name}">
              ${optionsHtml}
            </select>
          </div>
        </div>`;
      }).join('') : '<div class="place-card">Nessun risultato.</div>';
    }

    async function searchPlaces() {
      if (!currentLocation) return notify('‚ö†Ô∏è Imposta un punto di partenza', 'error');
      
      const radius = parseInt(document.getElementById('radiusInput').value, 10) || 500;
      const types = getSelectedTypes().length > 0 ? getSelectedTypes() : DAILY_DEFAULT;
      notify('üîç Ricerca luoghi Google...', 'info');
      displayUnifiedResults([], "Ricerca Google in corso...");
      let allPlaces = [];
      
      for (const type of types) {
        await new Promise(resolve => {
          service.nearbySearch({location: currentLocation, radius: radius, type: type}, (results, status) => {
            if (status === google.maps.places.PlacesServiceStatus.OK && results) {
              allPlaces.push(...results);
            }
            resolve();
          });
        });
      }
      
      const uniquePlaces = Array.from(new Map(allPlaces.map(p => [p.place_id, p])).values());
      const origin = new google.maps.LatLng(currentLocation.lat, currentLocation.lng);
      
      const formattedPlaces = uniquePlaces.map(p => {
        const distance = p.geometry?.location ? google.maps.geometry.spherical.computeDistanceBetween(origin, p.geometry.location) : null;
        let cardinal = '';
        if (p.geometry?.location) {
          const heading = google.maps.geometry.spherical.computeHeading(origin, p.geometry.location);
          cardinal = ` [${getCardinalDirectionShort(heading)}]`;
        }
        return {
          name: p.name || 'Senza nome',
          details: `${p.vicinity || 'Indirizzo non disponibile'} - Distanza: ${formatDistance(distance)}${cardinal}`,
          coords: p.geometry?.location ? {lat: p.geometry.location.lat(), lng: p.geometry.location.lng()} : null,
          distance: distance,
          place_id: p.place_id,
          source: 'google'
        };
      }).sort((a, b) => a.distance - b.distance);
      displayUnifiedResults(formattedPlaces, "Luoghi Google Trovati");
    }

    function handleRouteAction(idx, value) {
      const place = currentlyDisplayedPlaces[idx];
      const selectElement = event.target;
      if (!value || !place) {
        if (selectElement) selectElement.selectedIndex = 0;
        return;
      }
      
      let mode = 'WALKING'; // Default
      switch (value) {
        case 'set_start':
          // üÜï MODIFICA 5: Quando selezioni una fermata, quella diventa il nuovo punto di partenza
          // Usa le coordinate ESATTE della fermata (da Transitland, NON da Google Geocoding)
          if (place.coords) {
            setPosition(place.coords, place.name);
            const coordText = `(Coord: ${place.coords.lat.toFixed(5)}, ${place.coords.lng.toFixed(5)})`;
            
            // Per fermate Transitland, mostra anche le linee
            if (place.source === 'transitland' && place.routes && place.routes.length > 0) {
              document.getElementById('addressInput').value = `${place.name} ${coordText} - Linee: ${place.routes.join(', ')}`;
              notify(`‚úÖ Fermata impostata come partenza! Linee: ${place.routes.join(', ')}`, 'success');
            } else {
              document.getElementById('addressInput').value = `${place.name} ${coordText}`;
              notify('‚úÖ Punto di partenza aggiornato con coordinate esatte!', 'success');
            }
            document.getElementById('topHeader').scrollIntoView({behavior: 'smooth'});
          } else {
            notify('‚ùå Coordinate non disponibili per questo luogo.', 'error');
          }
          if (selectElement) selectElement.selectedIndex = 0;
          return;
        case 'walk':
          mode = 'WALKING';
          break;
        case 'transit':
          mode = 'TRANSIT';
          break;
        case 'bicycle':
          mode = 'BICYCLING';
          break;
        case 'drive':
          mode = 'DRIVING';
          break;
        case 'details':
          if (place.place_id) getPlaceDetails(place.place_id, place.name);
          if (selectElement) selectElement.selectedIndex = 0;
          return;
        case 'maps':
          if (place.place_id) window.open(`https://www.google.com/maps/search/?api=1&query=${encodeURIComponent(place.name)}&query_place_id=${place.place_id}`, '_blank');
          else notify('‚ùå ID luogo Google non disponibile.', 'error');
          if (selectElement) selectElement.selectedIndex = 0;
          return;
        case 'open_maps_coords':
          if (place.coords) window.open(`https://www.google.com/maps/search/?api=1&query=${place.coords.lat},${place.coords.lng}`, '_blank');
          else notify('‚ùå Coordinate non disponibili.', 'error');
          if (selectElement) selectElement.selectedIndex = 0;
          return;
        case 'find_address':
          if (place.coords) findAddressForPoint(place.coords.lat, place.coords.lng);
          else notify('‚ùå Coordinate non disponibili.', 'error');
          if (selectElement) selectElement.selectedIndex = 0;
          return;
        default:
          if (selectElement) selectElement.selectedIndex = 0;
          return;
      }

      // Se √® una modalit√† di rotta
      if (place.coords) {
        calculateAndShowRoute(place.coords, mode);
      } else {
        notify('‚ùå Coordinate non disponibili.', 'error');
      }
      if (selectElement) selectElement.selectedIndex = 0;
    }

    function getPlaceDetails(placeId, placeName) {
      if (!service) return;
      notify('Recupero dettagli...', 'info');
      service.getDetails({placeId: placeId, fields: ['opening_hours', 'rating', 'user_ratings_total']}, (place, status) => {
        if (status === google.maps.places.PlacesServiceStatus.OK && place) {
          let detailsHtml = `<div class="modal-info">
            <p><strong>Stato:</strong> ${place.opening_hours ? (place.opening_hours.isOpen() ? 'Aperto ora' : 'Chiuso') : 'Orari non disponibili'}</p>
            <p><strong>Valutazione:</strong> ${place.rating ? `${place.rating} stelle (${place.user_ratings_total} recensioni)` : 'Non disponibile'}</p>
            </div><div class="modal-buttons"><button class="btn" onclick="closeModal()">Chiudi</button></div>`;
          openModal(`Dettagli per: ${placeName}`, detailsHtml);
        } else {
          notify(`‚ùå Dettagli non disponibili: ${status}`, 'error');
        }
      });
    }

    function calculateCustomRoute() {
      const dest = document.getElementById('customDest').value.trim();
      const mode = document.getElementById('customRouteMode').value;
      if (!dest) return notify('‚ö†Ô∏è Inserisci una destinazione', 'error');
      calculateAndShowRoute(dest, mode);
    }

    // ==========================================
    // FUNZIONI MOOVIT
    // ==========================================
    
    // Mostra/nasconde il pulsante Moovit in base alla modalit√† selezionata
    function toggleMoovitButton() {
      const mode = document.getElementById('customRouteMode').value;
      const moovitBtn = document.getElementById('moovitButton');
      const destInput = document.getElementById('customDest').value.trim();
      
      // Mostra solo se: TRANSIT selezionato E c'√® una destinazione inserita
      if (mode === 'TRANSIT' && destInput) {
        moovitBtn.style.display = 'inline-block';
      } else {
        moovitBtn.style.display = 'none';
      }
    }
    
    // Listener per aggiornare visibilit√† Moovit quando cambia destinazione
    document.addEventListener('DOMContentLoaded', () => {
      const destInput = document.getElementById('customDest');
      if (destInput) {
        destInput.addEventListener('input', toggleMoovitButton);
        destInput.addEventListener('change', toggleMoovitButton);
      }
    });
    
    // Estrae la citt√† da un indirizzo
    function extractCityFromAddress(address) {
      if (!address) return null;
      // Prova a estrarre la citt√† dall'indirizzo (generalmente dopo la virgola)
      const parts = address.split(',');
      if (parts.length >= 2) {
        // Rimuove il CAP se presente e restituisce la citt√†
        let cityPart = parts[1].trim();
        // Rimuove numeri (CAP) all'inizio
        cityPart = cityPart.replace(/^\d{5}\s*/, '').trim();
        if (cityPart) return cityPart;
      }
      // Fallback: restituisce cityGuess globale
      return cityGuess || null;
    }
    
    // Apre il modal di configurazione Moovit
    function openMoovitModal() {
      const startAddress = document.getElementById('addressInput').value.trim();
      const destAddress = document.getElementById('customDest').value.trim();
      
      if (!startAddress) {
        notify('‚ö†Ô∏è Inserisci prima un indirizzo di partenza nella Sezione 1', 'error');
        return;
      }
      if (!destAddress) {
        notify('‚ö†Ô∏è Inserisci prima una destinazione', 'error');
        return;
      }
      
      // Estrae le citt√†
      const cityA = extractCityFromAddress(startAddress) || cityGuess || 'la tua citt√†';
      const cityB = extractCityFromAddress(destAddress) || cityA;
      
      // Prepara il messaggio dinamico
      let searchSuggestion = '';
      if (cityA.toLowerCase() === cityB.toLowerCase()) {
        searchSuggestion = `<strong>"Mezzi pubblici ${cityA} Moovit"</strong>`;
      } else {
        searchSuggestion = `<strong>"Mezzi pubblici ${cityA} Moovit"</strong> oppure <strong>"Mezzi pubblici ${cityB} Moovit"</strong> (cerca l'area che include entrambe le citt√†, es. la Provincia o la Regione)`;
      }
      
      const modalContent = `
        <div class="modal-info" style="padding: 10px 0;">
          <p style="font-size: 1.05em; line-height: 1.6; margin-bottom: 15px;">
            Per calcolare il percorso bus esatto, ho bisogno di sapere in quale zona Moovit ti trovi.
          </p>
          
          <p style="font-weight: 600; color: #495057; margin-bottom: 8px;">üìã Fai cos√¨:</p>
          <ol style="line-height: 1.8; margin-left: 20px; margin-bottom: 20px; color: #555;">
            <li>Cerca sul web: ${searchSuggestion}</li>
            <li>Apri il primo risultato che inizia con <strong>moovitapp.com</strong></li>
            <li>Copia l'<strong>intero indirizzo</strong> di quella pagina dalla barra del browser</li>
            <li>Incollalo qui sotto</li>
          </ol>
          
          <div style="background: #f8f9fb; border-radius: 8px; padding: 15px; margin-bottom: 15px;">
            <label style="font-weight: 600; color: #667eea; display: block; margin-bottom: 8px;">
              üîó Incolla qui il link Moovit:
            </label>
            <input type="text" 
                   id="moovitUrlInput" 
                   placeholder="https://moovitapp.com/index/it/mezzi_pubblici-..." 
                   style="width: 100%; padding: 12px; border: 2px solid #667eea; border-radius: 8px; font-size: 14px;"
                   aria-label="Incolla il link di Moovit">
            <small style="color: #888; display: block; margin-top: 6px;">
              Esempio: https://moovitapp.com/index/it/mezzi_pubblici-Roma-Roma_e_Lazio-city_81-61
            </small>
          </div>
          
          <div style="background: #e8f5e9; border-radius: 8px; padding: 12px; border-left: 4px solid #28a745;">
            <p style="margin: 0; font-size: 0.95em; color: #2e7d32;">
              <strong>‚ÑπÔ∏è Cosa far√† l'app:</strong><br>
              User√† questo link per creare il tuo itinerario da<br>
              <em>"${startAddress.substring(0, 50)}${startAddress.length > 50 ? '...' : ''}"</em><br>
              a<br>
              <em>"${destAddress.substring(0, 50)}${destAddress.length > 50 ? '...' : ''}"</em>
            </p>
          </div>
        </div>
        
        <div class="modal-buttons">
          <button class="btn btn-ghost" onclick="closeModal()">Annulla</button>
          <button class="btn btn-green" onclick="processMoovitUrl()" style="background: linear-gradient(135deg, #50c878, #32a852);">
            üöç Apri Moovit
          </button>
        </div>
      `;
      
      openModal('üìç Configurazione Moovit', modalContent);
      
      // Focus sull'input
      setTimeout(() => {
        const input = document.getElementById('moovitUrlInput');
        if (input) input.focus();
      }, 100);
    }
    
    // Processa l'URL Moovit incollato e apre il link finale
    function processMoovitUrl() {
      const moovitUrl = document.getElementById('moovitUrlInput').value.trim();
      const startAddress = document.getElementById('addressInput').value.trim();
      const destAddress = document.getElementById('customDest').value.trim();
      
      if (!moovitUrl) {
        notify('‚ö†Ô∏è Incolla il link di Moovit', 'error');
        return;
      }
      
      // Valida che sia un URL Moovit
      if (!moovitUrl.includes('moovitapp.com')) {
        notify('‚ö†Ô∏è Il link deve essere di moovitapp.com', 'error');
        return;
      }
      
      // Estrae lo slug dall'URL
      // URL esempio: https://moovitapp.com/index/it/mezzi_pubblici-Mentana-Roma_e_Lazio-city_81124-61
      // Vogliamo estrarre: Mentana-Roma_e_Lazio-city_81124-61
      
      let slug = null;
      
      // Metodo 1: cerca dopo "mezzi_pubblici-"
      const mezziMatch = moovitUrl.match(/mezzi_pubblici-(.+)$/);
      if (mezziMatch && mezziMatch[1]) {
        slug = mezziMatch[1];
      } else {
        // Metodo 2: cerca dopo "public_transit-" (versione inglese)
        const transitMatch = moovitUrl.match(/public_transit-(.+)$/);
        if (transitMatch && transitMatch[1]) {
          slug = transitMatch[1];
        }
      }
      
      if (!slug) {
        notify('‚ö†Ô∏è Non riesco a leggere il link. Assicurati di copiare l\'URL completo dalla pagina Moovit', 'error');
        return;
      }
      
      // Rimuove eventuali parametri query string
      slug = slug.split('?')[0].split('#')[0];
      
      // Codifica gli indirizzi per l'URL
      const fromEncoded = encodeURIComponent(startAddress);
      const toEncoded = encodeURIComponent(destAddress);
      
      // Costruisce l'URL finale Moovit per le direzioni
      // Formato: https://moovitapp.com/index/it/mezzi_pubblici-{slug}/directions?from={from}&to={to}
      const finalUrl = `https://moovitapp.com/index/it/mezzi_pubblici-${slug}?from=${fromEncoded}&to=${toEncoded}&fll=0_0&tll=0_0`;
      
      // Chiude il modal e apre Moovit
      closeModal();
      notify('‚úÖ Apertura Moovit...', 'success');
      
      // Apre in una nuova scheda
      window.open(finalUrl, '_blank');
    }
    
    // ==========================================
    // FINE FUNZIONI MOOVIT
    // ==========================================

    function calculateAndShowRoute(destination, mode) {
      if (!currentLocation) {
        notify('‚ö†Ô∏è Imposta un punto di partenza', 'error');
        return;
      }
      
      originalStartPoint = { lat: currentLocation.lat, lng: currentLocation.lng };
      
      notify('‚è≥ Calcolo percorso‚Ä¶', 'info');
      const travelMode = google.maps.TravelMode[mode.toUpperCase()];
      if (!travelMode) {
        notify('‚ùå Modalit√† di viaggio non valida: ' + mode, 'error');
        return;
      }
      
      const request = {
        origin: currentLocation,
        destination: destination,
        travelMode: travelMode,
        provideRouteAlternatives: (travelMode === google.maps.TravelMode.TRANSIT) 
      };

      directionsService.route(request, (result, status) => {
        if (status === 'OK') {
          
          if (result.routes && result.routes.length > 1 && travelMode === google.maps.TravelMode.TRANSIT) {
            currentRouteAlternativesResult = result; 
            showRouteAlternatives(result); 
          } else {
            startStepNavigation(result); 
          }

        } else {
          notify('‚ùå Impossibile calcolare il percorso: ' + status, 'error');
        }
      });
    }

    function calculateReturnTrip() {
      if (!finalDestinationPoint || !originalStartPoint) {
        notify('Errore: Punti di partenza/arrivo non trovati per il ritorno.', 'error');
        return;
      }
      
      notify('‚è≥ Calcolo percorso di ritorno (a piedi)...', 'info');
      
      const request = {
        origin: finalDestinationPoint, 
        destination: originalStartPoint,
        travelMode: google.maps.TravelMode.WALKING
      };

      directionsService.route(request, (result, status) => {
        if (status === 'OK') {
          originalStartPoint = { lat: finalDestinationPoint.lat, lng: finalDestinationPoint.lng };
          startStepNavigation(result);
        } else {
          notify('‚ùå Impossibile calcolare il percorso di ritorno: ' + status, 'error');
        }
      });
    }

    function showRouteAlternatives(result) {
      let modalBodyHtml = `<div class="modal-info" style="padding: 0;">
        <p style="padding: 0 16px 8px;">Sono state trovate ${result.routes.length} opzioni di percorso. Scegli quella che preferisci:</p>
      `;

      result.routes.forEach((route, index) => {
        const leg = route.legs[0];
        const summary = route.summary || `Percorso ${index + 1}`;
        const duration = leg.duration?.text || 'N/D';
        const distance = leg.distance?.text || 'N/D';
        const arrival = leg.arrival_time?.text ? ` (Arrivo: ${leg.arrival_time.text})` : '';
        
        const stepsSummary = (route.legs[0].steps || [])
          .filter(step => step.travel_mode === 'TRANSIT' && step.transit_details)
          .map(step => step.transit_details.line?.short_name || step.transit_details.line?.name)
          .filter(Boolean) 
          .join(' ‚Üí '); 

        modalBodyHtml += `
          <button 
            class="btn" 
            onclick="startNavigationForRoute(${index})" 
            style="width: 100%; margin-bottom: 10px; text-align: left; background: #f9f9f9; color: #333; border: 1px solid #ddd; padding: 12px;"
            onmouseover="this.style.background='#eee'" 
            onmouseout="this.style.background='#f9f9f9'"
          >
            <strong style="font-size: 1.1em; color: #667eea;">Opzione ${index + 1}: ${summary}</strong><br>
            <span style="font-size: 0.95em;">
              <strong>${duration}</strong>${arrival} (${distance})<br>
              <small>Mezzi: ${stepsSummary || 'Info non disp.'}</small>
            </span>
          </button>
        `;
      });

      modalBodyHtml += `</div>
        <div class="modal-buttons" style="margin-top:0;">
          <button class="btn btn-secondary" onclick="closeModal()">Annulla</button>
        </div>`;
      
      openModal('Scegli un Percorso (Mezzi Pubblici)', modalBodyHtml);
    }

    function startNavigationForRoute(routeIndex) {
      const fullResult = currentRouteAlternativesResult;
      
      if (!fullResult || !fullResult.routes[routeIndex]) {
        notify('‚ùå Errore: risultato del percorso non trovato.', 'error');
        closeModal();
        return;
      }

      const selectedResult = {
        ...fullResult, 
        routes: [ fullResult.routes[routeIndex] ] 
      };

      currentRouteAlternativesResult = null;
      
      closeModal();
      startStepNavigation(selectedResult);
    }

    // Array globale per memorizzare il tipo di ogni passo
    let stepDirectnessTypes = [];

    function analyzeRouteDirectness(steps) {
      // Analizza quanto ogni passo √® "diretto" confrontando:
      // - Distanza reale del percorso Google
      // - Distanza in linea d'aria tra inizio e fine passo
      
      let directCount = 0;
      let deviatedCount = 0;
      
      // Reset array globale
      stepDirectnessTypes = [];
      
      steps.forEach((step, index) => {
        // Salta i passi TRANSIT (non hanno senso per questa analisi)
        if (step.travel_mode === 'TRANSIT') {
          stepDirectnessTypes.push('transit'); // Segnaposto
          return;
        }
        
        const startLoc = new google.maps.LatLng(step.start_location.lat(), step.start_location.lng());
        const endLoc = new google.maps.LatLng(step.end_location.lat(), step.end_location.lng());
        
        // Distanza in linea d'aria (metri)
        const straightDistance = google.maps.geometry.spherical.computeDistanceBetween(startLoc, endLoc);
        
        // Distanza effettiva del percorso (metri)
        const actualDistance = step.distance?.value || 0;
        
        if (straightDistance < 5 || actualDistance < 5) {
          stepDirectnessTypes.push('skip'); // Troppo corto
          return;
        }
        
        // Calcola il "fattore di deviazione"
        const deviationFactor = (actualDistance / straightDistance) - 1;
        
        // SEMPLIFICATO: Solo 2 categorie
        if (deviationFactor < 0.4) {
          // Percorso diretto (max 40% pi√π lungo)
          directCount++;
          stepDirectnessTypes.push('direct');
        } else {
          // Percorso deviato (>40% pi√π lungo)
          deviatedCount++;
          stepDirectnessTypes.push('deviated');
        }
      });
      
      const total = directCount + deviatedCount || 1; // Evita divisione per zero
      
      let suggestion = "";
      if (deviatedCount > directCount) {
        suggestion = '<small style="color: #dc3545;">‚ö†Ô∏è Percorso con molte deviazioni. Usa il box "Direzione Reale".</small>';
      } else if (deviatedCount > 0) {
        suggestion = '<small style="color: #ffc107;">üí° Alcune deviazioni presenti. Controlla il box verde.</small>';
      } else {
        suggestion = '<small style="color: #28a745;">‚úì Percorso tutto diretto!</small>';
      }
      
      return {
        total: total,
        direct: directCount,
        deviated: deviatedCount,
        suggestion
      };
    }

    function startStepNavigation(result) {
      if (!result.routes?.[0]?.legs?.[0]) return notify('‚ùå Risultato del percorso non valido.', 'error');
      
      const leg = result.routes[0].legs[0];
      
      const totalDistance = leg.distance?.text || 'N/D';
      const totalDuration = leg.duration?.text || 'N/D';
      
      const flattenedSteps = [];
      (leg.steps || []).forEach(step => {
        if (step.travel_mode === 'WALKING' && step.steps && step.steps.length > 0) {
          flattenedSteps.push(...step.steps);
        } else {
          flattenedSteps.push(step);
        }
      });
      currentRouteSteps = flattenedSteps;

      // üìä ANALISI STATISTICA PERCORSO
      const routeAnalysis = analyzeRouteDirectness(currentRouteSteps);
      
      document.getElementById('navSummaryInfo').innerHTML = `
        <strong>Totale: ${totalDistance} (${totalDuration})</strong>
        <div style="margin-top: 10px; padding: 10px; background: #f8f9fb; border-radius: 6px; font-size: 0.9em; text-align: left;">
          <strong>üìä ANALISI PERCORSO:</strong><br>
          Passi totali: ${routeAnalysis.total}<br>
          <span style="color: #28a745;">üü¢ Diretti: ${routeAnalysis.direct} su ${routeAnalysis.total}</span><br>
          <span style="color: #dc3545;">üî¥ Deviati: ${routeAnalysis.deviated} su ${routeAnalysis.total}</span><br>
          ${routeAnalysis.suggestion}
        </div>
      `;

      currentStepIndex = 0;
      finalDestinationPoint = {lat: leg.end_location.lat(), lng: leg.end_location.lng()};
      finalDestinationAddress = leg.end_address;
      
      if (currentRouteSteps.length === 0 && !finalDestinationPoint) {
         return notify('‚ùå Nessun passo trovato per questo percorso.', 'error');
      }
      
      document.getElementById('mainContainer').style.display = 'none';
      document.getElementById('navigationView').style.display = 'flex';
      displayCurrentStep();
    }

    async function displayCurrentStep() {
      const totalStepsIncludingArrival = currentRouteSteps.length + 1;
      const navInstructionEl = document.getElementById('navInstruction');
      const transitInfoEl = document.getElementById('navTransitInfo');
      const mapsLink = document.getElementById('navGoogleMapsLink');
      const returnButton = document.getElementById('navReturnButton');
      
      transitInfoEl.style.display = 'none';
      mapsLink.style.display = 'block';
      document.getElementById('navFindAddressBtn').style.display = 'block';
      document.querySelectorAll('.nav-explore-tools button:not(#navReturnButton)').forEach(btn => btn.disabled = false);

      // üÜï Mostra loader durante l'analisi asincrona
      navInstructionEl.innerHTML = "‚è≥ Analisi passo e orientamento in corso...";

      let stepStartLat, stepStartLng, stepEndLat, stepEndLng, travelMode;

      // --- VARIABILI PER CALCOLO DIREZIONE REALE ---
      let realDirectionMsg = "";
      
      if (currentStepIndex < currentRouteSteps.length) { // Passo normale
        returnButton.style.display = 'none'; 
        
        const step = currentRouteSteps[currentStepIndex];
        const prevStep = currentStepIndex > 0 ? currentRouteSteps[currentStepIndex - 1] : null;

        currentStepStartPoint = {lat: step.start_location.lat(), lng: step.start_location.lng()};
        
        // Ottieni il tipo di questo passo dall'analisi
        const stepType = stepDirectnessTypes[currentStepIndex] || 'unknown';
        let stepBadge = '';
        
        if (stepType === 'direct') {
          stepBadge = ' üü¢ [DIRETTO]';
        } else if (stepType === 'deviated') {
          stepBadge = ' üî¥ [DEVIATO]';
        } else if (stepType === 'transit') {
          stepBadge = ' üöå [MEZZO]';
        }
        
        document.getElementById('navStepInfo').textContent = `Passo ${currentStepIndex + 1} di ${totalStepsIncludingArrival}${stepBadge}`;
        
        stepStartLat = step.start_location.lat();
        stepStartLng = step.start_location.lng();
        stepEndLat = step.end_location.lat();
        stepEndLng = step.end_location.lng();
        travelMode = step.travel_mode;

        // --- CALCOLO "DIREZIONE REALE" (Orientamento Geografico) ---
        // 1. Calcoliamo la direzione in linea d'aria tra inizio e fine passo
        const startLatLng = step.start_location;
        const endLatLng = step.end_location;
        const trueHeading = google.maps.geometry.spherical.computeHeading(startLatLng, endLatLng);
        
        // 2. Se abbiamo un passo precedente, sappiamo la tua direzione di marcia
        let relativeDir = "";
        if (prevStep) {
            // Calcoliamo la direzione del passo precedente (da dove vieni)
            const prevHeading = google.maps.geometry.spherical.computeHeading(prevStep.start_location, prevStep.end_location);
            
            // Differenza tra dove camminavi e dove punta il punto finale in linea d'aria
            let diff = trueHeading - prevHeading;
            if (diff > 180) diff -= 360;
            if (diff <= -180) diff += 360;
            
            if (diff > -20 && diff < 20) relativeDir = "DRITTO davanti a te";
            else if (diff >= 20 && diff < 160) relativeDir = "alla tua DESTRA";
            else if (diff <= -20 && diff > -160) relativeDir = "alla tua SINISTRA";
            else relativeDir = "DIETRO di te";
            
            realDirectionMsg = `<div style="margin-top:15px; padding:10px; background:#e8f5e9; border-left:5px solid #28a745; border-radius:4px; font-size:0.95em; color:#000;">
                <strong>üß≠ DIREZIONE REALE (Linea d'aria):</strong><br>
                Geograficamente, il punto finale del passo √® <strong>${relativeDir}</strong>.<br>
                <small>(Punta verso ${getCardinalDirectionLong(trueHeading)})</small>
            </div>`;
        } else {
            // Primo passo: usiamo solo i punti cardinali
            realDirectionMsg = `<div style="margin-top:15px; padding:10px; background:#e8f5e9; border-left:5px solid #28a745; border-radius:4px; font-size:0.95em; color:#000;">
                <strong>üß≠ DIREZIONE REALE (Linea d'aria):</strong><br>
                Il punto √® verso <strong>${getCardinalDirectionLong(trueHeading)}</strong>.
            </div>`;
        }

        // --- FINE CALCOLO ---

        if (step.travel_mode === 'TRANSIT' && step.transit_details) {
          const transit = step.transit_details;
          const line = transit.line?.name || transit.line?.short_name || 'Linea ND';
          const vehicle = transit.line?.vehicle?.name || 'Mezzo';
          const depTime = transit.departure_time?.text || '';
          const arrTime = transit.arrival_time?.text || '';
          navInstructionEl.innerHTML = `<strong>üöå ${line}</strong> (${vehicle})<br>
            Direzione: ${transit.headsign || 'ND'}<br>
            Partenza: ${transit.departure_stop?.name || 'ND'} ${depTime ? `(${depTime})` : ''}<br>
            Arrivo: ${transit.arrival_stop?.name || 'ND'} ${arrTime ? `(${arrTime})` : ''}<br>
            (${transit.num_stops || 'N/A'} fermate) - ${step.distance?.text || 'N/A'}`;
        } else {
          // Aggiungiamo il messaggio direzione reale sotto l'istruzione ufficiale
          let section6Integration = "";
          
          // ‚ú® INTEGRAZIONE SEZIONE 6 
          // Controlla se questo √® il primo passo a piedi (inizio viaggio O dopo un mezzo pubblico)
          const isFirstWalkingStep = (currentStepIndex === 0) || 
                                      (prevStep && prevStep.travel_mode === 'TRANSIT');
          
          if (isFirstWalkingStep && buildingDirectionFromStreet !== null) {
            try {
              const exitingDirection = (buildingDirectionFromStreet + 180) % 360;
              
              // üÜï PARSING ROBUSTO: Rimuove trattini per riconoscere "sud-ovest"/"sudovest"
              const instruction = (step.instructions || '').toLowerCase().replace(/-/g, '').replace(/\s+/g, '');
              let firstStepHeading = null;
              
              debugLog("DEBUG: Istruzione Google Maps:", step.instructions);
              debugLog("DEBUG: Istruzione pulita:", instruction);
              
              // Cerca direzioni cardinali (composte prima, semplici dopo)
              if (instruction.includes('nordovest') || instruction.includes('northwest')) {
                firstStepHeading = 315;
                debugLog("DEBUG: Trovato Nord-Ovest");
              } else if (instruction.includes('nordest') || instruction.includes('northeast')) {
                firstStepHeading = 45;
                debugLog("DEBUG: Trovato Nord-Est");
              } else if (instruction.includes('sudovest') || instruction.includes('southwest')) {
                firstStepHeading = 225;
                debugLog("DEBUG: Trovato Sud-Ovest");
              } else if (instruction.includes('sudest') || instruction.includes('southeast')) {
                firstStepHeading = 135;
                debugLog("DEBUG: Trovato Sud-Est");
              } else if (instruction.includes('nord') || instruction.includes('north')) {
                firstStepHeading = 0;
                debugLog("DEBUG: Trovato Nord");
              } else if (instruction.includes('sud') || instruction.includes('south')) {
                firstStepHeading = 180;
                debugLog("DEBUG: Trovato Sud");
              } else if (instruction.includes('ovest') || instruction.includes('west') || instruction.includes('occidente')) {
                firstStepHeading = 270;
                debugLog("DEBUG: Trovato Ovest");
              } else if (instruction.includes('est') || instruction.includes('east') || instruction.includes('oriente')) {
                firstStepHeading = 90;
                debugLog("DEBUG: Trovato Est");
              }
              
              // üÜï Fallback geometrico se il parsing fallisce
              if (firstStepHeading === null) {
                debugLog("DEBUG: Parsing testo fallito, uso geometria");
                firstStepHeading = google.maps.geometry.spherical.computeHeading(startLatLng, endLatLng);
              } else {
                debugLog("DEBUG: Usando direzione estratta:", firstStepHeading);
              }
              
              // üÜï ATTESA ASINCRONA: Aspetta che l'analisi U-Turn finisca
              const uTurnScenario = await analyzeUTurnScenario(step, prevStep);
              
              if (uTurnScenario.type !== 'normal' && uTurnScenario.type !== 'roundabout') {
                // √à un'inversione a U - usa la logica specializzata
                debugLog('üîÑ Scenario U-Turn rilevato:', uTurnScenario.type);
                section6Integration = generateUTurnInstruction(uTurnScenario, step.distance?.text);
              } else {
                // Svolte normali - MANTIENE LA LOGICA GEOMETRICA CORRETTA
                
                // Calcolo Opzione A (Uscita dal portone)
                let turnAngle = firstStepHeading - exitingDirection;
                if (turnAngle > 180) turnAngle -= 360;
                if (turnAngle <= -180) turnAngle += 360;
                
                const turnDegrees = Math.round(Math.abs(turnAngle));
                let turnDirection = "";
                
                if (turnDegrees < 20) { 
                  turnDirection = "procedi Dritto"; 
                } else if (turnDegrees >= 20 && turnDegrees < 70) {
                  turnDirection = turnAngle > 0 ? "gira a Destra sul marciapiede" : "gira a Sinistra sul marciapiede";
                } else if (turnDegrees >= 70 && turnDegrees < 110) {
                  turnDirection = turnAngle > 0 ? "gira decisamente a Destra" : "gira decisamente a Sinistra";
                } else if (turnDegrees >= 110 && turnDegrees < 160) {
                  turnDirection = turnAngle > 0 ? "gira quasi indietro verso Destra" : "gira quasi indietro verso Sinistra";
                } else {
                  turnDirection = turnAngle > 0 ? "fai quasi mezzo giro verso Destra" : "fai quasi mezzo giro verso Sinistra";
                }
                
                // Calcolo Opzione B (Spalle alla strada) - GEOMETRIA CORRETTA A 180¬∞
                let oppositeAngle = firstStepHeading - exitingDirection - 180;
                if (oppositeAngle > 180) oppositeAngle -= 360;
                if (oppositeAngle <= -180) oppositeAngle += 360;
                
                const oppositeDegrees = Math.round(Math.abs(oppositeAngle));
                let oppositeDirection = "";
                
                if (oppositeDegrees < 20) { 
                  oppositeDirection = "procedi Dritto"; 
                } else if (oppositeDegrees >= 20 && oppositeDegrees < 70) {
                  oppositeDirection = oppositeAngle > 0 ? "gira a Destra sul marciapiede" : "gira a Sinistra sul marciapiede";
                } else if (oppositeDegrees >= 70 && oppositeDegrees < 110) {
                  oppositeDirection = oppositeAngle > 0 ? "gira decisamente a Destra" : "gira decisamente a Sinistra";
                } else if (oppositeDegrees >= 110 && oppositeDegrees < 160) {
                  oppositeDirection = oppositeAngle > 0 ? "gira quasi indietro verso Destra" : "gira quasi indietro verso Sinistra";
                } else {
                  oppositeDirection = oppositeAngle > 0 ? "fai quasi mezzo giro verso Destra" : "fai quasi mezzo giro verso Sinistra";
                }
                
                section6Integration = `
                  <div style="margin-top:15px; padding:12px; background:#e3f2fd; border-left:5px solid #2196f3; border-radius:4px; font-size:0.95em; color:#000;">
                    <strong>üè¢ OPZIONE A - Uscendo dal portone:</strong><br>
                    ${turnDirection}.<br>
                    <span style="margin-top: 8px; display: block; font-style: italic; color: #555; border-top: 1px dashed #bbb; padding-top: 8px; font-size: 0.9em;">
                      <strong>üöç/üöñ OPZIONE B - Dando le spalle alla strada:</strong> ${oppositeDirection}.
                    </span>
                  </div>
                `;
              }
            } catch (err) {
              console.error('Errore analisi orientamento:', err);
              // üÜï Fallback: mostra almeno l'istruzione base
              section6Integration = `
                <div style="margin-top:15px; padding:12px; background:#fff3cd; border-left:5px solid #ffc107; border-radius:4px; font-size:0.95em; color:#856404;">
                  ‚ö†Ô∏è Calcolo orientamento non disponibile. Usa i punti cardinali dalla sezione "Direzione Reale".
                </div>
              `;
            }
          }
          
          navInstructionEl.innerHTML = (step.instructions || 'Nessuna istruzione').replace(/<[^>]*>/g, '') + 
                                       ` (${step.distance?.text || ''})` + 
                                       section6Integration +
                                       realDirectionMsg;
          
          // üÜï ANALISI RAY CASTING - Sicurezza Attraversamenti (ASINCRONA)
          try {
            await analyzeRoadCrossings(step, navInstructionEl);
          } catch (err) {
            console.error('Errore Ray Casting:', err);
          }
        }
      } else { // Arrivo
        returnButton.style.display = 'block'; 

        currentStepStartPoint = finalDestinationPoint;
        document.getElementById('navStepInfo').textContent = `Arrivo (Passo ${totalStepsIncludingArrival} di ${totalStepsIncludingArrival})`;
        navInstructionEl.innerHTML = `üèÅ Sei arrivato a destinazione: ${finalDestinationAddress}`;
        stepStartLat = stepEndLat = finalDestinationPoint.lat;
        stepStartLng = stepEndLng = finalDestinationPoint.lng;
        travelMode = 'WALKING';
      }
      
      // üÜï Gestione bottoni navigazione
      document.getElementById('navPrevButton').disabled = (currentStepIndex === 0);
      document.getElementById('navNextButton').disabled = (currentStepIndex >= currentRouteSteps.length);
      
      // Link Google Maps
      const gMapsMode = (travelMode === 'TRANSIT') ? 'transit' : (travelMode === 'BICYCLING' ? 'bicycling' : (travelMode === 'DRIVING' ? 'driving' : 'walking'));
      mapsLink.href = (currentStepIndex < currentRouteSteps.length) ?
        `https://www.google.com/maps/dir/?api=1&origin=${stepStartLat},${stepStartLng}&destination=${stepEndLat},${stepEndLng}&travelmode=${gMapsMode}` :
        `https://www.google.com/maps/search/?api=1&query=${finalDestinationPoint.lat},${finalDestinationPoint.lng}`;
      
      setTimeout(() => navInstructionEl.focus(), 100);
    }

    function navNextStep() {
      if (currentStepIndex < currentRouteSteps.length) {
        currentStepIndex++;
        displayCurrentStep();
      }
    }

    function navPrevStep() {
      if (currentStepIndex > 0) {
        currentStepIndex--;
        displayCurrentStep();
      }
    }

    function exitNavigation() {
      document.getElementById('navigationView').style.display = 'none';
      document.getElementById('mainContainer').style.display = 'block';
      document.getElementById('navSummaryInfo').textContent = '';
      currentRouteSteps = [];
      currentStepStartPoint = null;
      originalStartPoint = null;
      finalDestinationPoint = null;
    }

    function findAddressForCurrentStep() {
      if (!currentStepStartPoint) return notify('‚ùå Punto di partenza del passo non trovato.', 'error');
      findAddressForPoint(currentStepStartPoint.lat, currentStepStartPoint.lng);
    }

    async function exploreStep(source) {
      if (!currentStepStartPoint) return notify('‚ùå Punto di partenza del passo non trovato.', 'error');

      const startPoint = currentStepStartPoint;
      const radius = parseInt(document.getElementById('radiusInput').value, 10) || 500;
      let places = [];
      let title = '';
      
      try {
        if (source === 'google') {
          title = 'Esplora Servizi (Google)';
          notify(`üì° Esploro servizi...`, 'info');
          places = await fetchGooglePlacesForStep(startPoint, radius);
        } else if (source === 'osm') {
          title = 'Esplora Incroci (OSM)';
          notify(`üß≠ Esploro incroci...`, 'info');
          places = await fetchOSMIntersectionsForStep(startPoint, radius);
        } else if (source === 'transitland') {
          title = 'Esplora Fermate (Transitland)';
          notify(`üöå Esploro fermate...`, 'info');
          places = await fetchTransitlandStopsForStep(startPoint, radius);
        } else if (source === 'osm_poi') {
          title = 'Esplora POI (OSM)';
          notify(`üó∫Ô∏è Esploro POI...`, 'info');
          places = await fetchOSMPlacesForStep(startPoint, radius);
        }
        showExploreResultsModal(places, title, startPoint);
      } catch (e) {
        notify(`‚ùå Errore esplorazione: ${e.message}`, 'error');
        openModal('Errore Esplorazione', `<p>${e.message}</p><div class="modal-buttons"><button class="btn" onclick="closeModal()">Chiudi</button></div>`);
      }
    }

    async function fetchGooglePlacesForStep(location, radius) {
      let allPlaces = [];
      for (const type of DAILY_DEFAULT.slice(0, 10)) {
        await new Promise(resolve => {
          service.nearbySearch({location: location, radius: radius, type: type}, (results, status) => {
            if (status === google.maps.places.PlacesServiceStatus.OK && results) {
              allPlaces.push(...results);
            }
            resolve();
          });
        });
      }
      const uniquePlaces = Array.from(new Map(allPlaces.map(p => [p.place_id, p])).values());
      const origin = new google.maps.LatLng(location.lat, location.lng);
      
      return uniquePlaces.map(p => {
          const distance = p.geometry?.location ? google.maps.geometry.spherical.computeDistanceBetween(origin, p.geometry.location) : null;
          let cardinal = '';
          if (p.geometry?.location) {
              const heading = google.maps.geometry.spherical.computeHeading(origin, p.geometry.location);
              cardinal = ` [${getCardinalDirectionShort(heading)}]`;
          }
          return {
              name: p.name || 'Senza nome',
              details: `${p.vicinity || 'ND'} - Distanza: ${formatDistance(distance)}${cardinal}`,
              coords: p.geometry?.location ? {lat: p.geometry.location.lat(), lng: p.geometry.location.lng()} : null,
              distance: distance,
              place_id: p.place_id,
              source: 'google'
          }
      }).sort((a, b) => (a.distance ?? Infinity) - (b.distance ?? Infinity));
    }

    async function fetchOSMIntersectionsForStep(location, radius) {
      const query = `[out:json];way(around:${radius},${location.lat},${location.lng})["highway"];(._;>;);out body;`;
      
      // üÜï Chiamata DIRETTA a Overpass API (supporta CORS)
      const url = `https://overpass-api.de/api/interpreter?data=${encodeURIComponent(query)}`;
      const resp = await fetch(url, {
        method: 'GET'
      });
      if (!resp.ok) throw new Error(`Errore Overpass API: ${resp.status}`);
      const data = await resp.json();
      const nodes = new Map(data.elements.filter(e => e.type === 'node').map(n => [n.id, n]));
      const nodeToWays = new Map();
      data.elements.filter(e => e.type === 'way').forEach(w => {
        const name = w.tags?.name || w.tags?.ref || 'Strada senza nome';
        (w.nodes || []).forEach(nid => {
          if (!nodeToWays.has(nid)) nodeToWays.set(nid, new Set());
          nodeToWays.get(nid).add(name);
        });
      });
      const intersections = [];
      const origin = new google.maps.LatLng(location.lat, location.lng);
      nodeToWays.forEach((streetSet, nodeId) => {
        if (streetSet.size >= 2) {
          const node = nodes.get(nodeId);
          if (!node) return;
          const dist = google.maps.geometry.spherical.computeDistanceBetween(origin, {lat: node.lat, lng: node.lon});
          if (dist <= radius) {
            const heading = google.maps.geometry.spherical.computeHeading(origin, {lat: node.lat, lng: node.lon});
            const cardinal = ` [${getCardinalDirectionShort(heading)}]`;
            intersections.push({
              name: [...streetSet].join(' √ó '),
              details: `Distanza: ${formatDistance(dist)}${cardinal}`,
              coords: {lat: node.lat, lng: node.lon},
              distance: dist,
              source: 'osm_intersection'
            });
          }
        }
      });
      return intersections.sort((a, b) => (a.distance ?? Infinity) - (b.distance ?? Infinity));
    }

    async function fetchTransitlandStopsForStep(location, radius) {
      // ‚ö†Ô∏è FUNZIONE DISABILITATA - Transitland API richiede proxy server (no CORS)
      // Per riabilitarla, configura un server proxy personale che faccia da intermediario
      console.warn('‚ö†Ô∏è Fermate Transitland non disponibili - richiede proxy server');
      return []; // Restituisce array vuoto
    }

        async function fetchOSMPlacesForStep(location, radius) {
      const poiTypes = "amenity|shop|tourism|leisure|office|public_transport|historic|sport";
      const query = `[out:json];node(around:${radius},${location.lat},${location.lng})[~"^(${poiTypes})$"~"."];out body;`;
      try {
        // üÜï Chiamata DIRETTA a Overpass API (supporta CORS)
        const url = `https://overpass-api.de/api/interpreter?data=${encodeURIComponent(query)}`;
        const resp = await safeFetch(url, {
          method: 'GET'
        }, 7000, 'OpenStreetMap');
        
        const data = await resp.json();
        const nodes = data.elements.filter(e => e.type === 'node' && e.tags);
        debugLog(`‚úÖ Trovati ${nodes.length} POI OSM`);
        
        const origin = new google.maps.LatLng(location.lat, location.lng);
        
        return nodes.map(node => {
          const dist = google.maps.geometry.spherical.computeDistanceBetween(origin, {lat: node.lat, lng: node.lon});
          const name = node.tags?.name || 'Senza nome';
          const typeKey = Object.keys(node.tags).find(k => poiTypes.includes(k));
          const typeValue = typeKey ? node.tags[typeKey].replace(/_/g, ' ') : 'POI';
          const heading = google.maps.geometry.spherical.computeHeading(origin, {lat: node.lat, lng: node.lon});
          const cardinal = ` [${getCardinalDirectionShort(heading)}]`;
          return {
            name: `${name} (${typeValue})`,
            details: `Distanza: ${formatDistance(dist)}${cardinal}`,
            coords: {lat: node.lat, lng: node.lon},
            distance: dist,
            source: 'osm_poi'
          };
        }).sort((a, b) => (a.distance ?? Infinity) - (b.distance ?? Infinity));
      } catch (e) {
        announceError(`Impossibile recuperare POI da OpenStreetMap: ${e.message}`);
        throw e;
      }
    }

    function showExploreResultsModal(places, title, startPoint) {
      if (!places || places.length === 0) {
        return openModal(title, '<p>Nessun risultato trovato.</p><div class="modal-buttons"><button class="btn" onclick="closeModal()">Chiudi</button></div>');
      }
      const startLatLng = new google.maps.LatLng(startPoint.lat, startPoint.lng);
      const placesHtml = places.map(p => {
        let cardinal = 'ND';
        if (p.coords) {
          const endLatLng = new google.maps.LatLng(p.coords.lat, p.coords.lng);
          if (Math.abs(p.coords.lat - startPoint.lat) > 1e-6 || Math.abs(p.coords.lng - startPoint.lng) > 1e-6) {
            cardinal = getCardinalDirectionShort(google.maps.geometry.spherical.computeHeading(startLatLng, endLatLng));
          } else {
            cardinal = 'Qui';
          }
        }
        const icon = p.source === 'google' ? 'üì°' : (p.source === 'osm_intersection' ? 'üß≠' : (p.source === 'transitland' ? 'üöå' : 'üó∫Ô∏è'));
        
        // Costruiamo le azioni disponibili per il popup
        let actionButtons = '';
        if (p.coords) {
             // Aggiunto il pulsante "Imposta come Partenza" anche qui nel modale di esplorazione
             actionButtons += `<button class="btn btn-green" style="font-size:12px; margin-right:5px;" onclick="setStartPointFromModal(${p.coords.lat}, ${p.coords.lng}, '${p.name.replace(/'/g, "\\'")}')">üö© Imposta Partenza</button>`;
             actionButtons += `<button class="btn btn-ghost" style="font-size:12px;" onclick="findAddressForPoint(${p.coords.lat}, ${p.coords.lng})">üìç Trova Indirizzo</button>`;
        }

        return `<div class="place-card">
          <strong>${icon} ${p.name}</strong><br>
          <small><strong>[${cardinal}]</strong> ${p.details}</small>
          <div style="margin-top:8px">${actionButtons}</div>
        </div>`;
      }).join('');
      openModal(`${title} (${places.length} risultati)`, `<div class="explore-results-list">${placesHtml}</div><div class="modal-buttons"><button class="btn btn-secondary" onclick="closeModal()">Chiudi</button></div>`);
    }

    // Funzione helper per il modale di esplorazione
    function setStartPointFromModal(lat, lng, name) {
        // üÜï Usa coordinate esatte per fermate Transitland
        setPosition({lat, lng}, name);
        document.getElementById('addressInput').value = `${name} (Coord: ${lat.toFixed(5)}, ${lng.toFixed(5)})`;
        notify('‚úÖ Punto di partenza aggiornato con coordinate esatte!', 'success');
        closeModal();
        document.getElementById('topHeader').scrollIntoView({behavior: 'smooth'});
    }

    // Proxy-related functions
    async function fetchTransitlandStops() {
      if (!currentLocation) return notify('‚ö†Ô∏è Imposta un punto di partenza', 'error');
      displayUnifiedResults([], "Ricerca Fermate Reali in corso...");
      try {
        const stops = await fetchTransitlandStopsForStep(currentLocation, document.getElementById('radiusInput').value);
        displayUnifiedResults(stops, stops.length > 0 ? "Fermate Reali Trovate" : "Nessuna Fermata Trovata");
        if (stops.length === 0) notify('Nessuna fermata Transitland trovata.', 'info');
      } catch (e) {
        displayUnifiedResults([], "Errore Ricerca Fermate");
        notify('‚ùå ' + e.message, 'error');
      }
    }

    async function listOSMIntersections() {
      if (!currentLocation) return notify('‚ö†Ô∏è Imposta un punto di partenza', 'error');
      displayUnifiedResults([], "Ricerca Incroci OSM in corso...");
      try {
        const intersections = await fetchOSMIntersectionsForStep(currentLocation, document.getElementById('radiusInput').value);
        displayUnifiedResults(intersections, intersections.length > 0 ? "Incroci Trovati" : "Nessun Incrocio Trovato");
        if (intersections.length === 0) notify('Nessun incrocio OSM trovato.', 'info');
      } catch (e) {
        displayUnifiedResults([], "Errore Ricerca Incroci");
        notify('‚ùå Errore di rete OSM: ' + e.message, 'error');
      }
    }

    async function listOSMPlacesAll() {
      if (!currentLocation) return notify('‚ö†Ô∏è Imposta un punto di partenza', 'error');
      displayUnifiedResults([], "Ricerca POI OSM in corso...");
      try {
        const items = await fetchOSMPlacesForStep(currentLocation, document.getElementById('radiusInput').value);
        displayUnifiedResults(items, items.length > 0 ? "Punti di Interesse OSM Trovati" : "Nessun POI Trovato");
        if (items.length === 0) notify('Nessun POI OSM trovato.', 'info');
      } catch (e) {
        displayUnifiedResults([], "Errore Ricerca POI");
        notify('‚ùå Errore di rete OSM: ' + e.message, 'error');
      }
    }

    async function fetchWeather() {
      if (!currentLocation) return notify('‚ö†Ô∏è Imposta un punto di partenza', 'error');
      const out = document.getElementById('weatherResults');
      out.style.display = 'block';
      out.textContent = '‚è≥ Caricamento meteo...';
      const url = `https://api.open-meteo.com/v1/forecast?latitude=${currentLocation.lat}&longitude=${currentLocation.lng}&current_weather=true`;
      try {
        const resp = await fetch(url);
        if (!resp.ok) throw new Error(`Errore Meteo: ${resp.status}`);
        const data = await resp.json();
        out.innerHTML = `<strong>Meteo Attuale:</strong> ${data.current_weather.temperature}¬∞C ‚Äî <strong>Vento:</strong> ${data.current_weather.windspeed} km/h`;
      } catch (e) {
        out.textContent = '‚ùå Errore di rete Meteo: ' + e.message;
      }
    }

    // AI Prompt functions
    
    // PROMPT 1: Fermate Vicine (ricerca fermate entro 500m)
    async function prepareStopsNearbyPrompt() {
      try {
        if (!currentLocation) throw new Error('Imposta un punto di partenza nella Sezione 1.');
        const addr = document.getElementById('addressInput').value || 'Punto selezionato';
        const coords = `${currentLocation.lat.toFixed(6)}, ${currentLocation.lng.toFixed(6)}`;
        
        const prompt = `Trova tutte le fermate del trasporto pubblico vicine a:
üìç Indirizzo: ${addr}
üìê Coordinate: ${coords}

1. Coordinate
‚Ä¢ Ricava latitudine e longitudine precise dell'indirizzo (Google Maps o OpenStreetMap).

2. Ricerca fermate (entro 500 m)
‚Ä¢ Trova fermate di qualunque tipo: autobus, tram, metro, treni regionali, funicolari, traghetti, navette urbane, ecc.
‚Ä¢ Usa come fonti:
  ‚Äì OpenStreetMap (public_transport=platform, stop_position, stop_area, highway=bus_stop)
  ‚Äì feed GTFS disponibili (qualsiasi operatore del mondo)
  ‚Äì dataset ufficiali locali (se presenti)
  ‚Äì Moovit solo per confermare eventuale pagina della fermata

3. Output richiesto per ogni fermata
‚Ä¢ Nome
‚Ä¢ Tipo (bus, metro, tram, ecc.)
‚Ä¢ Linee servite
‚Ä¢ Coordinate
‚Ä¢ Distanza precisa in metri
‚Ä¢ Link Moovit (se disponibile)

4. Ordinamento
‚Ä¢ Ordina dalla fermata pi√π vicina alla pi√π lontana.

5. Espansione del raggio
‚Ä¢ Se entro 500 m non trovi nulla, aumenta a 700 m.

6. Importantissimo
‚Ä¢ NON calcolare percorsi; Moovit Web non supporta la ricerca per coordinate.
‚Ä¢ Usa l'incrocio di OSM + GTFS + dataset locali per trovare le fermate reali.
‚Ä¢ NON inventare dati: usa solo fonti verificabili.`;

        const ok = await copyText(prompt);
        openModal('üöè Prompt: Fermate Vicine', `
          <p style="margin-bottom:10px">${ok ? '‚úÖ Prompt copiato negli appunti!' : 'üìã Copia il prompt qui sotto:'}</p>
          <textarea id="copyBox" style="width:100%;height:320px;font-family:monospace;font-size:13px;padding:10px;border-radius:8px;border:2px solid #667eea" readonly>${prompt}</textarea>
          <div class="modal-buttons">
            <button class="btn btn-ghost" onclick="document.getElementById('copyBox').select();document.execCommand('copy');notify('‚úÖ Copiato!','success')">üìã Copia</button>
            <button class="btn" onclick="closeModal()">Chiudi</button>
          </div>`);
        document.getElementById('copyBox').select();
      } catch (e) { notify('‚ùå Errore: ' + e.message, 'error'); }
    }
    
    // PROMPT 2: Analisi Trasporto Pubblico (analisi completa operatori)
    async function prepareTransportAnalysisPrompt() {
      try {
        if (!currentLocation) throw new Error('Imposta un punto di partenza nella Sezione 1.');
        const addr = document.getElementById('addressInput').value || 'Punto selezionato';
        const coords = `${currentLocation.lat.toFixed(6)}, ${currentLocation.lng.toFixed(6)}`;
        const city = cityGuess || '';
        
        const prompt = `Analisi Trasporto Pubblico

Agisci come un analista globale dei dati del trasporto pubblico.
L'obiettivo √® identificare tutte le fermate e tutti gli operatori di trasporto pubblico (bus, tram, metro, treni suburbani, traghetti, funicolari) attivi o storicamente presenti in un'area.

üìç INPUT:
Indirizzo: ${addr}
Coordinate: ${coords}
${city ? `Citt√†: ${city}` : ''}

üìç Interpretazione dell'input
‚Ä¢ Se fornisco una via con indirizzo preciso ‚Üí analizza entro 400 m, estendibili fino a 800 m.
‚Ä¢ Se fornisco solo una citt√† o un comune ‚Üí considera l'intera area urbana.
‚Ä¢ Se non specifico la localit√† ‚Üí chiedi: "Per favore indica un indirizzo o una citt√†."

üîπ FASE 1 ‚Äì RICERCA FERMATE
‚Ä¢ Trova tutte le fermate nell'area tramite:
  ‚Äì OpenStreetMap (public_transport=*)
  ‚Äì feed GTFS (qualsiasi operatore mondiale)
  ‚Äì dataset open data locali
  ‚Äì piattaforme digitali (Google Maps, Moovit, Transitland, MobilityDatabase)
‚Ä¢ Se √® un indirizzo preciso ‚Üí ordina le fermate per distanza.
‚Ä¢ Se √® una citt√† ‚Üí raggruppale per quartiere/zona.

Per ogni fermata includi:
‚Äì nome
‚Äì tipi di servizio (bus, metro, tram, ecc.)
‚Äì linee servite
‚Äì fonte del dato (GTFS, OSM, Google, Moovit, PDF locale)
‚Äì NON inventare dati: usa solo dati verificabili.

üîπ FASE 2 ‚Äì ANALISI DEGLI OPERATORI (4 LIVELLI)

1Ô∏è‚É£ Livello istituzionale
‚Ä¢ Identifica gli operatori autorizzati tramite registri ufficiali (nazionali o regionali del paese considerato).

2Ô∏è‚É£ Livello digitale
‚Ä¢ Verifica quali operatori hanno feed GTFS pubblici e sono integrati in app come Google, Moovit, Transit, Citymapper.

3Ô∏è‚É£ Livello open-data (OSM + dataset locali)
‚Ä¢ Controlla se esistono linee o operatori presenti solo su OSM o su open data non ufficiali.

4Ô∏è‚É£ Livello empirico
‚Ä¢ Analizza orari PDF, siti aziendali, articoli locali, e verifica su Street View la presenza fisica di cartelli, paline e fermate.

üîπ OUTPUT FINALE (testo narrativo, chiaro e strutturato)
‚Ä¢ Elenca operatori istituzionali
‚Ä¢ Elenca operatori digitalmente integrati
‚Ä¢ Elenca operatori presenti solo su fonti open o empiriche
‚Ä¢ Indica eventuali linee/fermate "fantasma" o non mappate correttamente

Chiudi sempre chiedendo:
¬´Vuoi aumentare il raggio di ricerca o approfondire una fermata o un operatore?¬ª`;

        const ok = await copyText(prompt);
        openModal('üöå Prompt: Analisi Trasporto Pubblico', `
          <p style="margin-bottom:10px">${ok ? '‚úÖ Prompt copiato negli appunti!' : 'üìã Copia il prompt qui sotto:'}</p>
          <textarea id="copyBox" style="width:100%;height:350px;font-family:monospace;font-size:13px;padding:10px;border-radius:8px;border:2px solid #667eea" readonly>${prompt}</textarea>
          <div class="modal-buttons">
            <button class="btn btn-ghost" onclick="document.getElementById('copyBox').select();document.execCommand('copy');notify('‚úÖ Copiato!','success')">üìã Copia</button>
            <button class="btn" onclick="closeModal()">Chiudi</button>
          </div>`);
        document.getElementById('copyBox').select();
      } catch (e) { notify('‚ùå Errore: ' + e.message, 'error'); }
    }

    // PROMPT 3: Social (ricerca su Facebook/Instagram) - INVARIATO
    async function prepareSocialPrompt() {
      try {
        if (!currentLocation) throw new Error('Imposta un punto.');
        const addr = document.getElementById('addressInput').value;
        if (!addr) throw new Error('Indirizzo non trovato.');
        const prompt = `Trova Pagine e Post su Facebook/Instagram per attivit√† locali (es. ristorante, bar) nelle immediate vicinanze di "${addr}". FORMAT: Tabella con Nome, Piattaforma, URL, indirizzo, segnali di novit√† (es. "apertura"). Vuoi estendere la ricerca (indica i metri) o vuoi info/indicazioni per un luogo specifico (indica il nome)?`;
        const ok = await copyText(prompt);
        openModal('üí¨ Prompt: Ricerca Social', `
          <p style="margin-bottom:10px">${ok ? '‚úÖ Prompt copiato negli appunti!' : 'üìã Copia il prompt qui sotto:'}</p>
          <textarea id="copyBox" style="width:100%;height:260px;font-family:monospace;font-size:13px;padding:10px;border-radius:8px;border:2px solid #667eea" readonly>${prompt}</textarea>
          <div class="modal-buttons">
            <button class="btn btn-ghost" onclick="document.getElementById('copyBox').select();document.execCommand('copy');notify('‚úÖ Copiato!','success')">üìã Copia</button>
            <button class="btn" onclick="closeModal()">Chiudi</button>
          </div>`);
        document.getElementById('copyBox').select();
      } catch (e) { notify('‚ùå Errore prompt: ' + e.message, 'error'); }
    }

    // ---------------
    // FUNZIONALIT√Ä ORIENTAMENTO CIVICO (Sez. 6)
    // ---------------
    
    async function geocodeWithNominatim(address) {
        const encodedAddress = encodeURIComponent(address);
        const url = `https://nominatim.openstreetmap.org/search?q=${encodedAddress}&format=json&limit=1&email=mobility-app@example.com`;
        try {
            const response = await fetch(url);
            if (!response.ok) throw new Error(`Errore rete Nominatim: ${response.statusText}`);
            const data = await response.json();
            return (data?.length > 0) ? { lat: parseFloat(data[0].lat), lng: parseFloat(data[0].lon) } : null;
        } catch (error) {
            console.error("Fallimento chiamata Nominatim:", error);
            throw error;
        }
    }
    
    async function runCivicAnalysis() {
        const orientationStatusDiv = document.getElementById('orientation-status');
        const turnInstructionStatusDiv = document.getElementById('turn-instruction-status');

        if (!currentLocation) {
            updateStatus(orientationStatusDiv, "Errore: Imposta un indirizzo o rileva la posizione nella Sezione 1.", 'error');
            updateStatus(turnInstructionStatusDiv, "Imposta prima un indirizzo.");
            return;
        }

        // ‚ú® SE L'ORIENTAMENTO √à GI√Ä STATO CALCOLATO AUTOMATICAMENTE, MOSTRALO
        if (buildingDirectionFromStreet !== null) {
            const exitingDirection = (buildingDirectionFromStreet + 180) % 360;
            
            updateStatus(orientationStatusDiv, `
                <span class="success-message">‚úÖ Orientamento gi√† calcolato automaticamente in Sezione 1:</span>
                <span class="output-line">Uscendo dall'edificio</span>
                <span class="output-line">Guardando verso <strong>${getCardinalDirectionLong(exitingDirection)}</strong> (${Math.round(exitingDirection)}¬∞)</span>
                <span class="output-line" style="margin-top: 1em; padding-top: 0.5em; border-top: 1px dashed #ccc;">
                    üí° Per ricalcolare o analizzare un edificio diverso, modifica prima l'indirizzo in Sezione 1, poi clicca nuovamente "Analizza".
                </span>
            `, 'success', true);
            
            // Mostra anche la svolta se c'√® una direzione desiderata
            calculateAndShowTurnInstruction();
            return;
        }

        // Se non c'√® orientamento, esegui il calcolo completo
        const address = document.getElementById('addressInput').value;
        updateStatus(orientationStatusDiv, "Analisi in corso (Passo 1/3): Verifico coordinate Google...", 'info');
        updateStatus(turnInstructionStatusDiv, "Analisi in corso...");
        buildingDirectionFromStreet = null; 
         // Reset flag "Spalle al Palo" 

        let googlePoint = currentLocation;
        let osmPoint = null;
        let distanceToOsm = null;
        let googlePrecision = 'UNKNOWN';

        try {
            // *** PASSO 1: Ottieni dettagli di precisione (con Fallback intelligente) ***
            const googleResult = await new Promise((resolve, reject) => {
                // Tentativo A: Cerca per indirizzo testuale (massima precisione)
                geocoder.geocode({ 'address': address }, (results, status) => {
                    if (status === 'OK' && results?.[0]) {
                        resolve(results[0]);
                    } else {
                        // Tentativo B (FALLBACK): Se il testo fallisce, usa le coordinate (pi√π robusto)
                        console.warn("Geocoding testuale fallito, uso coordinate fallback.");
                        geocoder.geocode({ 'location': currentLocation }, (resLoc, stLoc) => {
                            if (stLoc === 'OK' && resLoc?.[0]) {
                                resolve(resLoc[0]);
                            } else {
                                reject(new Error(`Errore Google Geocoding: ${status} / ${stLoc}`));
                            }
                        });
                    }
                });
            });

            // Aggiorniamo i dati con il risultato migliore trovato
            currentLocation = {lat: googleResult.geometry.location.lat(), lng: googleResult.geometry.location.lng()};
            googlePoint = currentLocation;
            googlePrecision = googleResult.geometry.location_type; 
            
            updateStatus(orientationStatusDiv, `Analisi in corso (Passo 2/3): Google OK (Precisione: ${googlePrecision}). Verifico con OpenStreetMap...`, 'info');

            // *** PASSO 2: Geocoding OSM (Nominatim) ***
            try {
                // Usiamo il testo formattato ufficiale per la ricerca OSM per aumentare le chance di successo
                osmPoint = await geocodeWithNominatim(googleResult.formatted_address || address);
                if (osmPoint) {
                    distanceToOsm = haversineDistance(googlePoint, osmPoint);
                    updateStatus(orientationStatusDiv, `Analisi in corso (Passo 3/3): Verifica OSM OK (Distanza: ${distanceToOsm.toFixed(1)}m). Cerco Street View...`, 'info');
                } else {
                     updateStatus(orientationStatusDiv, `Analisi in corso (Passo 3/3): Indirizzo non trovato su OSM. Procedo solo con Google...`, 'info');
                }
            } catch (osmError) {
                console.warn("Errore Nominatim:", osmError);
                updateStatus(orientationStatusDiv, `Analisi in corso (Passo 3/3): Servizio OSM non disponibile. Procedo solo con Google...`, 'info');
            }

            // *** PASSO 3: Analisi Geometrica ***
            await analyzeOrientationGeometrically(
                googleResult.geometry.location, 
                googleResult.formatted_address, 
                googlePrecision, 
                distanceToOsm
            );

        } catch (error) {
            updateStatus(orientationStatusDiv, `Errore: ${error.message}`, 'error');
            updateStatus(turnInstructionStatusDiv, `Analisi fallita: ${error.message}`, 'error');
        }
    }

    // ================================================================
    // NUOVO SISTEMA DI ORIENTAMENTO "A CASCATA" (ROBUSTNESS V2)
    // Sistema a 4 tentativi progressivi con feedback di affidabilit√†
    // ================================================================

    // ================================================================
    // VERSIONE  "L'OSTINATO INTELLIGENTE" (by Gemini)
    // Cerca progressivamente (50->250m). Accetta solo se il NOME VIA coincide.
    // ================================================================

    // ================================================================
    // GESTIONE LUOGHI COMPLESSI (Piazze, Incroci, Rotonde)
    // ================================================================

    // ================================================================
    // SISTEMA CHECK PRECISIONE GEOCODING (Fase 1)
    // Verifica se un civico √® ESATTO o INTERPOLATO
    // ================================================================

    /**
     * Verifica la precisione di un indirizzo geocodificato
     * Restituisce il tipo di precisione e un punteggio di affidabilit√†
     */
    async function checkGeocodingPrecision(address) {
        return new Promise((resolve) => {
            geocoder.geocode({ address: address }, (results, status) => {
                if (status === 'OK' && results?.[0]) {
                    const result = results[0];
                    const locationType = result.geometry.location_type;
                    
                    // Definizione livelli di precisione
                    const precisionLevels = {
                        'ROOFTOP': {
                            reliable: true,
                            score: 100,
                            emoji: 'üü¢',
                            color: '#28a745',
                            title: 'Punto Esatto',
                            message: 'Il portone/edificio √® mappato esattamente da Google',
                            shortMessage: '‚úÖ Punto esatto (portone identificato)'
                        },
                        'RANGE_INTERPOLATED': {
                            reliable: false,
                            score: 40,
                            emoji: 'üü°',
                            color: '#ffc107',
                            title: 'Stima Approssimativa',
                            message: 'Google non conosce questo civico. Ha "indovinato" la posizione interpolando tra civici noti.',
                            shortMessage: '‚ö†Ô∏è Stima approssimativa (civico non mappato)'
                        },
                        'GEOMETRIC_CENTER': {
                            reliable: false,
                            score: 20,
                            emoji: 'üü†',
                            color: '#ff9800',
                            title: 'Centro Geometrico',
                            message: 'Google ha restituito il centro della via/area. Molto impreciso.',
                            shortMessage: '‚ö†Ô∏è Centro geometrico (molto impreciso)'
                        },
                        'APPROXIMATE': {
                            reliable: false,
                            score: 10,
                            emoji: 'üî¥',
                            color: '#dc3545',
                            title: 'Approssimato',
                            message: 'Google ha restituito una zona generica. Estremamente impreciso.',
                            shortMessage: '‚ùå Approssimato (zona generica)'
                        }
                    };
                    
                    const precisionInfo = precisionLevels[locationType] || precisionLevels['APPROXIMATE'];
                    
                    resolve({
                        found: true,
                        address: result.formatted_address,
                        type: locationType,
                        location: result.geometry.location,
                        ...precisionInfo
                    });
                } else {
                    resolve({
                        found: false,
                        error: status,
                        score: 0,
                        reliable: false
                    });
                }
            });
        });
    }

    /**
     * Estrae il nome della via da un indirizzo
     */
    function extractStreetName(address) {
        // Rimuove numero civico e citt√†
        const cleaned = address.toLowerCase()
            .replace(/,.*$/, '') // Rimuove tutto dopo la virgola
            .replace(/\d+/g, '') // Rimuove numeri
            .replace(/^(via|viale|piazza|corso|largo|strada|vicolo)\s+/i, '') // Rimuove prefisso
            .trim();
        
        return cleaned;
    }

    /**
     * Mostra il risultato del check di precisione all'utente
     */
    function showPrecisionCheckResult(precisionData, targetDiv) {
        if (!precisionData.found) {
            const html = `
                <div style="border-left: 5px solid #dc3545; padding: 15px; background: #fff; border-radius: 8px; margin: 15px 0;">
                    <h4 style="color: #dc3545; margin: 0 0 10px 0;">‚ùå Indirizzo Non Trovato</h4>
                    <p style="margin: 0;">Impossibile geocodificare l'indirizzo. Verifica che sia corretto.</p>
                </div>
            `;
            updateStatus(targetDiv, html, 'error', true);
            return;
        }

        const html = `
            <div style="border-left: 5px solid ${precisionData.color}; padding: 15px; background: #fff; border-radius: 8px; margin: 15px 0;">
                <h4 style="color: ${precisionData.color}; margin: 0 0 10px 0;">
                    ${precisionData.emoji} ${precisionData.title}
                </h4>
                
                <div style="background: #f8f9fa; padding: 12px; border-radius: 6px; margin-bottom: 12px;">
                    <strong>üìç Indirizzo:</strong> ${precisionData.address}
                </div>
                
                <div style="background: ${precisionData.color}22; padding: 12px; border-radius: 6px; margin-bottom: 12px;">
                    <strong>Affidabilit√†: ${precisionData.score}/100</strong>
                    <div style="width: 100%; height: 12px; background: #e0e0e0; border-radius: 6px; margin: 8px 0; overflow: hidden;">
                        <div style="width: ${precisionData.score}%; height: 100%; background: ${precisionData.color}; transition: width 0.5s;"></div>
                    </div>
                    <p style="margin: 8px 0 0 0; font-size: 0.95em;">
                        ${precisionData.message}
                    </p>
                </div>
                
                ${!precisionData.reliable ? `
                    <div style="background: #fff3cd; border: 2px solid #ffc107; padding: 12px; border-radius: 8px;">
                        <strong style="color: #856404;">‚ö†Ô∏è Attenzione:</strong>
                        <p style="margin: 8px 0 0 0; color: #856404; font-size: 0.9em;">
                            Questo civico NON √® mappato esattamente. Google ha "indovinato" la posizione.
                            Il calcolo dell'orientamento potrebbe essere meno affidabile.
                        </p>
                    </div>
                ` : `
                    <div style="background: #d4edda; border: 2px solid #28a745; padding: 12px; border-radius: 8px;">
                        <strong style="color: #155724;">‚úÖ Ottimo:</strong>
                        <p style="margin: 8px 0 0 0; color: #155724; font-size: 0.9em;">
                            Questo civico √® mappato con precisione. Il calcolo sar√† affidabile.
                        </p>
                    </div>
                `}
                
                <details style="margin-top: 12px;">
                    <summary style="cursor: pointer; color: #666; font-size: 0.9em;">üìä Dettagli Tecnici</summary>
                    <div style="margin-top: 10px; padding: 10px; background: #f0f0f0; border-radius: 6px; font-size: 0.85em; font-family: monospace;">
                        <p>Tipo: ${precisionData.type}</p>
                        <p>Lat: ${precisionData.location.lat().toFixed(7)}</p>
                        <p>Lng: ${precisionData.location.lng().toFixed(7)}</p>
                    </div>
                </details>
            </div>
        `;
        
        updateStatus(targetDiv, html, precisionData.reliable ? 'success' : 'info', true);
        announceToScreenReader(`Precisione indirizzo: ${precisionData.title}. Affidabilit√† ${precisionData.score} su 100.`);
    }

    /**
     * Confronta due indirizzi e verifica se sono affidabili per calcoli geometrici
     */
    async function compareTwoAddresses(addressA, addressB, resultDiv) {
        updateStatus(resultDiv, 'üîÑ Analisi precisione indirizzi in corso...', 'info');
        announceToScreenReader('Analisi precisione indirizzi avviata');
        
        // Geocoding con check precisione
        const [precisionA, precisionB] = await Promise.all([
            checkGeocodingPrecision(addressA),
            checkGeocodingPrecision(addressB)
        ]);
        
        if (!precisionA.found || !precisionB.found) {
            const html = `
                <div style="border-left: 5px solid #dc3545; padding: 15px; background: #fff; border-radius: 8px;">
                    <h4 style="color: #dc3545;">‚ùå Errore Geocodifica</h4>
                    <p>${!precisionA.found ? `Impossibile trovare: ${addressA}` : ''}</p>
                    <p>${!precisionB.found ? `Impossibile trovare: ${addressB}` : ''}</p>
                </div>
            `;
            updateStatus(resultDiv, html, 'error', true);
            return;
        }
        
        // Verifica che siano sulla stessa via
        const streetA = extractStreetName(addressA);
        const streetB = extractStreetName(addressB);
        
        if (streetA !== streetB) {
            const html = `
                <div style="border-left: 5px solid #dc3545; padding: 15px; background: #fff; border-radius: 8px;">
                    <h4 style="color: #dc3545;">‚ùå Vie Diverse</h4>
                    <p>Gli indirizzi sono su vie diverse:</p>
                    <ul>
                        <li><strong>A:</strong> ${precisionA.address}</li>
                        <li><strong>B:</strong> ${precisionB.address}</li>
                    </ul>
                    <p style="margin-top: 10px; color: #666;">
                        Il confronto geometrico funziona solo per indirizzi sulla stessa via.
                    </p>
                </div>
            `;
            updateStatus(resultDiv, html, 'error', true);
            return;
        }
        
        // Calcola affidabilit√† complessiva
        const minScore = Math.min(precisionA.score, precisionB.score);
        const avgScore = (precisionA.score + precisionB.score) / 2;
        const bothReliable = precisionA.reliable && precisionB.reliable;
        
        // ================================================================
        // CALCOLO GEOMETRICO (Prodotto Vettoriale)
        // ================================================================
        
        let geometricResult = null;
        let osmData = null;
        
        // Tenta di ottenere geometria strada da OSM
        if (minScore >= 20) { // Solo se ha un minimo di senso
            osmData = await getStreetGeometryFromOSM(precisionA.location, streetA);
            
            if (osmData.success) {
                // Trova segmento rilevante
                const segment = getRelevantStreetSegment(
                    osmData.geometry,
                    precisionA.location,
                    precisionB.location
                );
                
                if (segment) {
                    // Calcola prodotto vettoriale
                    geometricResult = sameSideOfStreet(
                        precisionA.location,
                        precisionB.location,
                        segment
                    );
                    
                    debugLog('‚úÖ Calcolo geometrico completato:', geometricResult);
                } else {
                    console.warn('‚ö†Ô∏è Impossibile determinare segmento rilevante');
                }
            } else {
                console.warn('‚ö†Ô∏è Geometria strada non disponibile da OSM');
            }
        }
        
        // ================================================================
        // VALIDAZIONE STREET VIEW (Fase 3)
        // ================================================================
        
        let streetViewResult = null;
        
        updateStatus(resultDiv, 'üëÅÔ∏è Verifica con Street View...', 'info');
        
        try {
            streetViewResult = await checkWithStreetView(precisionA.location, precisionB.location);
            
            if (streetViewResult.available) {
                debugLog('‚úÖ Validazione Street View completata:', streetViewResult);
            } else {
                console.warn('‚ö†Ô∏è Street View non disponibile:', streetViewResult.reason);
            }
        } catch (e) {
            console.error('‚ùå Errore validazione Street View:', e);
        }
        
        // ================================================================
        // CONFRONTO METODI (Fase 3)
        // ================================================================
        
        let methodComparison = null;
        
        if (geometricResult && streetViewResult) {
            methodComparison = compareAllMethods(geometricResult, streetViewResult);
            debugLog('üìä Confronto metodi:', methodComparison);
        }
        
        // ================================================================
        // CONFIDENCE SCORE COMBINATO (Fase 3)
        // ================================================================
        
        const combinedConfidence = calculateCombinedConfidence(
            avgScore,
            geometricResult,
            streetViewResult,
            null // compass non usato qui
        );
        
        debugLog('üéØ Confidence combinato:', combinedConfidence);
        
        // ================================================================
        // SISTEMA A SEMAFORO FINALE (Gemini Style + Fase 3)
        // ================================================================
        
        let finalStatus, finalColor, finalEmoji, finalTitle, finalMessage;
        let geometricMessage = '';
        let validationMessage = '';
        
        if (geometricResult && geometricResult.sameSide !== null) {
            // ABBIAMO IL CALCOLO GEOMETRICO!
            
            if (geometricResult.reason === 'ON_LINE') {
                // üî¥ ROSSO: Punto sulla linea
                finalStatus = 'error';
                finalColor = '#dc3545';
                finalEmoji = 'üî¥';
                finalTitle = 'Calcolo Geometrico IMPOSSIBILE';
                finalMessage = `${geometricResult.message}<br><br>
                    <strong>Causa probabile:</strong> Uno o entrambi i civici sono interpolati male e Google li ha piazzati
                    esattamente sulla linea centrale della strada.<br>
                    <strong>Affidabilit√† Geocoding:</strong> A=${precisionA.score}/100, B=${precisionB.score}/100`;
                
                geometricMessage = `
                    <div style="background: #ffebee; border: 2px solid #dc3545; padding: 15px; border-radius: 8px; margin-top: 15px;">
                        <strong style="color: #c62828;">‚ùå CALCOLO GEOMETRICO FALLITO</strong>
                        <p style="margin: 8px 0 0 0; color: #666;">
                            I punti sono troppo vicini alla linea della strada. Impossibile determinare il lato.
                        </p>
                        <div style="margin-top: 10px; padding: 10px; background: white; border-radius: 6px; font-size: 0.85em; font-family: monospace;">
                            <p>Cross Product A: ${geometricResult.crossA?.toFixed(8)}</p>
                            <p>Cross Product B: ${geometricResult.crossB?.toFixed(8)}</p>
                            <p>Lato A: ${geometricResult.sideA}</p>
                            <p>Lato B: ${geometricResult.sideB}</p>
                        </div>
                    </div>
                `;
                
            } else if (bothReliable && geometricResult.confidence === 'ALTA') {
                // üü¢ VERDE: Tutto perfetto
                
                // Controlla se abbiamo anche validazione Street View
                let enhancedTitle = geometricResult.sameSide ? 
                    '‚úÖ STESSO LATO' : 
                    '‚úÖ LATI OPPOSTI';
                
                if (methodComparison && methodComparison.agreement === 'FULL') {
                    enhancedTitle += ' (Certezza Multi-Metodo ‚úÖ)';
                    finalStatus = 'success';
                    finalColor = '#28a745';
                } else if (methodComparison && methodComparison.agreement === 'CONFLICT') {
                    enhancedTitle = '‚ö†Ô∏è DISCORDANZA tra Metodi';
                    finalStatus = 'warning';
                    finalColor = '#ff9800';
                } else {
                    enhancedTitle += ' (Certezza Matematica)';
                    finalStatus = 'success';
                    finalColor = '#28a745';
                }
                
                finalEmoji = finalStatus === 'success' ? 'üü¢' : '‚ö†Ô∏è';
                finalTitle = enhancedTitle;
                
                finalMessage = `${geometricResult.message}<br><br>
                    <strong>Metodo:</strong> Prodotto Vettoriale (Cross Product)<br>
                    <strong>Affidabilit√† Geocoding:</strong> Entrambi ROOFTOP (100/100)<br>
                    <strong>Confidenza Calcolo:</strong> ${geometricResult.confidence}<br>
                    <strong>Score Combinato:</strong> ${combinedConfidence.score}/100 (${combinedConfidence.methodsCount} metodi)`;
                
                // Messaggio validazione incrociata
                if (methodComparison) {
                    if (methodComparison.agreement === 'FULL') {
                        validationMessage = `
                            <div style="background: #d4edda; border: 2px solid #28a745; padding: 15px; border-radius: 8px; margin-top: 15px;">
                                <strong style="color: #155724; font-size: 1.1em;">‚úÖ VALIDAZIONE INCROCIATA RIUSCITA</strong>
                                <p style="margin: 10px 0 0 0; color: #155724;">
                                    <strong>Geometrico e Street View CONCORDANO!</strong><br>
                                    Entrambi i metodi confermano: <strong>${methodComparison.result}</strong>
                                </p>
                                <div style="margin-top: 10px; padding: 10px; background: white; border-radius: 6px; font-size: 0.9em;">
                                    <p style="margin: 0;">üìê Calcolo Geometrico: <strong>${geometricResult.sameSide ? 'STESSO LATO' : 'LATI OPPOSTI'}</strong></p>
                                    <p style="margin: 5px 0 0 0;">üëÅÔ∏è Street View: <strong>${streetViewResult.sameSide ? 'STESSO LATO' : 'LATI OPPOSTI'}</strong></p>
                                </div>
                                <p style="margin: 10px 0 0 0; font-size: 0.9em; color: #666;">
                                    Differenza angoli Street View: ${streetViewResult.angleDifference.toFixed(1)}¬∞
                                    (Confidenza: ${streetViewResult.confidence})
                                </p>
                            </div>
                        `;
                    } else if (methodComparison.agreement === 'CONFLICT') {
                        validationMessage = `
                            <div style="background: #fff3cd; border: 2px solid #ff9800; padding: 15px; border-radius: 8px; margin-top: 15px;">
                                <strong style="color: #856404; font-size: 1.1em;">‚ö†Ô∏è DISCORDANZA TRA METODI</strong>
                                <p style="margin: 10px 0; color: #856404;">
                                    I due metodi danno risultati OPPOSTI. Questo pu√≤ indicare:
                                </p>
                                <ul style="margin: 5px 0; padding-left: 20px; color: #856404; font-size: 0.9em;">
                                    <li>Civici interpolati male da Google</li>
                                    <li>Strada con geometria complessa (curve, biforcazioni)</li>
                                    <li>Punti Street View non ottimali</li>
                                </ul>
                                <div style="margin-top: 10px; padding: 10px; background: white; border-radius: 6px; font-size: 0.9em;">
                                    <p style="margin: 0;">üìê Calcolo Geometrico: <strong>${methodComparison.geometricSays}</strong></p>
                                    <p style="margin: 5px 0 0 0;">üëÅÔ∏è Street View: <strong>${methodComparison.streetViewSays}</strong></p>
                                </div>
                                <p style="margin: 10px 0 0 0; font-size: 0.85em; color: #666;">
                                    üí° Verifica manualmente con Street View interattivo
                                </p>
                            </div>
                        `;
                    }
                } else if (streetViewResult && streetViewResult.available) {
                    validationMessage = `
                        <div style="background: #e3f2fd; border: 2px solid #2196f3; padding: 15px; border-radius: 8px; margin-top: 15px;">
                            <strong style="color: #1565c0;">üëÅÔ∏è Street View Disponibile</strong>
                            <p style="margin: 8px 0 0 0; color: #666; font-size: 0.9em;">
                                Street View: ${streetViewResult.sameSide ? 'STESSO LATO' : 'LATI OPPOSTI'}
                                (Differenza angoli: ${streetViewResult.angleDifference.toFixed(1)}¬∞, Confidenza: ${streetViewResult.confidence})
                            </p>
                        </div>
                    `;
                }
                
                geometricMessage = `
                    <div style="background: #e8f5e9; border: 2px solid #28a745; padding: 15px; border-radius: 8px; margin-top: 15px;">
                        <strong style="color: #2e7d32; font-size: 1.1em;">üìê CALCOLO GEOMETRICO RIUSCITO</strong>
                        <div style="margin-top: 10px; padding: 12px; background: white; border-radius: 6px;">
                            <p style="margin: 0 0 8px 0; font-size: 1.05em;"><strong>Risultato:</strong></p>
                            <p style="margin: 0; font-size: 1.2em; color: #2e7d32;">
                                ${geometricResult.sameSide ? 
                                    '‚úÖ Gli indirizzi sono sullo STESSO marciapiede' : 
                                    '‚ö†Ô∏è Gli indirizzi sono su marciapiedi OPPOSTI'}
                            </p>
                        </div>
                        <div style="margin-top: 10px; padding: 10px; background: #f5f5f5; border-radius: 6px; font-size: 0.9em;">
                            <p style="margin: 0 0 5px 0;"><strong>Dettagli:</strong></p>
                            <p style="margin: 0;">‚Ä¢ Indirizzo A: Lato <strong>${geometricResult.sideA}</strong></p>
                            <p style="margin: 0;">‚Ä¢ Indirizzo B: Lato <strong>${geometricResult.sideB}</strong></p>
                            <p style="margin: 5px 0 0 0; color: #666; font-size: 0.85em;">
                                (Sinistra/Destra rispetto al senso di percorrenza della strada)
                            </p>
                        </div>
                        <details style="margin-top: 10px;">
                            <summary style="cursor: pointer; color: #666; font-size: 0.85em;">üî¨ Dati Matematici</summary>
                            <div style="margin-top: 8px; padding: 8px; background: white; border-radius: 4px; font-size: 0.8em; font-family: monospace;">
                                <p>Cross Product A: ${geometricResult.crossA.toFixed(8)}</p>
                                <p>Cross Product B: ${geometricResult.crossB.toFixed(8)}</p>
                                <p>Geometria OSM: ${osmData.geometry.length} nodi</p>
                                <p>Strada: ${osmData.name}</p>
                                <p>OSM ID: ${osmData.osmId}</p>
                            </div>
                        </details>
                    </div>
                `;
                
            } else {
                // üü° GIALLO: Calcolo fatto ma affidabilit√† ridotta
                finalStatus = 'warning';
                finalColor = '#ffc107';
                finalEmoji = 'üü°';
                finalTitle = geometricResult.sameSide ? 
                    'PROBABILE Stesso Lato (Calcolo Geometrico)' : 
                    'PROBABILE Lati Opposti (Calcolo Geometrico)';
                finalMessage = `${geometricResult.message}<br><br>
                    <strong>‚ö†Ô∏è Attenzione:</strong> Almeno uno dei civici √® interpolato.<br>
                    <strong>Affidabilit√† Geocoding:</strong> Min=${minScore}/100, Media=${avgScore.toFixed(0)}/100<br>
                    <strong>Confidenza Calcolo:</strong> ${geometricResult.confidence}`;
                
                geometricMessage = `
                    <div style="background: #fff3cd; border: 2px solid #ffc107; padding: 15px; border-radius: 8px; margin-top: 15px;">
                        <strong style="color: #856404; font-size: 1.1em;">üìê CALCOLO GEOMETRICO (Affidabilit√† Ridotta)</strong>
                        <div style="margin-top: 10px; padding: 12px; background: white; border-radius: 6px;">
                            <p style="margin: 0 0 8px 0;"><strong>Risultato Probabile:</strong></p>
                            <p style="margin: 0; font-size: 1.1em; color: #856404;">
                                ${geometricResult.sameSide ? 
                                    'üü° Probabilmente STESSO marciapiede' : 
                                    'üü° Probabilmente marciapiedi OPPOSTI'}
                            </p>
                            <p style="margin: 10px 0 0 0; font-size: 0.9em; color: #666;">
                                ‚ö†Ô∏è Verifica con Street View o altri punti di riferimento
                            </p>
                        </div>
                        <div style="margin-top: 10px; padding: 10px; background: #f5f5f5; border-radius: 6px; font-size: 0.9em;">
                            <p style="margin: 0;">‚Ä¢ Indirizzo A: Lato <strong>${geometricResult.sideA}</strong></p>
                            <p style="margin: 0;">‚Ä¢ Indirizzo B: Lato <strong>${geometricResult.sideB}</strong></p>
                        </div>
                    </div>
                `;
            }
            
        } else {
            // NESSUN CALCOLO GEOMETRICO (solo precisione geocoding)
            
            if (bothReliable) {
                finalStatus = 'success';
                finalColor = '#28a745';
                finalEmoji = 'üü¢';
                finalTitle = 'Dati Affidabili (ma Geometria Strada Non Disponibile)';
                finalMessage = `Entrambi i civici sono mappati con precisione.<br>
                    <strong>‚ö†Ô∏è Nota:</strong> Non √® stato possibile ottenere la geometria della strada da OpenStreetMap.
                    Impossibile determinare se sono sullo stesso lato.`;
                    
                geometricMessage = `
                    <div style="background: #e3f2fd; border: 2px solid #2196f3; padding: 15px; border-radius: 8px; margin-top: 15px;">
                        <strong style="color: #1565c0;">‚ÑπÔ∏è Geometria Strada Non Disponibile</strong>
                        <p style="margin: 8px 0 0 0; color: #666; font-size: 0.9em;">
                            ${osmData ? osmData.error : 'Non √® stato possibile recuperare i dati della strada da OpenStreetMap.'}
                            <br><br>
                            Il calcolo geometrico non √® disponibile per questa via.
                        </p>
                    </div>
                `;
                
            } else if (minScore >= 40) {
                finalStatus = 'warning';
                finalColor = '#ffc107';
                finalEmoji = 'üü°';
                finalTitle = 'Dati Parzialmente Affidabili';
                finalMessage = 'Almeno uno dei civici √® stimato (non esatto). Calcolo geometrico non disponibile o inaffidabile.';
            } else {
                finalStatus = 'error';
                finalColor = '#dc3545';
                finalEmoji = 'üî¥';
                finalTitle = 'Dati NON Affidabili';
                finalMessage = 'Uno o entrambi i civici sono molto imprecisi. Calcolo geometrico sconsigliato.';
            }
        }
        
        const html = `
            <div style="border-left: 5px solid ${finalColor}; padding: 20px; background: #fff; border-radius: 8px;">
                <h3 style="color: ${finalColor}; margin: 0 0 15px 0;">
                    ${finalEmoji} ${finalTitle}
                </h3>
                
                <!-- Riepilogo Indirizzi -->
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 20px;">
                    <div style="background: #f8f9fa; padding: 12px; border-radius: 8px; border-left: 4px solid ${precisionA.color};">
                        <strong style="color: ${precisionA.color};">üìç Indirizzo A</strong>
                        <p style="margin: 8px 0 0 0; font-size: 0.9em;">${precisionA.address}</p>
                        <div style="margin-top: 8px; padding: 6px; background: ${precisionA.color}22; border-radius: 4px; font-size: 0.85em;">
                            ${precisionA.emoji} ${precisionA.title}<br>
                            <strong>Score: ${precisionA.score}/100</strong>
                        </div>
                    </div>
                    
                    <div style="background: #f8f9fa; padding: 12px; border-radius: 8px; border-left: 4px solid ${precisionB.color};">
                        <strong style="color: ${precisionB.color};">üìç Indirizzo B</strong>
                        <p style="margin: 8px 0 0 0; font-size: 0.9em;">${precisionB.address}</p>
                        <div style="margin-top: 8px; padding: 6px; background: ${precisionB.color}22; border-radius: 4px; font-size: 0.85em;">
                            ${precisionB.emoji} ${precisionB.title}<br>
                            <strong>Score: ${precisionB.score}/100</strong>
                        </div>
                    </div>
                </div>
                
                <!-- Affidabilit√† Complessiva -->
                <div style="background: ${finalColor}22; padding: 15px; border-radius: 8px; border-left: 4px solid ${finalColor}; margin-bottom: 15px;">
                    <strong style="font-size: 1.1em;">Affidabilit√† Complessiva: ${avgScore.toFixed(0)}/100</strong>
                    <div style="width: 100%; height: 20px; background: #e0e0e0; border-radius: 10px; margin: 10px 0; overflow: hidden;">
                        <div style="width: ${avgScore}%; height: 100%; background: ${finalColor}; transition: width 0.5s;"></div>
                    </div>
                    <p style="margin: 8px 0 0 0;">${finalMessage}</p>
                </div>
                
                <!-- Dettagli Tecnici -->
                <details style="margin-top: 15px;">
                    <summary style="cursor: pointer; color: #666; font-size: 0.9em;">üìä Dettagli Analisi</summary>
                    <div style="margin-top: 10px; padding: 12px; background: #f0f0f0; border-radius: 6px; font-size: 0.9em;">
                        <p><strong>Score Minimo:</strong> ${minScore}/100 (Il pi√π basso dei due determina l'affidabilit√†)</p>
                        <p><strong>Score Medio:</strong> ${avgScore.toFixed(0)}/100</p>
                        <p><strong>Via Comune:</strong> ${streetA}</p>
                        <p><strong>Distanza tra i punti:</strong> ${google.maps.geometry.spherical.computeDistanceBetween(precisionA.location, precisionB.location).toFixed(1)}m</p>
                        <hr style="margin: 10px 0;">
                        <p><strong>Indirizzo A:</strong></p>
                        <ul style="margin: 5px 0; padding-left: 20px; font-size: 0.85em;">
                            <li>Tipo: ${precisionA.type}</li>
                            <li>${precisionA.message}</li>
                        </ul>
                        <p><strong>Indirizzo B:</strong></p>
                        <ul style="margin: 5px 0; padding-left: 20px; font-size: 0.85em;">
                            <li>Tipo: ${precisionB.type}</li>
                            <li>${precisionB.message}</li>
                        </ul>
                    </div>
                </details>
                
                ${geometricMessage}
                ${validationMessage}
                
                ${!bothReliable ? `
                    <div style="background: #fff3cd; border: 2px solid #ff9800; padding: 12px; border-radius: 8px; margin-top: 15px;">
                        <strong style="color: #856404;">üí° Suggerimento:</strong>
                        <p style="margin: 8px 0 0 0; color: #856404; font-size: 0.9em;">
                            Per migliorare l'affidabilit√†:
                        </p>
                        <ul style="margin: 8px 0 0 0; padding-left: 20px; color: #856404; font-size: 0.9em;">
                            <li>Usa indirizzi con civici esatti e ben mappati</li>
                            <li>Verifica che il civico esista davvero nella realt√†</li>
                            <li>Preferisci edifici noti (negozi, chiese, monumenti)</li>
                        </ul>
                    </div>
                ` : ''}
            </div>
        `;
        
        updateStatus(resultDiv, html, finalStatus, true);
        announceToScreenReader(`Analisi completata. Affidabilit√† complessiva: ${avgScore.toFixed(0)} su 100. ${finalTitle}`);
    }

    // ================================================================
    // FINE SISTEMA CHECK PRECISIONE
    // ================================================================

    // ================================================================
    // SISTEMA GEOMETRIA STRADA E PRODOTTO VETTORIALE (Fase 2)
    // Determina se due punti sono sullo stesso lato della strada
    // ================================================================

    /**
     * Ottiene la geometria (linea centrale) di una strada da OpenStreetMap
     * Usa Overpass API (GRATIS!)
     */
    async function getStreetGeometryFromOSM(coords, streetName) {
        console.log('üîç Ricerca geometria per:', streetName);
        
        // Pulisci e crea varianti del nome strada
        const variants = generateStreetNameVariants(streetName);
        console.log('üìù Varianti nome:', variants);
        
        // TENTATIVO 1: Ricerca con nome strada (raggio 200m)
        let osmData = await searchStreetByName(coords, variants, 200);
        
        if (osmData.success) {
            console.log('‚úÖ Trovata con ricerca per nome');
            return osmData;
        }
        
        // TENTATIVO 2: Ricerca solo per coordinate vicine (raggio 50m - molto conservativo)
        console.log('‚ö†Ô∏è Nome non trovato, provo ricerca per coordinate (50m)...');
        osmData = await searchStreetByProximity(coords, 50);
        
        if (osmData.success) {
            // Verifica che il nome corrisponda almeno parzialmente
            const foundName = osmData.name.toLowerCase();
            const originalName = streetName.toLowerCase();
            
            // Estrai la parte significativa (senza "via", "viale", ecc.)
            const foundCore = foundName.replace(/^(via|viale|piazza|corso|largo|strada|vicolo|v\.|vle|cso|pza)\s+/i, '').trim();
            const originalCore = originalName.replace(/^(via|viale|piazza|corso|largo|strada|vicolo|v\.|vle|cso|pza)\s+/i, '').trim();
            
            // Verifica che ci sia almeno una corrispondenza parziale
            if (foundCore.includes(originalCore.split(' ')[0]) || originalCore.includes(foundCore.split(' ')[0])) {
                console.log('‚úÖ Trovata per coordinate e nome verificato:', osmData.name);
                return osmData;
            } else {
                console.warn('‚ö†Ô∏è Strada trovata ma nome non corrisponde:', osmData.name, 'vs', streetName);
            }
        }
        
        console.warn('‚ùå Nessuna geometria trovata');
        return { success: false, error: 'Strada non trovata in OpenStreetMap. Prova con un indirizzo pi√π preciso o verifica il nome della via.' };
    }
    
    // Genera varianti del nome strada per migliorare la ricerca
    function generateStreetNameVariants(streetName) {
        const variants = new Set();
        const original = streetName.trim();
        variants.add(original);
        
        // Rimuovi prefissi comuni
        const withoutPrefix = original.replace(/^(via|viale|piazza|corso|largo|strada|vicolo|v\.|vle|cso|pza)\s+/i, '').trim();
        variants.add(withoutPrefix);
        
        // Aggiungi varianti con prefissi comuni
        ['Via', 'Viale', 'Corso', 'Piazza'].forEach(prefix => {
            variants.add(`${prefix} ${withoutPrefix}`);
        });
        
        // Gestisci "di" e "del"
        if (withoutPrefix.includes(' di ') || withoutPrefix.includes(' del ')) {
            variants.add(withoutPrefix.replace(' di ', ' '));
            variants.add(withoutPrefix.replace(' del ', ' '));
        }
        
        // Rimuovi duplicati e restituisci array
        return Array.from(variants).filter(v => v.length > 0);
    }
    
    // Ricerca strada per nome con varianti
    async function searchStreetByName(coords, nameVariants, radius) {
        // Costruisci query con tutte le varianti
        const nameConditions = nameVariants.map(name => {
            const escaped = name.replace(/[\\"]/g, '\\$&');
            return `way["highway"]["name"~"${escaped}",i](around:${radius},${coords.lat},${coords.lng});`;
        }).join('\n');
        
        const query = `
            [out:json][timeout:15];
            (
              ${nameConditions}
            );
            out geom;
        `;
        
        return await executeOverpassQuery(query, coords, nameVariants[0]);
    }
    
    // Ricerca strada solo per coordinate (fallback conservativo)
    async function searchStreetByProximity(coords, radius) {
        const query = `
            [out:json][timeout:15];
            (
              way["highway"]["name"](around:${radius},${coords.lat},${coords.lng});
            );
            out geom;
        `;
        
        return await executeOverpassQuery(query, coords, null);
    }
    
    // Esegui query Overpass
    async function executeOverpassQuery(query, coords, expectedName) {
        const url = `https://overpass-api.de/api/interpreter?data=${encodeURIComponent(query)}`;
        
        try {
            updateStatus(document.getElementById('orientation-status'), 'üó∫Ô∏è Recupero geometria strada da OpenStreetMap...', 'info');
            
            const response = await fetch(url);
            
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}`);
            }
            
            const data = await response.json();
            
            if (data.elements && data.elements.length > 0) {
                // Trova la strada pi√π vicina al punto
                let closestStreet = null;
                let minDistance = Infinity;
                
                for (const element of data.elements) {
                    if (element.geometry && element.geometry.length >= 2) {
                        // Calcola distanza media dai nodi
                        const avgDist = element.geometry.reduce((sum, node) => {
                            const nodeLoc = new google.maps.LatLng(node.lat, node.lon);
                            return sum + google.maps.geometry.spherical.computeDistanceBetween(coords, nodeLoc);
                        }, 0) / element.geometry.length;
                        
                        if (avgDist < minDistance) {
                            minDistance = avgDist;
                            closestStreet = element;
                        }
                    }
                }
                
                if (closestStreet) {
                    const foundName = closestStreet.tags?.name || 'Sconosciuta';
                    console.log(`‚úÖ Geometria strada trovata: ${foundName} (${closestStreet.geometry.length} nodi, distanza: ${minDistance.toFixed(1)}m)`);
                    
                    return {
                        success: true,
                        geometry: closestStreet.geometry.map(node => ({
                            lat: node.lat,
                            lng: node.lon
                        })),
                        name: foundName,
                        osmId: closestStreet.id,
                        distance: minDistance
                    };
                }
            }
            
            console.warn('‚ö†Ô∏è Nessuna geometria strada trovata in OSM');
            return { success: false, error: 'Strada non trovata' };
            
        } catch (e) {
            console.error('‚ùå Errore chiamata OSM:', e);
            return { success: false, error: `Errore OSM: ${e.message}` };
        }
    }

    /**
     * Trova il segmento di strada pi√π rilevante per due punti
     */
    function getRelevantStreetSegment(streetGeometry, pointA, pointB) {
        if (!streetGeometry || streetGeometry.length < 2) {
            return null;
        }
        
        // Trova il segmento pi√π vicino ai punti
        let closestSegmentStart = null;
        let closestSegmentEnd = null;
        let minDistance = Infinity;
        
        for (let i = 0; i < streetGeometry.length - 1; i++) {
            const segStart = new google.maps.LatLng(streetGeometry[i].lat, streetGeometry[i].lng);
            const segEnd = new google.maps.LatLng(streetGeometry[i + 1].lat, streetGeometry[i + 1].lng);
            
            // Distanza media dei due punti da questo segmento
            const distA = distanceToLineSegment(pointA, segStart, segEnd);
            const distB = distanceToLineSegment(pointB, segStart, segEnd);
            const avgDist = (distA + distB) / 2;
            
            if (avgDist < minDistance) {
                minDistance = avgDist;
                closestSegmentStart = segStart;
                closestSegmentEnd = segEnd;
            }
        }
        
        return [closestSegmentStart, closestSegmentEnd];
    }

    /**
     * Calcola la distanza punto-segmento
     */
    function distanceToLineSegment(point, lineStart, lineEnd) {
        const x0 = point.lng();
        const y0 = point.lat();
        const x1 = lineStart.lng();
        const y1 = lineStart.lat();
        const x2 = lineEnd.lng();
        const y2 = lineEnd.lat();
        
        const A = x0 - x1;
        const B = y0 - y1;
        const C = x2 - x1;
        const D = y2 - y1;
        
        const dot = A * C + B * D;
        const len_sq = C * C + D * D;
        let param = -1;
        
        if (len_sq !== 0) param = dot / len_sq;
        
        let xx, yy;
        
        if (param < 0) {
            xx = x1;
            yy = y1;
        } else if (param > 1) {
            xx = x2;
            yy = y2;
        } else {
            xx = x1 + param * C;
            yy = y1 + param * D;
        }
        
        const dx = x0 - xx;
        const dy = y0 - yy;
        
        // Converti da gradi a metri (approssimazione)
        const metersPerDegree = 111320;
        return Math.sqrt(dx * dx + dy * dy) * metersPerDegree;
    }

    /**
     * PRODOTTO VETTORIALE (Cross Product)
     * Determina se due punti sono sullo stesso lato di una linea
     */
    function sameSideOfStreet(pointA, pointB, streetSegment) {
        if (!streetSegment || streetSegment.length < 2) {
            return {
                sameSide: null,
                reason: 'NO_SEGMENT',
                message: 'Segmento strada non valido'
            };
        }
        
        const lineStart = streetSegment[0];
        const lineEnd = streetSegment[1];
        
        // Vettore della linea stradale
        const lineVector = {
            x: lineEnd.lng() - lineStart.lng(),
            y: lineEnd.lat() - lineStart.lat()
        };
        
        // Vettore da inizio linea al punto A
        const vectorToA = {
            x: pointA.lng() - lineStart.lng(),
            y: pointA.lat() - lineStart.lat()
        };
        
        // Vettore da inizio linea al punto B
        const vectorToB = {
            x: pointB.lng() - lineStart.lng(),
            y: pointB.lat() - lineStart.lat()
        };
        
        // Prodotto vettoriale (cross product)
        // Se z > 0: punto a SINISTRA della linea
        // Se z < 0: punto a DESTRA della linea
        // Se z ‚âà 0: punto SULLA linea (problema!)
        
        const crossA = lineVector.x * vectorToA.y - lineVector.y * vectorToA.x;
        const crossB = lineVector.x * vectorToB.y - lineVector.y * vectorToB.x;
        
        console.log(`üìê Cross Product A: ${crossA.toFixed(8)}`);
        console.log(`üìê Cross Product B: ${crossB.toFixed(8)}`);
        
        // Tolleranza per punti quasi sulla linea
        const tolerance = 0.000001;
        
        if (Math.abs(crossA) < tolerance || Math.abs(crossB) < tolerance) {
            return {
                sameSide: null,
                reason: 'ON_LINE',
                message: 'Uno o entrambi i punti sono troppo vicini alla linea della strada (probabile civico interpolato)',
                crossA: crossA,
                crossB: crossB,
                sideA: 'SULLA LINEA',
                sideB: 'SULLA LINEA'
            };
        }
        
        // Stesso segno = stesso lato
        const sameSide = (crossA > 0 && crossB > 0) || (crossA < 0 && crossB < 0);
        
        const sideA = crossA > 0 ? 'SINISTRA' : 'DESTRA';
        const sideB = crossB > 0 ? 'SINISTRA' : 'DESTRA';
        
        return {
            sameSide: sameSide,
            reason: 'CALCULATED',
            message: sameSide ? 
                'I punti sono sullo STESSO lato della strada' : 
                'I punti sono su lati OPPOSTI della strada',
            sideA: sideA,
            sideB: sideB,
            crossA: crossA,
            crossB: crossB,
            confidence: Math.abs(crossA) > 0.00001 && Math.abs(crossB) > 0.00001 ? 'ALTA' : 'MEDIA'
        };
    }

    // ================================================================
    // FINE SISTEMA GEOMETRIA STRADA
    // ================================================================

    // ================================================================
    // SISTEMA VALIDAZIONE INCROCIATA (Fase 3)
    // Confronta Geometrico vs Street View vs Bussola
    // ================================================================

    /**
     * Verifica con Street View se due indirizzi sono sullo stesso lato
     * Usa la prospettiva visiva per confrontare con il calcolo geometrico
     */
    async function checkWithStreetView(locationA, locationB) {
        try {
            // Trova Street View per entrambi i punti
            const svDataA = await findStreetViewPromise(locationA, 50);
            const svDataB = await findStreetViewPromise(locationB, 50);
            
            if (!svDataA || !svDataB) {
                return { available: false, reason: 'Street View non disponibile' };
            }
            
            // Calcola gli heading da ogni Street View verso l'altro punto
            const headingA_to_B = google.maps.geometry.spherical.computeHeading(
                svDataA.location.latLng,
                locationB
            );
            
            const headingB_to_A = google.maps.geometry.spherical.computeHeading(
                svDataB.location.latLng,
                locationA
            );
            
            // Se i due punti si "guardano" con heading opposti (~180¬∞ di differenza),
            // sono probabilmente su lati opposti della strada
            let diff = Math.abs(headingA_to_B - headingB_to_A);
            if (diff > 180) diff = 360 - diff;
            
            // Normalizza la differenza a [0, 180]
            const normalizedDiff = diff > 180 ? 360 - diff : diff;
            
            // Se la differenza √® vicina a 180¬∞, sono su lati opposti
            // Se √® vicina a 0¬∞, sono sullo stesso lato
            const sameSide = normalizedDiff < 90; // Threshold arbitrario
            
            const confidence = normalizedDiff < 30 || normalizedDiff > 150 ? 'ALTA' : 'MEDIA';
            
            return {
                available: true,
                sameSide: sameSide,
                headingA_to_B: headingA_to_B,
                headingB_to_A: headingB_to_A,
                angleDifference: normalizedDiff,
                confidence: confidence,
                method: 'Street View Perspective'
            };
            
        } catch (e) {
            console.warn('Street View check failed:', e);
            return { available: false, reason: e.message };
        }
    }

    /**
     * Validazione con bussola del dispositivo
     * Richiede permessi sensore orientamento
     */
    async function validateWithDeviceCompass(calculatedHeading) {
        // Controlla supporto
        if (!window.DeviceOrientationEvent) {
            return { available: false, reason: 'DeviceOrientation non supportato' };
        }
        
        // Richiedi permessi se necessario (iOS 13+)
        if (typeof DeviceOrientationEvent.requestPermission === 'function') {
            try {
                const permission = await DeviceOrientationEvent.requestPermission();
                if (permission !== 'granted') {
                    return { available: false, reason: 'Permesso bussola negato' };
                }
            } catch (e) {
                return { available: false, reason: 'Errore richiesta permessi: ' + e.message };
            }
        }
        
        return new Promise((resolve) => {
            let readings = [];
            let count = 0;
            const maxReadings = 10;
            const timeout = 3000; // 3 secondi
            
            const handler = (event) => {
                if (event.alpha !== null) {
                    // alpha = 0¬∞ quando il telefono punta a Nord
                    // Normalizziamo per matching con Google Maps heading
                    const compassHeading = (360 - event.alpha) % 360;
                    readings.push(compassHeading);
                    count++;
                    
                    if (count >= maxReadings) {
                        window.removeEventListener('deviceorientation', handler);
                        
                        // Calcola media
                        const avgCompass = readings.reduce((a, b) => a + b) / readings.length;
                        
                        // Confronta con il risultato calcolato
                        let diff = Math.abs(calculatedHeading - avgCompass);
                        if (diff > 180) diff = 360 - diff;
                        
                        const reliable = diff < 30; // Differenza accettabile
                        const confidence = diff < 15 ? 'ALTA' : diff < 30 ? 'MEDIA' : 'BASSA';
                        
                        resolve({
                            available: true,
                            compassHeading: avgCompass,
                            calculatedHeading: calculatedHeading,
                            difference: diff,
                            reliable: reliable,
                            confidence: confidence,
                            readings: readings
                        });
                    }
                }
            };
            
            window.addEventListener('deviceorientation', handler);
            
            // Timeout
            setTimeout(() => {
                window.removeEventListener('deviceorientation', handler);
                if (count === 0) {
                    resolve({ available: false, reason: 'Nessuna lettura bussola ricevuta' });
                }
            }, timeout);
        });
    }

    /**
     * Calcola confidence score combinato da tutti i metodi
     */
    function calculateCombinedConfidence(precisionScore, geometricResult, streetViewResult, compassResult) {
        let totalScore = 0;
        let weights = 0;
        let methods = [];
        
        // 1. Precisione Geocoding (peso 25%)
        if (precisionScore) {
            totalScore += precisionScore * 0.25;
            weights += 0.25;
            methods.push(`Geocoding: ${precisionScore}/100`);
        }
        
        // 2. Calcolo Geometrico (peso 35%)
        if (geometricResult && geometricResult.sameSide !== null) {
            const geoScore = geometricResult.confidence === 'ALTA' ? 95 : 70;
            totalScore += geoScore * 0.35;
            weights += 0.35;
            methods.push(`Geometrico: ${geoScore}/100 (${geometricResult.confidence})`);
        }
        
        // 3. Street View (peso 25%)
        if (streetViewResult && streetViewResult.available) {
            const svScore = streetViewResult.confidence === 'ALTA' ? 90 : 60;
            totalScore += svScore * 0.25;
            weights += 0.25;
            methods.push(`Street View: ${svScore}/100 (${streetViewResult.confidence})`);
        }
        
        // 4. Bussola (peso 15%)
        if (compassResult && compassResult.available) {
            const compScore = compassResult.confidence === 'ALTA' ? 95 : 
                            compassResult.confidence === 'MEDIA' ? 70 : 40;
            totalScore += compScore * 0.15;
            weights += 0.15;
            methods.push(`Bussola: ${compScore}/100 (${compassResult.confidence})`);
        }
        
        // Normalizza per i pesi effettivi
        const finalScore = weights > 0 ? (totalScore / weights) : 0;
        
        return {
            score: Math.round(finalScore),
            methods: methods,
            methodsCount: methods.length
        };
    }

    /**
     * Confronta risultati di tutti i metodi e determina concordanza
     */
    function compareAllMethods(geometricResult, streetViewResult) {
        if (!geometricResult || geometricResult.sameSide === null) {
            return { agreement: 'NO_GEOMETRIC', message: 'Calcolo geometrico non disponibile' };
        }
        
        if (!streetViewResult || !streetViewResult.available) {
            return { agreement: 'NO_STREETVIEW', message: 'Street View non disponibile' };
        }
        
        const geoSameSide = geometricResult.sameSide;
        const svSameSide = streetViewResult.sameSide;
        
        if (geoSameSide === svSameSide) {
            return {
                agreement: 'FULL',
                message: 'Geometrico e Street View CONCORDANO',
                result: geoSameSide ? 'STESSO LATO' : 'LATI OPPOSTI',
                emoji: '‚úÖ',
                color: '#28a745'
            };
        } else {
            return {
                agreement: 'CONFLICT',
                message: 'DISCORDANZA tra Geometrico e Street View',
                geometricSays: geoSameSide ? 'STESSO LATO' : 'LATI OPPOSTI',
                streetViewSays: svSameSide ? 'STESSO LATO' : 'LATI OPPOSTI',
                emoji: '‚ö†Ô∏è',
                color: '#dc3545'
            };
        }
    }

    // ================================================================
    // FINE SISTEMA VALIDAZIONE INCROCIATA
    // ================================================================

    /**
     * Rileva se la posizione √® un luogo complesso (piazza, incrocio, rotonda)
     */
    async function detectComplexLocation(coords) {
        return new Promise((resolve) => {
            geocoder.geocode({ location: coords }, (results, status) => {
                if (status === 'OK' && results?.[0]) {
                    const types = results[0].types;
                    const formattedAddress = results[0].formatted_address.toLowerCase();
                    const addressComponents = results[0].address_components;
                    
                    const isSquare = types.includes('town_square') || types.includes('plaza') ||
                                    formattedAddress.includes('piazza');
                    const isIntersection = types.includes('intersection');
                    const isRoundabout = formattedAddress.includes('rotonda') || 
                                        formattedAddress.includes('rotatoria');
                    
                    // Rileva vie molto corte (potrebbero essere problematiche)
                    const streetComponent = addressComponents.find(c => c.types.includes('route'));
                    const isShortStreet = streetComponent?.short_name?.length < 15;
                    
                    const isComplex = isSquare || isIntersection || isRoundabout;
                    let locationType = 'via';
                    
                    if (isSquare) locationType = 'piazza';
                    else if (isIntersection) locationType = 'incrocio';
                    else if (isRoundabout) locationType = 'rotonda';
                    
                    resolve({
                        isComplex: isComplex,
                        type: locationType,
                        name: results[0].formatted_address,
                        requiresMultiPoint: isSquare || isRoundabout,
                        suggestedMessage: isSquare ? 
                            'Sei in una piazza. Inserisci il numero civico esatto per migliorare la precisione.' :
                            isIntersection ?
                            'Sei in un incrocio. Specifica quale angolo (es. "Via X angolo Via Y").' :
                            isRoundabout ?
                            'Sei vicino a una rotonda. Usa un indirizzo appena fuori dalla rotonda.' :
                            null
                    });
                }
                resolve({ isComplex: false, type: 'via' });
            });
        });
    }

    /**
     * Mostra guidance dettagliata per luoghi complessi
     */
    function showComplexLocationGuidance(locationType, address) {
        const guidance = {
            'piazza': {
                icon: 'üèõÔ∏è',
                title: 'Piazza Rilevata',
                tips: [
                    'Inserisci il <strong>numero civico esatto</strong> (es. "Piazza San Carlo, 15")',
                    'Oppure specifica un punto di riferimento (es. "Piazza San Carlo angolo Via Roma")',
                    'Se possibile, usa il nome del negozio/edificio specifico'
                ],
                reliability: 'MEDIA-BASSA üü°',
                example: 'Invece di: "Piazza San Carlo"<br>Meglio: "Piazza San Carlo, 161" oppure "Caff√® Torino, Piazza San Carlo"'
            },
            'incrocio': {
                icon: 'üîÄ',
                title: 'Incrocio Rilevato',
                tips: [
                    'Specifica <strong>quale angolo</strong> dell\'incrocio',
                    'Usa la formula "Via X angolo Via Y"',
                    'Indica se sei sul lato nord/sud/est/ovest dell\'incrocio'
                ],
                reliability: 'BASSA üî¥',
                example: 'Invece di: "Via Roma 20"<br>Meglio: "Via Roma 20 angolo Corso Vittorio"'
            },
            'rotonda': {
                icon: 'üîÑ',
                title: 'Rotonda Rilevata',
                tips: [
                    'Le rotonde sono <strong>molto difficili</strong> da orientare automaticamente',
                    'Specifica l\'uscita o la via che stai prendendo',
                    'Usa un punto di riferimento vicino ma non sulla rotonda'
                ],
                reliability: 'MOLTO BASSA üî¥',
                example: 'Meglio cercare un indirizzo appena fuori dalla rotonda'
            }
        };
        
        const info = guidance[locationType];
        if (!info) return;
        
        const html = `
            <div style="border: 3px solid #ff9800; background: #fff3cd; padding: 20px; border-radius: 12px; margin: 15px 0;">
                <h3 style="color: #856404; margin: 0 0 15px 0;">${info.icon} ${info.title}</h3>
                
                <div style="background: white; padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                    <strong style="color: #dc3545;">‚ö†Ô∏è Affidabilit√† Attesa: ${info.reliability}</strong>
                    <p style="margin: 10px 0 0 0; font-size: 0.95em;">
                        L'orientamento in ${locationType === 'piazza' ? 'piazze' : locationType === 'incrocio' ? 'incroci' : 'rotonde'} 
                        √® meno preciso. Segui questi suggerimenti:
                    </p>
                </div>
                
                <ul style="margin: 0; padding-left: 20px; line-height: 1.8;">
                    ${info.tips.map(tip => `<li>${tip}</li>`).join('')}
                </ul>
                
                <div style="margin-top: 15px; padding: 12px; background: #e3f2fd; border-left: 4px solid #2196f3; border-radius: 4px;">
                    <strong>üí° Esempio pratico:</strong><br>
                    <span style="font-size: 0.9em;">${info.example}</span>
                </div>
                
                <button class="btn" onclick="document.getElementById('addressInput').focus()" 
                        style="margin-top: 15px; width: 100%;">
                    ‚úèÔ∏è Modifica Indirizzo per Maggiore Precisione
                </button>
            </div>
        `;
        
        updateStatus(document.getElementById('orientation-status'), html, 'info', true);
        announceToScreenReader(`Attenzione: ${info.title}. ${info.tips[0]}`);
    }

    // ================================================================
    // VERSIONE  ROBUSTNESS & SAFETY (Correzioni ChatGPT integrate)
    // ================================================================

    async function runCivicAnalysisCascade() {
        const orientationStatusDiv = document.getElementById('orientation-status');
        const turnInstructionStatusDiv = document.getElementById('turn-instruction-status');

        if (!currentLocation) {
            updateStatus(orientationStatusDiv, "‚ö†Ô∏è Errore: Imposta un indirizzo prima.", 'error');
            announceToScreenReader("Errore: indirizzo mancante");
            return;
        }

        updateStatus(orientationStatusDiv, "üîÑ Analisi Ibrida (Precisione + Geometria)...", 'info');
        updateStatus(turnInstructionStatusDiv, "Elaborazione dati in corso...", 'info');
        announceToScreenReader("Analisi orientamento avviata. Attendi.");
        
        buildingDirectionFromStreet = null; 

        try {
            const originPoint = new google.maps.LatLng(currentLocation.lat, currentLocation.lng);
            const inputAddress = document.getElementById('addressInput').value;
            
            // üîç RILEVAMENTO LUOGHI COMPLESSI (Piazze, Incroci, Rotonde)
            const locationInfo = await detectComplexLocation(originPoint);
            
            // üéØ CHECK PRECISIONE GEOCODING (Fase 1)
            updateStatus(orientationStatusDiv, 'üîç Verifica precisione indirizzo...', 'info');
            const precisionData = await checkGeocodingPrecision(inputAddress);
            
            if (!precisionData.found) {
                updateStatus(orientationStatusDiv, '‚ùå Impossibile verificare la precisione dell\'indirizzo', 'error');
            } else {
                // Mostra info precisione
                console.log(`üìä Precisione Geocoding: ${precisionData.type} (Score: ${precisionData.score}/100)`);
                
                // Se NON affidabile, mostra warning
                if (!precisionData.reliable) {
                    const warningHtml = `
                        <div style="background: #fff3cd; border: 2px solid #ff9800; padding: 15px; border-radius: 8px; margin: 15px 0;">
                            <h4 style="color: #856404; margin: 0 0 10px 0;">
                                ${precisionData.emoji} Precisione Indirizzo: ${precisionData.title}
                            </h4>
                            <div style="background: white; padding: 12px; border-radius: 6px; margin-bottom: 10px;">
                                <strong>Affidabilit√†: ${precisionData.score}/100</strong>
                                <div style="width: 100%; height: 12px; background: #e0e0e0; border-radius: 6px; margin: 8px 0; overflow: hidden;">
                                    <div style="width: ${precisionData.score}%; height: 100%; background: ${precisionData.color}; transition: width 0.5s;"></div>
                                </div>
                            </div>
                            <p style="margin: 0; color: #856404; font-size: 0.95em;">
                                ‚ö†Ô∏è ${precisionData.message}
                            </p>
                            <p style="margin: 10px 0 0 0; color: #856404; font-size: 0.9em;">
                                <strong>Conseguenza:</strong> Il calcolo dell'orientamento potrebbe essere meno preciso.
                                Se possibile, usa un indirizzo con civico esatto.
                            </p>
                        </div>
                    `;
                    
                    updateStatus(orientationStatusDiv, warningHtml, 'info', true);
                    announceToScreenReader(`Attenzione: ${precisionData.shortMessage}. L'orientamento potrebbe essere meno preciso.`);
                    
                    // Pausa per far leggere
                    await new Promise(resolve => setTimeout(resolve, 2000));
                } else {
                    // Se affidabile, mostra messaggio rapido positivo
                    debugLog('‚úÖ Indirizzo mappato con precisione');
                    notify('‚úÖ Indirizzo verificato con precisione', 'success');
                }
            }
            
            if (locationInfo.isComplex) {
                console.log(`‚ö†Ô∏è Luogo complesso rilevato: ${locationInfo.type} - ${locationInfo.name}`);
                announceToScreenReader(`Attenzione: ${locationInfo.type} rilevato. Calcolo con cautela.`);
                
                // Mostra warning dettagliato all'utente
                showComplexLocationGuidance(locationInfo.type, locationInfo.name);
                
                // Aggiunge messaggio informativo che proceder√† comunque
                setTimeout(() => {
                    updateStatus(orientationStatusDiv, `
                        <div style="background: #e3f2fd; border-left: 4px solid #2196f3; padding: 12px; margin: 10px 0;">
                            ‚ÑπÔ∏è Procedo comunque con l'analisi, ma <strong>verifica attentamente il risultato</strong>.<br>
                            Se possibile, inserisci un indirizzo pi√π preciso usando il pulsante sopra.
                        </div>
                    `, 'info', true);
                }, 1500);
                
                // Aspetta 3 secondi per dare tempo all'utente di leggere
                await new Promise(resolve => setTimeout(resolve, 3000));
            }
            
            // Pulizia nome via (Cruciale per evitare falsi positivi distanti)
            const cleanInputName = inputAddress.toLowerCase()
                .replace(/^(via|viale|piazza|corso|largo|strada|vicolo)\s+/i, '')
                .split(',')[0].replace(/[0-9]/g, '').trim();

            let bestData = null;
            let analysisMode = "STANDARD"; // STANDARD o GEOMETRIC

            // ---------------------------------------------------------
            // FASE 1: TENTATIVO DI PRECISIONE (Vicino, raggio stretto)
            // ---------------------------------------------------------
            try {
                // Cerchiamo entro 50 metri
                const closeData = await findStreetViewPromise(originPoint, 50);
                const dist = google.maps.geometry.spherical.computeDistanceBetween(originPoint, closeData.location.latLng);
                
                // CRITERIO DI SICUREZZA:
                // Ci fidiamo del calcolo vettoriale diretto SOLO se siamo a pi√π di 4 metri.
                // Se siamo < 4m, il GPS √® troppo sovrapposto e l'angolo impazzisce.
                if (dist >= 4.0) {
                    // Controllo nome via (se disponibile e se l'input √® valido)
                    const svDesc = (closeData.location.description || "").toLowerCase();
                    if (cleanInputName.length <= 2 || svDesc.includes(cleanInputName)) {
                         bestData = closeData;
                         analysisMode = "STANDARD";
                         console.log(`‚úÖ Fase 1 OK: Punto standard trovato a ${dist.toFixed(1)}m`);
                    } else {
                        console.warn("Fase 1: Via diversa. Ignoro.");
                    }
                } else {
                    console.warn(`‚ö†Ô∏è Fase 1: Punto troppo vicino (${dist.toFixed(2)}m). Rischio instabilit√†. Passo a Geometria.`);
                    announceToScreenReader("Punto troppo vicino. Passo a modalit√† geometrica.");
                }
            } catch (e) {
                console.log("Fase 1: Nessun punto vicino trovato.");
            }

            // ---------------------------------------------------------
            // FASE 2: TENTATIVO GEOMETRICO DISTANTE (Se Fase 1 fallita o saltata)
            // ---------------------------------------------------------
            if (!bestData) {
                updateStatus(orientationStatusDiv, "üîÑ Punto esatto ambiguo o assente. Triangolazione da distante...", 'info');
                
                // Raggi crescenti. NOTA: Arriviamo fino a 300m per cercare la prospettiva.
                const radii = [70, 150, 250, 350];
                
                for (const r of radii) {
                    try {
                        const farData = await findStreetViewPromise(originPoint, r);
                        const svLocFar = farData.location.latLng;
                        const distFar = google.maps.geometry.spherical.computeDistanceBetween(originPoint, svLocFar);

                        // üî¥ CORREZIONE CRITICA CHATGPT:
                        // Dobbiamo assicurarci che il punto trovato sia DAVVERO lontano.
                        // Se Google ci rid√† lo stesso punto a 2 metri, dobbiamo scartarlo e allargare il cerchio.
                        if (distFar < 10.0) {
                            console.warn(`Fase 2 (Raggio ${r}): Punto trovato ma √® ancora troppo vicino (${distFar.toFixed(1)}m). Scarto.`);
                            continue; // Salta al prossimo raggio
                        }

                        // Controllo TASSATIVO del nome via (non possiamo fare geometria su una via diversa)
                        const svDesc = (farData.location.description || "").toLowerCase();
                        const svShort = (farData.location.shortDescription || "").toLowerCase();
                        
                        if (cleanInputName.length > 2 && 
                            !svDesc.includes(cleanInputName) && 
                            !svShort.includes(cleanInputName)) {
                            console.log(`Fase 2: Scartato punto distante su via diversa (${svDesc})`);
                            continue;
                        }

                        // Se siamo qui: Punto Lontano (>10m) + Stessa Via = PERFETTO.
                        bestData = farData;
                        analysisMode = "GEOMETRIC";
                        console.log(`‚úÖ Fase 2 OK: Punto geometrico a ${distFar.toFixed(1)}m`);
                        break; // Trovato, fermati.
                    } catch (e) {}
                }
            }

            // ---------------------------------------------------------
            // OUTPUT FINALE
            // ---------------------------------------------------------
            if (bestData) {
                let reliability = analysisMode === "STANDARD" ? "ALTA üü¢" : "STIMATA üü°";
                const msg = analysisMode === "STANDARD" ? "‚úÖ Misurazione Diretta" : "üìê Stima Geometrica";
                
                // Abbassa affidabilit√† per luogo complesso
                if (locationInfo.isComplex) {
                    if (reliability.includes("ALTA")) {
                        reliability = "MEDIA üü°";
                    } else if (reliability.includes("STIMATA")) {
                        reliability = "BASSA üü†";
                    }
                }
                
                // Abbassa ulteriormente se geocoding impreciso
                if (precisionData.found && !precisionData.reliable) {
                    if (reliability.includes("ALTA")) {
                        reliability = "MEDIA üü°";
                    } else if (reliability.includes("MEDIA")) {
                        reliability = "BASSA üü†";
                    } else if (reliability.includes("STIMATA")) {
                        reliability = "MOLTO BASSA üî¥";
                    }
                }
                
                await processStreetViewResultCascade(
                    bestData, 
                    originPoint, 
                    inputAddress, 
                    msg, 
                    reliability, 
                    false,
                    analysisMode === "GEOMETRIC", // Flag modalit√†
                    locationInfo, // Info luogo complesso
                    precisionData // Info precisione geocoding
                );
            } else {
                // FALLIMENTO TOTALE
                 const htmlError = `
                    <div style="border-left: 5px solid #dc3545; padding: 15px; background: #fff; border-radius: 8px;">
                        <h4 style="margin:0 0 10px 0; color: #dc3545;">‚ùå Analisi Impossibile</h4>
                        <p>Non riesco a calcolare un orientamento affidabile.</p>
                        <ul style="margin-top:10px; font-size:0.9em; color:#666;">
                           <li>Il punto esatto √® troppo ambiguo o non mappato.</li>
                           <li>Non ho trovato punti di riferimento distanti sulla stessa via ("${cleanInputName}").</li>
                        </ul>
                    </div>`;
                updateStatus(orientationStatusDiv, htmlError, 'error', true);
                announceToScreenReader("Analisi fallita. Dati insufficienti.");
            }

        } catch (fatalError) {
            console.error(fatalError);
            updateStatus(orientationStatusDiv, `Errore Tecnico: ${fatalError.message}`, 'error');
            announceToScreenReader("Errore tecnico nell'analisi.");
        }
    }

    // ----------------------------------------
    // FUNZIONI HELPER SISTEMA CASCATA
    // ----------------------------------------

    /**
     * Trova Street View con Promise (invece di callback)
     */
    function findStreetViewPromise(location, radius) {
        return new Promise((resolve, reject) => {
            const svService = new google.maps.StreetViewService();
            svService.getPanorama(
                { location: location, radius: radius }, 
                (data, status) => {
                    if (status === 'OK') {
                        resolve(data);
                    } else {
                        reject(new Error(`Street View non disponibile: ${status}`));
                    }
                }
            );
        });
    }

    /**
     * Cerca indirizzi vicini usando Google Places
     */
    function fetchNearbyAddressesCascade(origin) {
        return new Promise(resolve => {
            const request = {
                location: origin,
                radius: 50,
                types: ['street_address', 'premise']
            };
            
            // Usa service (gi√† definito globalmente come placesService)
            if (!service) {
                console.error("PlacesService non inizializzato");
                resolve([]);
                return;
            }
            
            service.nearbySearch(request, (results, status) => {
                if (status === 'OK' && results) {
                    // Filtra via il punto stesso (distanza < 2m)
                    const others = results.filter(p => {
                        const dist = google.maps.geometry.spherical.computeDistanceBetween(
                            origin, 
                            p.geometry.location
                        );
                        return dist > 2;
                    });
                    
                    console.log(`Trovati ${others.length} indirizzi vicini`);
                    resolve(others);
                } else {
                    console.log("Nessun indirizzo vicino trovato:", status);
                    resolve([]);
                }
            });
        });
    }

    /**
     * Trova il miglior vicino con Street View
     * mode: 'SAME_SIDE' o 'OPPOSITE_SIDE'
     */
    async function findBestNeighborCascade(neighbors, origin, mode) {
        // Ordina per distanza (pi√π vicino = migliore)
        neighbors.sort((a, b) => {
            const dA = google.maps.geometry.spherical.computeDistanceBetween(origin, a.geometry.location);
            const dB = google.maps.geometry.spherical.computeDistanceBetween(origin, b.geometry.location);
            return dA - dB;
        });

        for (const place of neighbors) {
            const placeLoc = place.geometry.location;
            
            try {
                // Prova a ottenere Street View per questo vicino
                const svData = await findStreetViewPromise(placeLoc, 20);
                
                // Abbiamo SV! Ora capiamo se √® stesso lato o opposto
                
                // Calcola orientamento strada dai link SV
                let roadHeading = 0;
                if (svData.links && svData.links.length > 0) {
                    // Media di tutti i link (non solo il primo!)
                    const headings = svData.links.map(link => link.heading);
                    roadHeading = headings.reduce((sum, h) => sum + h, 0) / headings.length;
                } else {
                    // Fallback: usa orientamento centrale
                    roadHeading = svData.tiles?.centerHeading || 0;
                }

                // Calcola vettore da me al vicino
                const vectorMeToNeighbor = google.maps.geometry.spherical.computeHeading(origin, placeLoc);
                
                // Differenza angolare normalizzata
                let diff = Math.abs(vectorMeToNeighbor - roadHeading);
                if (diff > 180) diff = 360 - diff;
                
                // Normalizza a [0, 90]
                let alignment = diff % 180; 
                if (alignment > 90) alignment = 180 - alignment;

                const isParallel = alignment < 30; // Tolleranza 30¬∞
                
                // Match con la richiesta
                if (mode === 'SAME_SIDE' && isParallel) {
                    console.log(`Trovato vicino stesso lato: ${place.name}, allineamento ${alignment.toFixed(1)}¬∞`);
                    return { 
                        svData: svData, 
                        address: place.name || place.vicinity,
                        location: placeLoc
                    };
                }
                
                if (mode === 'OPPOSITE_SIDE' && !isParallel) {
                    console.log(`Trovato vicino lato opposto: ${place.name}, allineamento ${alignment.toFixed(1)}¬∞`);
                    return { 
                        svData: svData, 
                        address: place.name || place.vicinity,
                        location: placeLoc
                    };
                }

            } catch (e) {
                // Niente SV qui, prova il prossimo
                continue;
            }
        }
        
        return null; // Nessun vicino valido trovato
    }

    async function processStreetViewResultCascade(svData, targetLoc, targetAddr, reliabilityMsg, reliabilityLevel, invert = false, isGeometricMode = false, locationInfo = null, precisionData = null) {
        const orientationStatusDiv = document.getElementById('orientation-status');
        const svLoc = svData.location.latLng;
        const distance = google.maps.geometry.spherical.computeDistanceBetween(svLoc, targetLoc);
        
        // 1. Recupera Direzione Strada (Street Heading)
        // Media dei link per stabilit√†, fallback su centerHeading
        let streetHeading = 0;
        if (svData.links && svData.links.length > 0) {
            const headings = svData.links.map(link => link.heading);
            streetHeading = headings.reduce((sum, h) => sum + h, 0) / headings.length;
        } else {
            streetHeading = svData.tiles?.centerHeading || 0;
        }

        // 2. CALCOLO DELL'ORIENTAMENTO (Il cuore del sistema)
        let buildingHeading = 0;
        let explanation = "";

        if (isGeometricMode) {
            // --- LOGICA GEOMETRICA (PROSPETTIVA) ---
            // Usiamo questa quando siamo lontani (>10m). 
            // Guardiamo la "linea" della strada e vediamo se la casa √® a destra o sinistra.
            
            const vectorToHouse = google.maps.geometry.spherical.computeHeading(svLoc, targetLoc);
            
            // Calcolo differenziale: (Vettore Casa) - (Vettore Strada)
            let diff = vectorToHouse - streetHeading;
            // Normalizzazione angolo tra -180 e 180
            if (diff > 180) diff -= 360;
            if (diff <= -180) diff += 360;
            
            // Se diff > 0: Casa a DESTRA. Orientamento = Strada + 90¬∞
            // Se diff < 0: Casa a SINISTRA. Orientamento = Strada - 90¬∞
            if (diff > 0) {
                buildingHeading = (streetHeading + 90) % 360; 
                explanation = "Analisi prospettica: l'edificio si trova sul lato <strong>DESTRO</strong> del senso di marcia.";
            } else {
                buildingHeading = (streetHeading - 90 + 360) % 360; 
                explanation = "Analisi prospettica: l'edificio si trova sul lato <strong>SINISTRO</strong> del senso di marcia.";
            }
        } else {
            // --- LOGICA STANDARD (VETTORIALE) ---
            // Usiamo questa quando siamo a una distanza sicura (4m - 50m).
            // Calcoliamo la freccia esatta che va dalla macchina al portone.
            buildingHeading = google.maps.geometry.spherical.computeHeading(svLoc, targetLoc);
            explanation = "Calcolo vettoriale diretto (Precisione Alta).";
        }

        if (invert) buildingHeading = (buildingHeading + 180) % 360;
        
        // Salviamo il dato globale per la funzione "Svolta"
        buildingDirectionFromStreet = buildingHeading;

        // 3. Preparazione Output Utente
        const exitingHeading = (buildingDirectionFromStreet + 180) % 360;
        const cardExit = getCardinalDirectionLong(exitingHeading);
        
        // Calcolo posizione relativa (solo per visualizzazione testuale)
        let relativeAngle = buildingHeading - streetHeading;
        if (relativeAngle > 180) relativeAngle -= 360;
        if (relativeAngle <= -180) relativeAngle += 360;
        
        let relativePosition = "";
        if (Math.abs(relativeAngle) < 15) relativePosition = "Davanti a te"; // Raro in geometric mode
        else if (relativeAngle > 0) relativePosition = "alla tua DESTRA";
        else relativePosition = "alla tua SINISTRA";

        // Styling differenziato per modalit√†
        const boxColor = isGeometricMode ? "#ffc107" : "#28a745"; // Giallo vs Verde
        const titleColor = isGeometricMode ? "#856404" : "#155724";

        // Warning per luoghi complessi
        let complexLocationWarning = '';
        if (locationInfo?.isComplex) {
            const warningIcons = {
                'piazza': 'üèõÔ∏è',
                'incrocio': 'üîÄ',
                'rotonda': 'üîÑ'
            };
            const icon = warningIcons[locationInfo.type] || '‚ö†Ô∏è';
            
            complexLocationWarning = `
                <div style="background: #fff3cd; border: 2px solid #ff9800; padding: 12px; border-radius: 8px; margin-top: 10px;">
                    <strong style="color: #856404;">${icon} Luogo Complesso: ${locationInfo.type.toUpperCase()}</strong>
                    <p style="margin: 8px 0 0 0; font-size: 0.9em; color: #666;">
                        Questo tipo di posizione √® pi√π difficile da orientare. <strong>Verifica attentamente il risultato</strong> 
                        confrontandolo con Street View e punti di riferimento noti.
                    </p>
                </div>
            `;
        }
        
        // Warning per precisione geocoding bassa
        let precisionWarning = '';
        if (precisionData?.found && !precisionData.reliable) {
            precisionWarning = `
                <div style="background: #fff3cd; border: 2px solid #ff9800; padding: 12px; border-radius: 8px; margin-top: 10px;">
                    <strong style="color: #856404;">üìä Precisione Indirizzo: ${precisionData.title}</strong>
                    <p style="margin: 8px 0 0 0; font-size: 0.9em; color: #666;">
                        ${precisionData.message}
                    </p>
                    <div style="margin-top: 8px; padding: 8px; background: white; border-radius: 4px;">
                        <small style="color: #856404;">
                            <strong>Affidabilit√† Geocoding:</strong> ${precisionData.score}/100<br>
                            <strong>Tipo:</strong> ${precisionData.type}
                        </small>
                    </div>
                </div>
            `;
        }

        const html = `
            <div style="border-left: 5px solid ${boxColor}; padding: 15px; background: #fff; border-radius: 8px;">
                <h4 style="margin:0 0 10px 0; color: ${titleColor};">
                    ${reliabilityMsg} <span style="font-size:0.8em; opacity:0.8">(${reliabilityLevel})</span>
                </h4>
                <div style="background: #f8f9fb; padding: 10px; border-radius: 6px; margin-bottom: 10px; font-size: 0.95em;">
                    <strong>Distanza punto osservazione:</strong> ${distance.toFixed(1)} metri<br>
                    <em>${explanation}</em>
                </div>
                <div style="background: ${isGeometricMode ? '#fff3cd' : '#e8f5e9'}; padding: 12px; border-radius: 6px; border-left: 4px solid ${titleColor};">
                    <p style="margin: 0 0 5px 0; font-size: 1.1em; color: ${titleColor};">
                        Quando esci, guardi verso: <strong>${cardExit}</strong>
                    </p>
                    <p style="margin: 5px 0 0 0; font-size: 1.05em; border-top: 1px solid #ccc; padding-top: 5px; color: ${titleColor};">
                        Rispetto alla strada, l'edificio √® <strong>${relativePosition}</strong>
                    </p>
                </div>
                ${complexLocationWarning}
                ${precisionWarning}
            </div>
        `;
        
        updateStatus(orientationStatusDiv, html, 'success', true);
        
        // Annuncio vocale sintetico per screen reader
        const shortAnnounce = `Analisi completata. Affidabilit√† ${isGeometricMode ? 'stimata' : 'alta'}. Uscendo guardi a ${cardExit}.`;
        announceToScreenReader(shortAnnounce);

        // Abilita il box delle svolte
        document.getElementById('turn-instruction-wrapper').style.display = 'block';
        
        // Aggiorna la vista Street View
        streetView.setPosition(svLoc);
        streetView.setPov({ heading: buildingHeading, pitch: 0 });
        
        // Calcola eventuali svolte se l'utente ha gi√† selezionato una direzione
        calculateAndShowTurnInstruction();
    }

    /**
     * Fallback quando non c'√® nessun dato visivo
     */
    // ================================================================
    // FINE SISTEMA CASCATA
    // ================================================================

    // *** FUNZIONE 'analyzeOrientationGeometrically' COMPLETAMENTE CORRETTA ***
    async function analyzeOrientationGeometrically(targetLoc, targetAddr, geocodePrecision, distanceToOsm) {
        const orientationStatusDiv = document.getElementById('orientation-status');
        const turnInstructionStatusDiv = document.getElementById('turn-instruction-status');
        
        let cameraLocationLatLng;
        let streetName = '';
        let streetDirection;
        buildingDirectionFromStreet = null;

        try {
            // Passo 1: Trova camera SV con ricerca espansa progressiva
            let svFound = false;
            let searchRadii = [50, 100, 150, 200]; // Radii di ricerca progressivi
            let data = null;
            let usedRadius = 0;
            
            for (const radius of searchRadii) {
                const metadataUrl = `https://maps.googleapis.com/maps/api/streetview/metadata?location=${targetLoc.lat()},${targetLoc.lng()}&radius=${radius}&key=${window.userApiKey}`;
                const response = await fetch(metadataUrl);
                data = await response.json();
                
                if (data.status === "OK") {
                    // üîí SAFETY CHECK: Verifica distanza PRIMA di accettare
                    const svLoc = new google.maps.LatLng(data.location.lat, data.location.lng);
                    const actualDistance = google.maps.geometry.spherical.computeDistanceBetween(targetLoc, svLoc);
                    
                    if (actualDistance < 4) {
                        console.warn(`‚ö†Ô∏è Street View troppo vicino: ${actualDistance.toFixed(1)}m nel raggio ${radius}m. Provo raggio successivo.`);
                        continue; // Salta questo raggio, prova il prossimo
                    }
                    
                    svFound = true;
                    usedRadius = radius;
                    
                    // Notifica l'utente se il punto trovato √® distante
                    const distanceRounded = Math.round(actualDistance);
                    if (distanceRounded > 50) {
                        notify(`‚ö†Ô∏è Street View trovato a ${distanceRounded}m dall'indirizzo (raggio ricerca: ${radius}m)`, 'info');
                    }
                    
                    break; // Trovato e valido, esci dal loop
                }
            }
            
            if (!svFound || data.status !== "OK") {
                 throw new Error(data?.status === "ZERO_RESULTS" ? 
                    "Nessun dato Street View disponibile entro 200m dall'indirizzo. Prova un altro indirizzo." : 
                    `Errore API Street View (${data?.status}).`);
            }
            
            cameraLocationLatLng = new google.maps.LatLng(data.location.lat, data.location.lng);
            
            // VERIFICA CRITICA: Controlla che Street View sia sulla stessa via dell'indirizzo cercato
            const svStreetName = await new Promise((resolve, reject) => {
                geocoder.geocode({ location: cameraLocationLatLng }, (results, status) => {
                    if (status === 'OK' && results?.[0]) {
                        const routeComponent = results[0].address_components?.find(c => c.types.includes('route'));
                        resolve(routeComponent?.long_name || null);
                    } else {
                        resolve(null);
                    }
                });
            });
            
            const originalStreetName = await new Promise((resolve, reject) => {
                geocoder.geocode({ location: targetLoc }, (results, status) => {
                    if (status === 'OK' && results?.[0]) {
                        const routeComponent = results[0].address_components?.find(c => c.types.includes('route'));
                        resolve(routeComponent?.long_name || null);
                    } else {
                        resolve(null);
                    }
                });
            });
            
            // Confronta i nomi delle vie (normalizza per evitare falsi negativi)
            const normalizeStreet = (name) => {
                if (!name) return '';
                return name.toLowerCase()
                    .replace(/^(via|viale|piazza|corso|largo|strada|vicolo)\s+/i, '')
                    .replace(/[^\w\s]/g, '')
                    .trim();
            };
            
            const svStreetNormalized = normalizeStreet(svStreetName);
            const originalStreetNormalized = normalizeStreet(originalStreetName);
            
            let streetWarning = '';
            if (svStreetNormalized && originalStreetNormalized && 
                svStreetNormalized !== originalStreetNormalized) {
                // NON bloccare, ma avvisa fortemente l'utente
                streetWarning = `<span class="output-line" style="color: #dc3545; font-weight: bold; background: #fff3cd; padding: 8px; border-radius: 5px; display: block; margin: 10px 0;">
                    ‚ö†Ô∏è ATTENZIONE: Street View trovato su "${svStreetName}" invece che su "${originalStreetName}". 
                    L'analisi potrebbe essere INAFFIDABILE. Considera di provare un indirizzo pi√π preciso.
                </span>`;
                notify(`‚ö†Ô∏è Street View su via diversa: ${svStreetName} ‚â† ${originalStreetName}`, 'error');
            } else if (usedRadius > 50) {
                // Se la verifica passa e il raggio era ampio, notifica successo
                notify(`‚úì Street View verificato su ${svStreetName || originalStreetName} (${distance}m)`, 'success');
            }

            // Passo 2: Trova nome strada/piazza/area (Metodo robusto)
            const reverseGeocodeResult = await new Promise((resolve, reject) => {
                geocoder.geocode({ location: cameraLocationLatLng }, (results, status) => {
                    if (status === 'OK' && results?.[0]) resolve(results[0]);
                    else reject(new Error(`Impossibile determinare la strada (Errore Reverse Geocoding: ${status})`));
                });
            });
            
            // Cerca il nome del luogo in ordine di preferenza
            const preferredStreetTypes = ['route', 'town_square', 'pedestrian', 'park', 'neighborhood', 'colloquial_area', 'locality'];
            let streetComponent = null;
            for (const type of preferredStreetTypes) {
                streetComponent = reverseGeocodeResult.address_components?.find(c => c.types.includes(type));
                if (streetComponent) break; 
            }

            if (!streetComponent) {
                throw new Error("Impossibile determinare il nome della strada/piazza/area.");
            }
            streetName = streetComponent.long_name;

            // Passo 3: Trova direzione della strada (Metodo robusto basato sui link)
            // Dobbiamo chiedere all'istanza di streetview i suoi link
            await new Promise(resolve => setTimeout(resolve, 50)); // Piccola attesa per caricare i link
            const svLinks = streetView.getLinks();
            
            if (!svLinks || svLinks.length < 2) {
                if(svLinks && svLinks.length === 1) {
                     // Fine di una strada, usa l'unico link (indietro)
                     streetDirection = (svLinks[0].heading + 180 + 360) % 360; // L'asse √® opposto
                } else {
                     throw new Error("Impossibile determinare la direzione (nessun link SV).");
                }
            } else {
                // Cerca la coppia di link pi√π vicina a 180¬∞ (avanti/indietro)
                let bestPair = null;
                let minDiffFrom180 = 180;

                for (let i = 0; i < svLinks.length; i++) {
                    for (let j = i + 1; j < svLinks.length; j++) {
                        let diff = Math.abs(svLinks[i].heading - svLinks[j].heading);
                        if (diff > 180) diff = 360 - diff; // Gestisce il giro
                        
                        const diffFrom180 = Math.abs(180 - diff);
                        
                        if (diffFrom180 < minDiffFrom180) {
                            minDiffFrom180 = diffFrom180;
                            bestPair = [svLinks[i], svLinks[j]];
                        }
                    }
                }

                if (!bestPair || minDiffFrom180 > 45) { // Tolleranza 45¬∞
                    // Non ha trovato un asse chiaro (es. incrocio a 5 vie)
                    // Usa l'orientamento di caricamento del panorama
                    streetDirection = (streetView.getPov().heading + 360) % 360;
                     console.warn("Nessun asse stradale chiaro, uso il POV di caricamento.");
                } else {
                     // Usa l'orientamento del primo link della coppia come direzione
                     streetDirection = (bestPair[0].heading + 360) % 360;
                }
            }
            
            // Nota: Safety check gi√† fatto nel loop sopra
            // Qui siamo sicuri che distanceToStreetView >= 4m
            
            // Calcolo distanza per affidabilit√†
            const distanceToStreetView = google.maps.geometry.spherical.computeDistanceBetween(
                targetLoc,
                cameraLocationLatLng
            );
            
            // Passo 4 & 5: Calcola direzioni
            buildingDirectionFromStreet = (google.maps.geometry.spherical.computeHeading(cameraLocationLatLng, targetLoc) + 360) % 360;

            // Passo 6 & 7: Calcola angolo e posizione relativa
            let relativeAngle = buildingDirectionFromStreet - streetDirection;
            if (relativeAngle > 180) relativeAngle -= 360;
            if (relativeAngle <= -180) relativeAngle += 360;
            let relativePosition = "";
            if (relativeAngle >= -45 && relativeAngle < 45) { relativePosition = "Davanti"; }
            else if (relativeAngle >= 45 && relativeAngle < 135) { relativePosition = "alla Destra"; }
            else if (relativeAngle <= -45 && relativeAngle > -135) { relativePosition = "alla Sinistra"; }
            else { relativePosition = relativeAngle > 0 ? "Dietro, leggermente alla Destra" : "Dietro, leggermente alla Sinistra"; }
            
            const streetDirectionCardinal = getCardinalDirectionLong(streetDirection);

            // *** LOGICA DI AFFIDABILIT√Ä CORRETTA CON "SPALLE AL PALO" ***
            // Passo 8: Messaggio con affidabilit√†
            let reliabilityText = "SCONOSCIUTA";
            let reliabilityClass = "reliability-low";
            let precisionReason = "";
            let isBackToPost = false; // Flag per modalit√† "Spalle al Palo"
            
            // Nota: distanceToStreetView gi√† calcolata sopra per safety check

            if (geocodePrecision === 'ROOFTOP') {
                reliabilityText = "ALTA üü¢";
                reliabilityClass = "reliability-high";
                precisionReason = "Precisione Google: ALTA (ROOFTOP).";
                if (distanceToOsm !== null && distanceToOsm > RELIABILITY_THRESHOLD_METERS) {
                    precisionReason += ` (Nota: Verifica OSM fallita, dist. ${distanceToOsm.toFixed(1)}m).`;
                }
            } else if (distanceToStreetView < 25) {
                // ‚ú® NUOVA LOGICA "SPALLE AL PALO" ‚ú®
                // Se il punto non √® ROOFTOP ma √® vicino alla strada (< 25m), lo accettiamo!
                reliabilityText = "ALTA üü¢";
                reliabilityClass = "reliability-high";
                isBackToPost = true;
                precisionReason = `Punto di partenza a ${distanceToStreetView.toFixed(1)}m dalla strada. ` +
                                 `Orientamento "Spalle al Palo/Fermata" - Situazione affidabile.`;
            } else if (geocodePrecision === 'RANGE_INTERPOLATED') {
                reliabilityText = "MEDIA üü°";
                reliabilityClass = "reliability-medium";
                precisionReason = "Precisione Google: MEDIA (Interpolata). L'orientamento √® una stima.";
            } else {
                reliabilityText = "NULLA üî¥";
                reliabilityClass = "reliability-low";
                precisionReason = `Precisione Google: BASSA (${geocodePrecision}). ` +
                                 `Distanza da Street View: ${distanceToStreetView.toFixed(1)}m. Analisi non affidabile.`;
            }
            // *** FINE MODIFICA MESSAGGI ***

            const outputHtmlOrientation = `
                ${streetWarning}
                <span class="output-line ${reliabilityClass}">
                    Affidabilit√† Stima: <strong>${reliabilityText}</strong>
                </span>
                <span class="output-line" style="font-size: 0.9em; margin-bottom: 1em;">
                    Motivo: ${precisionReason}
                </span>
                ${isBackToPost ? 
                    `<span class="output-line"><strong>Situazione (Spalle al punto/fermata):</strong> Hai la strada davanti a te...</span>
                     <span class="output-line">...guardando verso <strong>${streetDirectionCardinal}</strong> (dir. ${Math.round(streetDirection)}¬∞).</span>
                     <span class="output-line">L'edificio <strong>"${targetAddr}"</strong> si trova <strong>${relativePosition}</strong> rispetto a questa direzione.</span>` :
                    `<span class="output-line">Sei virtualmente al centro di <strong>${streetName}</strong>.</span>
                     <span class="output-line">L'area/strada qui ha un asse verso <strong>${streetDirectionCardinal}</strong> (dir. ${Math.round(streetDirection)}¬∞).</span>
                     <span class="output-line">L'edificio <strong>"${targetAddr}"</strong> si trova <strong>${relativePosition}</strong> rispetto a questo asse.</span>`
                }
            `;
            updateStatus(orientationStatusDiv, outputHtmlOrientation, 'success', true);

            // Passo 9: Calcola e mostra la svolta opzionale
            calculateAndShowTurnInstruction();

        } catch (error) {
             const errorMsg = error.message;
             let helpText = '';
             
             if (errorMsg.includes('nessun link SV') || errorMsg.includes('Street View entro')) {
                 helpText = '<br><br><strong>üí° Suggerimenti:</strong><br>' +
                           '‚Ä¢ Prova un indirizzo diverso o pi√π vicino a una strada principale<br>' +
                           '‚Ä¢ Alcune aree non hanno copertura Street View<br>' +
                           '‚Ä¢ Usa il pulsante üîÑ RESET in Street View se sei bloccato';
             } else if (errorMsg.includes('invece che su')) {
                 helpText = '<br><br><strong>üí° Suggerimenti:</strong><br>' +
                           '‚Ä¢ L\'indirizzo cercato √® troppo lontano da Street View disponibile<br>' +
                           '‚Ä¢ Street View ha trovato una via diversa da quella cercata<br>' +
                           '‚Ä¢ Prova con il numero civico esatto o un punto pi√π centrale della via<br>' +
                           '‚Ä¢ Verifica che la via abbia copertura Street View nella mappa';
             }
             
             updateStatus(orientationStatusDiv, `<span class="error-message">Errore: ${errorMsg}</span>${helpText}<br><br>Impossibile determinare l'orientamento.`, 'error', true);
             updateStatus(turnInstructionStatusDiv, `Analisi fallita: ${errorMsg}`, 'error');
        }
    }

    function calculateAndShowTurnInstruction() {
        const turnInstructionStatusDiv = document.getElementById('turn-instruction-status');
        const desiredDir = document.getElementById('desired-direction').value;

        if (!desiredDir) {
            updateStatus(turnInstructionStatusDiv, "Nessuna direzione desiderata specificata.", 'info');
            return;
        }
        if (buildingDirectionFromStreet === null) {
             updateStatus(turnInstructionStatusDiv, "Impossibile calcolare svolta: orientamento edificio non determinato.", 'error');
             return;
        }

        const desiredDegrees = cardinalToDegrees[desiredDir];
        if (desiredDegrees === undefined) {
             updateStatus(turnInstructionStatusDiv, "Errore: Direzione desiderata non valida.", 'error');
             return;
        }

        // üîß CALCOLO SVOLTA
        // NOTA GEOMETRICA: buildingDirectionFromStreet √® calcolato come vettore DA STRADA VERSO PUNTO
        // Quindi per sapere dove guardi TU (dal punto verso la strada), serve SEMPRE +180¬∞
        
        const exitingDirection = (buildingDirectionFromStreet + 180) % 360;
        
        let turnAngle = desiredDegrees - exitingDirection;
        if (turnAngle > 180) turnAngle -= 360;
        if (turnAngle <= -180) turnAngle += 360;

        const turnDegrees = Math.round(Math.abs(turnAngle));
        let turnDirection = "";
        
        // Istruzioni semplificate e pi√π umane
        if (turnDegrees < 20) { 
          turnDirection = "procedi Dritto sul marciapiede"; 
        } else if (turnDegrees >= 20 && turnDegrees < 70) {
          turnDirection = turnAngle > 0 ? "gira a Destra sul marciapiede" : "gira a Sinistra sul marciapiede";
        } else if (turnDegrees >= 70 && turnDegrees < 110) {
          turnDirection = turnAngle > 0 ? "gira decisamente a Destra" : "gira decisamente a Sinistra";
        } else if (turnDegrees >= 110 && turnDegrees < 160) {
          turnDirection = turnAngle > 0 ? "gira quasi indietro verso Destra" : "gira quasi indietro verso Sinistra";
        } else {
          // Quasi 180¬∞ - scegli il lato pi√π breve
          if (turnAngle > 0) {
            turnDirection = "fai quasi mezzo giro verso Destra";
          } else {
            turnDirection = "fai quasi mezzo giro verso Sinistra";
          }
        }

        // Calcola la direzione opposta per chi √® appena sceso dal mezzo
        let oppositeAngle = desiredDegrees - exitingDirection - 180;
        if (oppositeAngle > 180) oppositeAngle -= 360;
        if (oppositeAngle <= -180) oppositeAngle += 360;
        
        const oppositeDegrees = Math.round(Math.abs(oppositeAngle));
        let oppositeDirection = "";
        if (oppositeDegrees < 20) { 
          oppositeDirection = "procedi Dritto sul marciapiede"; 
        } else if (oppositeDegrees >= 20 && oppositeDegrees < 70) {
          oppositeDirection = oppositeAngle > 0 ? "gira a Destra sul marciapiede" : "gira a Sinistra sul marciapiede";
        } else if (oppositeDegrees >= 70 && oppositeDegrees < 110) {
          oppositeDirection = oppositeAngle > 0 ? "gira decisamente a Destra" : "gira decisamente a Sinistra";
        } else if (oppositeDegrees >= 110 && oppositeDegrees < 160) {
          oppositeDirection = oppositeAngle > 0 ? "gira quasi indietro verso Destra" : "gira quasi indietro verso Sinistra";
        } else {
          if (oppositeAngle > 0) {
            oppositeDirection = "fai quasi mezzo giro verso Destra";
          } else {
            oppositeDirection = "fai quasi mezzo giro verso Sinistra";
          }
        }

         const outputHtmlTurn = `
            <span class="output-line" style="font-size: 1.1em;"><strong>Per andare verso ${getCardinalDirectionLong(desiredDegrees)}:</strong></span>
            <span class="output-line" style="font-size: 1.2em; color: #667eea; font-weight: bold; margin: 0.5em 0;">${turnDirection}</span>
            <span class="output-line" style="margin-top: 1em; padding-top: 0.5em; border-top: 1px dashed #ccc; font-style: italic; color: #17a2b8; font-size: 0.9em;">
                ‚ÑπÔ∏è Se sei appena sceso dal mezzo con le spalle al traffico: ${oppositeDirection}.
            </span>
        `;
        updateStatus(turnInstructionStatusDiv, outputHtmlTurn, 'info', true);
    }

    // ===============================
    // üÜï RAY CASTING - ANALISI SICUREZZA ATTRAVERSAMENTI
    // ===============================
    
    /**
     * Analizza la sicurezza degli attraversamenti per il passo corrente
     * Attivata solo quando necessario (trigger intelligente)
     */
    async function analyzeRoadCrossings(step, instructionDiv) {
      // Trigger intelligente: analizza solo se necessario
      const instruction = step.instructions?.toLowerCase() || '';
      const distance = step.distance?.value || 0; // in metri
      
      const keywords = ['attraversa', 'cross', 'rotonda', 'roundabout', 'incrocio'];
      const hasKeyword = keywords.some(kw => instruction.includes(kw));
      
      if (!hasKeyword && distance > 50) {
        // Passo lungo senza attraversamento: skip analisi
        return;
      }
      
      // Mostra loading
      const loadingDiv = document.createElement('div');
      loadingDiv.className = 'raycasting-loading';
      loadingDiv.textContent = 'Analisi sicurezza in corso...';
      instructionDiv.appendChild(loadingDiv);
      
      try {
        const result = await performRayCasting(step);
        loadingDiv.remove();
        
        const alertDiv = document.createElement('div');
        alertDiv.className = `safety-alert ${result.level}`;
        alertDiv.setAttribute('role', 'alert');
        alertDiv.innerHTML = result.message;
        
        instructionDiv.appendChild(alertDiv);
        
      } catch (error) {
        console.error('Errore Ray Casting:', error);
        loadingDiv.remove();
      }
    }
    
    /**
     * Esegue il Ray Casting vero e proprio con query Overpass OSM
     */
    async function performRayCasting(step) {
      const start = step.start_location;
      const end = step.end_location;
      
      if (!start || !end) {
        return { level: 'unknown', message: 'Impossibile analizzare: coordinate non disponibili.' };
      }
      
      // Verifica cache
      const cacheKey = `raycasting_${start.lat()}_${start.lng()}_${end.lat()}_${end.lng()}`;
      const cached = localStorage.getItem(cacheKey);
      
      if (cached) {
        const cachedData = JSON.parse(cached);
        if (Date.now() - cachedData.timestamp < 86400000) { // 24 ore
          return cachedData.result;
        }
      }
      
      // Calcola bounding box (25m buffer)
      const centerLat = (start.lat() + end.lat()) / 2;
      const centerLng = (start.lng() + end.lng()) / 2;
      const bbox = calculateBBoxForRayCasting({ lat: centerLat, lng: centerLng }, 25);
      
      // Query Overpass API
      // NOTA: Usa union per includere sia strade senza layer che strade con layer=0
      const query = `
        [out:json][timeout:5];
        (
          way[highway~"^(primary|secondary|tertiary|residential|trunk|unclassified)$"][!"layer"](${bbox});
          way[highway~"^(primary|secondary|tertiary|residential|trunk|unclassified)$"][layer=0](${bbox});
        );
        out geom;
      `;
      
      try {
        const response = await fetch('https://overpass-api.de/api/interpreter', {
          method: 'POST',
          body: query
        });
        
        if (!response.ok) throw new Error('OSM query failed');
        
        const data = await response.json();
        const roads = data.elements.filter(e => e.type === 'way' && e.geometry);
        
        // Ray Casting geometrico
        const intersections = countIntersections(
          { lat: start.lat(), lng: start.lng() },
          { lat: end.lat(), lng: end.lng() },
          roads
        );
        
        // Determina livello di sicurezza
        let result = generateSafetyMessage(intersections, step.instructions);
        
        // Salva in cache
        localStorage.setItem(cacheKey, JSON.stringify({
          timestamp: Date.now(),
          result: result
        }));
        
        return result;
        
      } catch (error) {
        console.error('Errore Overpass:', error);
        
        // Paracadute: usa analisi testuale Google
        const instruction = step.instructions?.toLowerCase() || '';
        if (instruction.includes('attraversa') || instruction.includes('cross') || instruction.includes('rotonda')) {
          return {
            level: 'warning',
            message: '‚ö†Ô∏è ATTENZIONE: Google indica un attraversamento, ma i dati geometrici non sono disponibili. Procedere con cautela.'
          };
        }
        
        return { level: 'unknown', message: 'Analisi non disponibile per questo passo.' };
      }
    }
    
    /**
     * Conta le intersezioni tra il segmento di movimento e le strade OSM
     */
    function countIntersections(start, end, roads) {
      let count = 0;
      
      roads.forEach(road => {
        if (!road.geometry || road.geometry.length < 2) return;
        
        // Verifica intersezione tra segmento start-end e ogni segmento della strada
        for (let i = 0; i < road.geometry.length - 1; i++) {
          const roadStart = road.geometry[i];
          const roadEnd = road.geometry[i + 1];
          
          if (segmentsIntersect(start, end, roadStart, roadEnd)) {
            count++;
            break; // Conta solo una volta per strada
          }
        }
      });
      
      return count;
    }
    
    /**
     * Algoritmo di intersezione tra due segmenti
     */
    function segmentsIntersect(p1, p2, p3, p4) {
      // Algoritmo di intersezione tra segmenti
      const det = (p2.lng - p1.lng) * (p4.lat - p3.lat) - (p4.lng - p3.lng) * (p2.lat - p1.lat);
      
      if (Math.abs(det) < 1e-10) return false; // Paralleli
      
      const t = ((p4.lng - p3.lng) * (p1.lat - p3.lat) - (p4.lat - p3.lat) * (p1.lng - p3.lng)) / det;
      const u = ((p2.lng - p1.lng) * (p1.lat - p3.lat) - (p2.lat - p1.lat) * (p1.lng - p3.lng)) / det;
      
      return t >= 0 && t <= 1 && u >= 0 && u <= 1;
    }
    
    /**
     * Genera il messaggio di sicurezza appropriato
     */
    function generateSafetyMessage(intersections, htmlInstruction) {
      const instruction = htmlInstruction?.toLowerCase() || '';
      
      if (intersections === 0) {
        // Verifica paracadute
        if (instruction.includes('attraversa') || instruction.includes('cross')) {
          return {
            level: 'warning',
            message: '‚ö†Ô∏è ATTENZIONE: Google indica un attraversamento, ma non sono state rilevate strade. Verificare visivamente.'
          };
        }
        return {
          level: 'safe',
          message: 'Percorso su marciapiede. Nessun attraversamento rilevato.'
        };
      }
      
      if (intersections === 1) {
        return {
          level: 'warning',
          message: '‚ö†Ô∏è Attraversamento stradale semplice (1 carreggiata).'
        };
      }
      
      if (intersections === 2) {
        return {
          level: 'danger',
          message: '‚ö†Ô∏è ATTENZIONE: Strada a doppia carreggiata - traffico bidirezionale separato.'
        };
      }
      
      return {
        level: 'danger',
        message: `‚ö†Ô∏è PERICOLO: Incrocio complesso - rilevate ${intersections} linee di traffico. Massima cautela.`
      };
    }
    
    /**
     * Calcola bounding box per Ray Casting
     */
    function calculateBBoxForRayCasting(center, radiusMeters) {
      const earthRadius = 6371000;
      const latDelta = (radiusMeters / earthRadius) * (180 / Math.PI);
      const lngDelta = latDelta / Math.cos(center.lat * Math.PI / 180);
      
      return `${center.lat - latDelta},${center.lng - lngDelta},${center.lat + latDelta},${center.lng + lngDelta}`;
    }

    // =============================
    // üÜï GESTIONE INTELLIGENTE U-TURN
    // =============================
    
    /**
     * üéØ FUNZIONE PRINCIPALE: Analizza uno step per determinare se √® un'inversione a U
     * e in quale scenario ricade.
     * 
     * STRATEGIA: Google Text primario + OSM per dettagli aggiuntivi
     */
    async function analyzeUTurnScenario(step, prevStep) {
      const startLoc = {lat: step.start_location.lat(), lng: step.start_location.lng()};
      const endLoc = {lat: step.end_location.lat(), lng: step.end_location.lng()};
      
      // 1. CALCOLO ANGOLO DI SVOLTA
      let turnAngle = null;
      if (prevStep) {
        const prevHeading = google.maps.geometry.spherical.computeHeading(
          prevStep.start_location, 
          prevStep.end_location
        );
        const currHeading = google.maps.geometry.spherical.computeHeading(
          step.start_location, 
          step.end_location
        );
        turnAngle = currHeading - prevHeading;
        if (turnAngle > 180) turnAngle -= 360;
        if (turnAngle <= -180) turnAngle += 360;
      }
      
      const absTurnAngle = Math.abs(turnAngle || 0);
      
      // 2. VERIFICA SE √à UN'INVERSIONE
      const U_TURN_MIN_ANGLE = 140;
      const U_TURN_MAX_ANGLE = 220;
      const isUTurn = (absTurnAngle >= U_TURN_MIN_ANGLE && absTurnAngle <= U_TURN_MAX_ANGLE);
      
      if (!isUTurn) {
        return {type: 'normal', angle: turnAngle};
      }
      
      debugLog('üîÑ Rilevata possibile inversione a U:', absTurnAngle, '¬∞');
      
      // 3. VERIFICA ROTONDA
      const instruction = (step.instructions || '').toLowerCase();
      if (instruction.includes('rotonda') || instruction.includes('roundabout')) {
        debugLog('üîÑ Identificata come rotonda, non inversione');
        return {type: 'roundabout', angle: turnAngle};
      }
      
      // ========================================
      // LOGICA GOOGLE-FIRST (Pi√π Affidabile)
      // ========================================
      
      // 4. FONTE PRIMARIA: Google Text
      const googleIndicatesCrossing = 
        instruction.includes('attraversa') || 
        instruction.includes('cross') || 
        instruction.includes('traverse') ||
        instruction.includes('other side') ||
        instruction.includes('lato opposto');
      
      if (googleIndicatesCrossing) {
        debugLog('‚úÖ Google indica esplicitamente attraversamento');
        
        let osmDetails = null;
        try {
          osmDetails = await checkRoadIntersection(startLoc, endLoc, step);
        } catch (e) {
          console.warn('‚ö†Ô∏è OSM non disponibile, procedo con Google');
        }
        
        return {
          type: 'crossing',
          angle: turnAngle,
          roadData: {
            intersects: true,
            count: osmDetails?.count || 1,
            confidence: 'high',
            source: 'google_text',
            crosswalks: osmDetails?.crosswalks || [],
            method: osmDetails ? 'google+osm' : 'google_only'
          }
        };
      }
      
      // 5. FONTE SECONDARIA: OSM
      console.log('‚ÑπÔ∏è Google silenzioso, verifico OSM...');
      
      try {
        const osmData = await checkRoadIntersection(startLoc, endLoc, step);
        
        if (osmData.intersects) {
          console.log('‚ö†Ô∏è OSM rileva attraversamento');
          
          return {
            type: 'crossing',
            angle: turnAngle,
            roadData: {
              intersects: true,
              count: osmData.count,
              confidence: 'medium',
              source: 'osm_geometry',
              crosswalks: osmData.crosswalks,
              method: 'osm_only',
              warning: 'Google non menziona attraversamento ma OSM lo rileva'
            }
          };
        }
        
        debugLog('‚úÖ Nessun attraversamento (Google + OSM concordano)');
        
      } catch (error) {
        console.log('‚ö†Ô∏è OSM non disponibile, Google non indica attraversamento');
      }
      
      // 6. POST-FERMATA
      const isPostTransit = prevStep && prevStep.travel_mode === 'TRANSIT';
      
      if (isPostTransit) {
        console.log('üöç Inversione dopo mezzo pubblico');
        return {
          type: 'post_transit_uturn',
          angle: turnAngle,
          transitInfo: prevStep.transit_details
        };
      }
      
      // 7. DEFAULT: Marciapiede
      debugLog('‚úÖ Inversione su marciapiede');
      return {
        type: 'sidewalk_uturn',
        angle: turnAngle
      };
    }
    
    /**
     * üõ£Ô∏è Verifica se la linea tra due punti interseca geometrie stradali OSM
     * 
     * Restituisce intersects = null se non pu√≤ determinare con certezza
     */
    async function checkRoadIntersection(start, end, step) {
      const midpoint = {
        lat: (start.lat + end.lat) / 2,
        lng: (start.lng + end.lng) / 2
      };
      
      // Check cache prima di interrogare Overpass
      const cacheKey = `roadint_${Math.round(midpoint.lat*10000)}_${Math.round(midpoint.lng*10000)}`;
      const cached = localStorage.getItem(cacheKey);
      if (cached) {
        const data = JSON.parse(cached);
        if (Date.now() - data.timestamp < 86400000) { // 24h
          console.log('üì¶ Cache hit per intersezione strada');
          return data.result;
        }
      }
      
      // Query Overpass per geometrie stradali entro 50m
      const bbox = calculateBBoxForRayCasting(midpoint, 50);
      const query = `
        [out:json][timeout:10];
        (
          way["highway"~"^(primary|secondary|tertiary|residential|unclassified|trunk|motorway|service)$"](${bbox});
        );
        out geom;
      `;
      
      try {
        const response = await fetch('https://overpass-api.de/api/interpreter', {
          method: 'POST',
          body: query
        });
        
        if (!response.ok) throw new Error(`Overpass HTTP ${response.status}`);
        
        const data = await response.json();
        const roads = data.elements
          .filter(el => el.type === 'way' && el.geometry && el.geometry.length >= 2)
          .map(way => ({
            geometry: way.geometry.map(node => ({lat: node.lat, lng: node.lon})),
            tags: way.tags
          }));
        
        console.log('üó∫Ô∏è Overpass ha restituito', roads.length, 'strade');
        
        // Conta intersezioni
        const intersectionCount = countIntersections(start, end, roads);
        
        // Verifica presenza attraversamenti pedonali
        const crosswalks = await findNearbyCrosswalks(start, 20);
        
        const result = {
          intersects: intersectionCount > 0,
          count: intersectionCount,
          roads: roads.length,
          crosswalks: crosswalks,
          confidence: intersectionCount > 0 ? 'high' : 'medium',
          method: 'geometry'
        };
        
        // Salva in cache
        localStorage.setItem(cacheKey, JSON.stringify({
          timestamp: Date.now(),
          result: result
        }));
        
        return result;
        
      } catch (error) {
        console.error('‚ùå Errore checkRoadIntersection:', error);
        
        // ‚ö†Ô∏è OSM fallito ‚Üí restituisci null (incertezza)
        return {
          intersects: null, // ‚Üê "NON LO SO"
          count: 0,
          confidence: 'low',
          fallbackUsed: true,
          method: 'failed',
          error: error.message
        };
      }
    }
    
    /**
     * üö∂ Cerca attraversamenti pedonali entro un raggio
     */
    async function findNearbyCrosswalks(location, radiusMeters) {
      const bbox = calculateBBoxForRayCasting(location, radiusMeters);
      const query = `
        [out:json][timeout:5];
        (
          node["highway"="crossing"](${bbox});
          way["footway"="crossing"](${bbox});
        );
        out geom;
      `;
      
      try {
        const response = await fetch('https://overpass-api.de/api/interpreter', {
          method: 'POST',
          body: query
        });
        
        if (!response.ok) throw new Error(`Overpass HTTP ${response.status}`);
        
        const data = await response.json();
        
        const crosswalks = data.elements.map(el => {
          const elLat = el.lat || (el.center ? el.center.lat : null);
          const elLng = el.lon || (el.center ? el.center.lon : null);
          
          if (!elLat || !elLng) return null;
          
          return {
            type: el.tags?.crossing || 'unknown',
            distance: google.maps.geometry.spherical.computeDistanceBetween(
              new google.maps.LatLng(location.lat, location.lng),
              new google.maps.LatLng(elLat, elLng)
            ),
            location: {lat: elLat, lng: elLng},
            tags: el.tags
          };
        })
        .filter(c => c !== null)
        .sort((a, b) => a.distance - b.distance);
        
        console.log('üö∂ Trovati', crosswalks.length, 'attraversamenti pedonali');
        return crosswalks;
        
      } catch (error) {
        console.warn('‚ö†Ô∏è Errore ricerca crosswalks:', error);
        return [];
      }
    }
    
    /**
     * üó£Ô∏è Genera l'istruzione vocale appropriata per un'inversione a U
     */
    function generateUTurnInstruction(scenario, distance) {
      const distanceText = distance ? ` (${distance})` : '';
      
      switch(scenario.type) {
        case 'sidewalk_uturn':
          // SCENARIO 1: Inversione su marciapiede
          return `
            <div style="background: #e8f5e9; border-left: 5px solid #28a745; padding: 14px; border-radius: 8px; margin-top: 12px;">
              <strong style="font-size: 1.25em; color: #2e7d32;">üîÑ Fai dietrofront sul marciapiede</strong>${distanceText}<br>
              <span style="color: #2e7d32; margin-top: 8px; display: block; line-height: 1.5;">
                Inverti la direzione di marcia restando sullo stesso lato della strada.<br>
                <small style="color: #555; font-style: italic;">Torna indietro lungo il percorso appena percorso.</small>
              </span>
            </div>
          `;
          
        case 'crossing':
          // SCENARIO 2: Attraversamento stradale
          const confidence = scenario.roadData.confidence;
          const method = scenario.roadData.method;
          const hasCrosswalk = scenario.roadData.crosswalks && scenario.roadData.crosswalks.length > 0;
          const nearestCrosswalk = hasCrosswalk ? scenario.roadData.crosswalks[0] : null;
          
          let crossingDetail = '';
          if (hasCrosswalk && nearestCrosswalk.distance < 30) {
            const crossType = nearestCrosswalk.tags?.crossing === 'traffic_signals' ? 
              'semaforo pedonale' : 'strisce pedonali';
            crossingDetail = `Usa il ${crossType} a ${Math.round(nearestCrosswalk.distance)}m.`;
          } else if (confidence === 'high') {
            crossingDetail = 'Cerca strisce pedonali o semaforo nelle vicinanze.';
          } else {
            crossingDetail = '‚ö†Ô∏è Attraversamento probabile - verifica presenza strisce pedonali.';
          }
          
          const carreggiate = scenario.roadData.count === 1 ? 'una carreggiata' : 
                              `${scenario.roadData.count} carreggiate`;
          
          // Badge fonte
          let sourceBadge = '';
          if (method === 'google_only') {
            sourceBadge = '<span style="background:#4285f4;color:white;padding:2px 8px;border-radius:10px;font-size:0.75em;margin-left:8px;">Google</span>';
          } else if (method === 'google+osm') {
            sourceBadge = '<span style="background:#34a853;color:white;padding:2px 8px;border-radius:10px;font-size:0.75em;margin-left:8px;">Google+OSM</span>';
          } else if (method === 'osm_only') {
            sourceBadge = '<span style="background:#fbbc04;color:white;padding:2px 8px;border-radius:10px;font-size:0.75em;margin-left:8px;">OSM</span>';
          }
          
          const bgColor = confidence === 'high' ? '#fff3cd' : '#ffe5cc';
          const borderColor = confidence === 'high' ? '#ff9800' : '#ff6b35';
          
          return `
            <div style="background: ${bgColor}; border-left: 5px solid ${borderColor}; padding: 14px; border-radius: 8px; margin-top: 12px;">
              <strong style="font-size: 1.25em; color: #856404;">‚ö†Ô∏è ATTRAVERSA la strada</strong>${sourceBadge}${distanceText}<br>
              <span style="color: #856404; margin-top: 8px; display: block; line-height: 1.5;">
                ${crossingDetail}<br>
                <small>Traffico rilevato: ${carreggiate}.</small>
                ${scenario.roadData.warning ? `<br><small style="color: #d9534f;">‚ÑπÔ∏è ${scenario.roadData.warning}</small>` : ''}
              </span>
            </div>
          `;
          
        case 'post_transit_uturn':
          // SCENARIO 3: Post-fermata bus
          const transitLine = scenario.transitInfo?.line?.name || scenario.transitInfo?.line?.short_name || 'il mezzo';
          const headsign = scenario.transitInfo?.headsign || '';
          
          return `
            <div style="background: #e3f2fd; border-left: 5px solid #2196f3; padding: 14px; border-radius: 8px; margin-top: 12px;">
              <strong style="font-size: 1.25em; color: #1565c0;">üöç Dopo essere sceso da ${transitLine}</strong>${distanceText}<br>
              <span style="color: #1565c0; margin-top: 8px; display: block; line-height: 1.5;">
                Cammina nella direzione <strong>opposta</strong> al senso di marcia del mezzo.
                ${headsign ? `<br><small>(Il mezzo andava verso: ${headsign})</small>` : ''}
              </span>
              <span style="margin-top: 10px; display: block; font-size: 0.92em; color: #555; font-style: italic; padding-top: 8px; border-top: 1px dashed #90caf9;">
                üí° Se hai le spalle al traffico dopo essere sceso, cammina dritto senza girarti.
              </span>
            </div>
          `;
          
        default:
          return '';
      }
    }

    // ---------------
    // EVENT LISTENERS
    // ---------------
    
    document.addEventListener('keydown', e => {
      if (e.key === 'Escape') {
        const modal = document.getElementById('modal');
        const navView = document.getElementById('navigationView');
        if (modal?.classList.contains('show')) {
          closeModal();
        } else if (navView?.style.display === 'flex') {
          exitNavigation();
        }
      }
      if (e.key === 'Enter' && e.ctrlKey && document.getElementById('searchSection')?.style.display !== 'none') {
        searchPlaces();
      }
      if (e.key === 'ArrowRight' && e.ctrlKey && document.getElementById('navigationView')?.style.display === 'flex') {
        e.preventDefault();
        navNextStep();
      }
      if (e.key === 'ArrowLeft' && e.ctrlKey && document.getElementById('navigationView')?.style.display === 'flex') {
        e.preventDefault();
        navPrevStep();
      }
    });
    document.addEventListener('click', e => {
      if (e.target.id === 'modal') closeModal();
    });
    
    // Listener per il cambio di direzione desiderata
    document.getElementById('desired-direction').addEventListener('change', calculateAndShowTurnInstruction);
    
    // Listener per Enter negli input
    document.getElementById('addressInput')?.addEventListener('keypress', e => {
      if (e.key === 'Enter') {
        searchLocation();
        announceToScreenReader('Ricerca indirizzo avviata');
      }
    });

// ===== GESTIONE MOOVIT CON SCELTA UTENTE =====
const MOOVIT_ZONES_STORAGE = 'moovit_zones';
let selectedMoovitZone = null;

// Carica le zone Moovit salvate
function loadMoovitZones() {
  const saved = localStorage.getItem(MOOVIT_ZONES_STORAGE);
  return saved ? JSON.parse(saved) : [];
}

// Salva una nuova zona Moovit
function saveMoovitZone(url, zoneName) {
  const zones = loadMoovitZones();
  
  // Controlla se esiste gi√† una zona con lo stesso nome
  const existingIndex = zones.findIndex(z => z.name === zoneName);
  
  if (existingIndex !== -1) {
    // Aggiorna zona esistente
    zones[existingIndex] = {
      url: url,
      name: zoneName,
      savedAt: new Date().toISOString()
    };
    notify('‚úÖ Zona Moovit aggiornata!', 'success');
  } else {
    // Aggiungi nuova zona
    zones.push({
      url: url,
      name: zoneName,
      savedAt: new Date().toISOString()
    });
    notify('‚úÖ Zona Moovit salvata!', 'success');
  }
  
  localStorage.setItem(MOOVIT_ZONES_STORAGE, JSON.stringify(zones));
  console.log('üíæ Zona Moovit salvata:', zoneName);
  
  // Seleziona automaticamente questa zona
  selectedMoovitZone = { url, name: zoneName };
  updateMoovitUI();
}

// Salva il link Moovit dall'input utente
function saveMoovitBaseUrl() {
  const urlInput = document.getElementById('moovitBaseUrl');
  const nameInput = document.getElementById('moovitZoneName');
  const url = urlInput.value.trim();
  const zoneName = nameInput.value.trim();
  
  if (!url) {
    notify('‚ùå Inserisci un link Moovit valido', 'error');
    return;
  }
  
  if (!zoneName) {
    notify('‚ùå Inserisci un nome per questa zona', 'error');
    return;
  }
  
  if (!url.includes('moovitapp.com')) {
    notify('‚ö†Ô∏è Il link dovrebbe essere di moovitapp.com', 'error');
    return;
  }
  
  // Salva la zona
  saveMoovitZone(url, zoneName);
  
  // Pulisci i campi
  urlInput.value = '';
  nameInput.value = '';
}

// Mostra il selettore di zone salvate
function showZoneSelector() {
  const zones = loadMoovitZones();
  const selector = document.getElementById('moovitZoneSelector');
  const selectElement = document.getElementById('savedZonesSelect');
  
  if (zones.length === 0) {
    // Nessuna zona salvata - mostra solo il form nuovo
    if (selector) selector.style.display = 'none';
    document.getElementById('moovitConfig').style.display = 'block';
    return;
  }
  
  // Ci sono zone salvate - mostra il selettore
  if (selectElement) {
    selectElement.innerHTML = '<option value="">-- Seleziona una zona --</option>' +
      zones.map((zone, index) => 
        `<option value="${index}">${zone.name}</option>`
      ).join('');
  }
  
  if (selector) selector.style.display = 'block';
}

// Usa una zona salvata selezionata
function useSavedZone() {
  const selectElement = document.getElementById('savedZonesSelect');
  const selectedIndex = selectElement.value;
  
  if (selectedIndex === '') {
    notify('‚ö†Ô∏è Seleziona una zona', 'error');
    return;
  }
  
  const zones = loadMoovitZones();
  const zone = zones[parseInt(selectedIndex)];
  
  if (zone) {
    selectedMoovitZone = zone;
    updateMoovitUI();
    notify('‚úÖ Zona selezionata: ' + zone.name, 'success');
  }
}

// Aggiorna l'interfaccia Moovit
function updateMoovitUI() {
  const statusDiv = document.getElementById('moovitStatus');
  const selector = document.getElementById('moovitZoneSelector');
  const config = document.getElementById('moovitConfig');
  
  if (selectedMoovitZone) {
    // Zona selezionata - mostra status
    if (statusDiv) {
      statusDiv.innerHTML = `<strong>‚úÖ Zona Moovit attiva:</strong> ${selectedMoovitZone.name}`;
      statusDiv.style.display = 'block';
    }
    if (selector) selector.style.display = 'none';
    if (config) config.style.display = 'none';
  } else {
    // Nessuna zona selezionata
    if (statusDiv) statusDiv.style.display = 'none';
    showZoneSelector();
  }
}

// Deseleziona zona corrente
function deselectMoovitZone() {
  selectedMoovitZone = null;
  updateMoovitUI();
  notify('Zona deselezionata. Scegli una zona per usare Moovit.', 'info');
}

// Genera link Moovit completo
function generateMoovitLink(fromLat, fromLng, fromName, toLat, toLng, toName) {
  if (!selectedMoovitZone) {
    notify('‚ö†Ô∏è Seleziona prima una zona Moovit', 'error');
    return null;
  }
  
  const baseUrl = selectedMoovitZone.url;
  
  // Pulisci i nomi per l'URL
  const cleanFromName = encodeURIComponent(fromName.replace(/,/g, '').trim());
  const cleanToName = encodeURIComponent(toName.replace(/,/g, '').trim());
  
  // Costruisci il link Moovit
  const moovitUrl = `${baseUrl}/linee/${cleanFromName}-${cleanToName}/${fromLat}_${fromLng}/${toLat}_${toLng}`;
  
  console.log('üöç Link Moovit generato:', moovitUrl);
  return moovitUrl;
}

// Apri percorso in Moovit
function openInMoovit() {
  if (!currentLocation || !currentLocation.lat || !currentLocation.lng) {
    notify('‚ùå Imposta prima la posizione di partenza (Sezione 1)', 'error');
    return;
  }
  
  if (!selectedMoovitZone) {
    notify('‚ö†Ô∏è Seleziona prima una zona Moovit', 'error');
    updateMoovitUI();
    return;
  }
  
  const destInput = document.getElementById('destinationInput');
  if (!destInput || !destInput.value) {
    notify('‚ùå Inserisci prima una destinazione (Sezione 5)', 'error');
    return;
  }
  
  // Usa il geocoder per ottenere le coordinate della destinazione
  const geocoder = new google.maps.Geocoder();
  geocoder.geocode({ address: destInput.value }, (results, status) => {
    if (status === 'OK' && results[0]) {
      const destLat = results[0].geometry.location.lat();
      const destLng = results[0].geometry.location.lng();
      const destName = results[0].formatted_address;
      
      const fromName = document.getElementById('addressInput').value || 'Posizione corrente';
      
      const moovitLink = generateMoovitLink(
        currentLocation.lat,
        currentLocation.lng,
        fromName,
        destLat,
        destLng,
        destName
      );
      
      if (moovitLink) {
        window.open(moovitLink, '_blank');
        notify('üöç Apertura Moovit...', 'success');
      }
    } else {
      notify('‚ùå Impossibile geocodificare la destinazione', 'error');
      console.error('Geocoding error:', status);
    }
  });
}

// Mostra/nascondi sezione Moovit
function updateMoovitVisibility() {
  const travelMode = document.getElementById('travelMode').value;
  const moovitBtn = document.getElementById('openMoovitBtn');
  const moovitSection = document.getElementById('moovitSection');
  
  if (travelMode === 'TRANSIT') {
    if (moovitBtn) moovitBtn.style.display = 'inline-block';
    if (moovitSection) {
      moovitSection.style.display = 'block';
      updateMoovitUI();
    }
  } else {
    if (moovitBtn) moovitBtn.style.display = 'none';
    if (moovitSection) moovitSection.style.display = 'none';
  }
}

// Gestione zone salvate nel modal
function showSavedMoovitZones() {
  const zones = loadMoovitZones();
  const modal = document.getElementById('moovitZonesModal');
  const list = document.getElementById('moovitZonesList');
  
  if (!list) return;
  
  if (zones.length === 0) {
    list.innerHTML = '<p style="color:#6c757d;font-style:italic;">Nessuna zona salvata ancora.</p>';
  } else {
    list.innerHTML = zones.map((zone, index) => `
      <div style="padding:12px;border:1px solid #dee2e6;border-radius:6px;margin-bottom:10px;background:#f8f9fa;">
        <strong style="font-size:1.1em;">${zone.name}</strong><br>
        <small style="color:#6c757d;">Link: ${zone.url.substring(0, 60)}...</small><br>
        <small style="color:#6c757d;">Salvata: ${new Date(zone.savedAt).toLocaleString('it-IT')}</small><br>
        <div style="margin-top:10px;display:flex;gap:8px;">
          <button class="btn btn-secondary" onclick="selectZoneFromModal(${index})" style="padding:6px 12px;font-size:0.9em;">
            ‚úÖ Usa Questa
          </button>
          <button class="btn btn-danger" onclick="deleteMoovitZone(${index})" style="padding:6px 12px;font-size:0.9em;">
            üóëÔ∏è Rimuovi
          </button>
        </div>
      </div>
    `).join('');
  }
  
  if (modal) modal.classList.add('show');
}

function selectZoneFromModal(index) {
  const zones = loadMoovitZones();
  const zone = zones[index];
  
  if (zone) {
    selectedMoovitZone = zone;
    updateMoovitUI();
    closeMoovitZonesModal();
    notify('‚úÖ Zona selezionata: ' + zone.name, 'success');
  }
}

function deleteMoovitZone(index) {
  if (!confirm('Vuoi rimuovere questa zona Moovit?')) return;
  
  const zones = loadMoovitZones();
  const deletedZone = zones[index];
  
  // Se la zona eliminata √® quella selezionata, deseleziona
  if (selectedMoovitZone && selectedMoovitZone.name === deletedZone.name) {
    selectedMoovitZone = null;
  }
  
  zones.splice(index, 1);
  localStorage.setItem(MOOVIT_ZONES_STORAGE, JSON.stringify(zones));
  
  notify('üóëÔ∏è Zona rimossa', 'info');
  showSavedMoovitZones();
  updateMoovitUI();
}

function closeMoovitZonesModal() {
  const modal = document.getElementById('moovitZonesModal');
  if (modal) modal.classList.remove('show');
}

// Inizializzazione
window.addEventListener('DOMContentLoaded', () => {
  const travelModeSelect = document.getElementById('travelMode');
  if (travelModeSelect) {
    travelModeSelect.addEventListener('change', updateMoovitVisibility);
    updateMoovitVisibility();
  }
});

// ===== GESTIONE API KEY =====
(function() {
  const STORAGE = 'google_maps_api_key_mobilita';
  let loaded = false;
  window.userApiKey = null;

  function notify(msg, type) {
    const ex = document.querySelector('.notification');
    if (ex) ex.remove();
    const n = document.createElement('div');
    n.className = 'notification ' + type;
    n.textContent = msg;
    n.style.cssText = 'position:fixed;top:20px;right:20px;z-index:20000;';
    document.body.appendChild(n);
    setTimeout(() => n.remove(), 5000);
  }

  function check() {
    const s = localStorage.getItem(STORAGE);
    if (s && s.length > 20) {
      window.userApiKey = s;
      load();
      return true;
    }
    return false;
  }

  function load() {
    if (loaded) return;
    console.log('üîÑ Caricamento Google Maps...');
    document.getElementById('apiKeySetup').style.display = 'none';
    document.body.classList.remove('api-setup-active');
    document.getElementById('settingsIcon').style.display = 'flex';
    
    const sc = document.createElement('script');
    // RIMUOVO IL CALLBACK - initMap verr√† chiamato manualmente dopo il caricamento
    sc.src = 'https://maps.googleapis.com/maps/api/js?key=' + window.userApiKey + '&v=weekly&libraries=places,geometry';
    sc.async = true;
    sc.defer = true;
    sc.onerror = () => {
      notify('‚ùå Errore caricamento Maps', 'error');
      document.getElementById('apiKeySetup').style.display = 'block';
      document.body.classList.add('api-setup-active');
      document.getElementById('settingsIcon').style.display = 'none';
    };
    sc.onload = () => {
      console.log('‚úÖ Maps caricato, chiamo initMap...');
      // Chiama initMap manualmente dopo il caricamento
      if (typeof window.initMap === 'function') {
        window.initMap();
        notify('‚úÖ App pronta!', 'success');
      } else {
        console.error('‚ùå initMap non trovata!');
        notify('‚ùå Errore inizializzazione', 'error');
      }
    };
    document.head.appendChild(sc);
    loaded = true;
  }

  document.getElementById('saveKeyBtn').addEventListener('click', () => {
    const k = document.getElementById('apiKeyInput').value.trim();
    if (!k) return notify('‚ùå Inserisci la chiave', 'error');
    if (!k.startsWith('AIzaSy')) return notify('‚ö†Ô∏è Dovrebbe iniziare con AIzaSy', 'error');
    localStorage.setItem(STORAGE, k);
    window.userApiKey = k;
    notify('‚úÖ Salvata!', 'success');
    setTimeout(load, 800);
  });

  document.getElementById('testKeyBtn').addEventListener('click', async () => {
    const k = document.getElementById('apiKeyInput').value.trim();
    if (!k) return notify('‚ùå Inserisci la chiave', 'error');
    const st = document.getElementById('apiKeyStatus');
    st.innerHTML = '<p style="color:#17a2b8">üîÑ Test...</p>';
    try {
      const r = await fetch('https://maps.googleapis.com/maps/api/geocode/json?address=Roma&key=' + k);
      const d = await r.json();
      if (d.status === 'OK') st.innerHTML = '<p style="color:#28a745;font-weight:600">‚úÖ Valida!</p>';
      else if (d.status === 'REQUEST_DENIED') st.innerHTML = '<p style="color:#dc3545;font-weight:600">‚ùå Rifiutata</p>';
      else st.innerHTML = '<p style="color:#ff9800">‚ö†Ô∏è ' + d.status + '</p>';
    } catch(e) {
      st.innerHTML = '<p style="color:#dc3545">‚ùå Errore</p>';
    }
  });

  document.getElementById('toggleKeyBtn').addEventListener('click', () => {
    const i = document.getElementById('apiKeyInput');
    i.type = i.type === 'password' ? 'text' : 'password';
  });

  document.getElementById('settingsIcon').addEventListener('click', () => {
    const m = document.getElementById('apiKeyModal');
    const s = document.getElementById('currentApiStatus');
    const i = document.getElementById('newApiKeyInput');
    if (window.userApiKey) {
      s.innerHTML = '<span class="api-status active">‚úÖ Attiva</span>';
      i.value = window.userApiKey;
    } else {
      s.innerHTML = '<span class="api-status inactive">‚ùå Non configurata</span>';
    }
    m.classList.add('show');
  });

  document.getElementById('closeModalBtn').addEventListener('click', () => {
    document.getElementById('apiKeyModal').classList.remove('show');
  });

  document.getElementById('updateKeyBtn').addEventListener('click', () => {
    const k = document.getElementById('newApiKeyInput').value.trim();
    if (!k || !k.startsWith('AIzaSy')) return notify('‚ùå Non valida', 'error');
    localStorage.setItem(STORAGE, k);
    window.userApiKey = k;
    notify('‚úÖ Aggiornata! Ricarica pagina', 'success');
    document.getElementById('apiKeyModal').classList.remove('show');
  });

  document.getElementById('removeKeyBtn').addEventListener('click', () => {
    if (!confirm('Rimuovere?')) return;
    localStorage.removeItem(STORAGE);
    notify('üóëÔ∏è Rimossa', 'info');
    setTimeout(() => location.reload(), 2000);
  });

  document.getElementById('toggleNewKeyBtn').addEventListener('click', () => {
    const i = document.getElementById('newApiKeyInput');
    i.type = i.type === 'password' ? 'text' : 'password';
  });

  document.getElementById('apiKeyModal').addEventListener('click', e => {
    if (e.target.id === 'apiKeyModal') document.getElementById('apiKeyModal').classList.remove('show');
  });

  document.getElementById('apiKeyInput').addEventListener('keypress', e => {
    if (e.key === 'Enter') document.getElementById('saveKeyBtn').click();
  });

  window.addEventListener('DOMContentLoaded', () => {
    console.log('üöÄ App Mobilit√†');
    if (!check()) {
      console.log('üìù Nessuna API key trovata');
    }
  });
})();
</script>

<!-- Modal Gestione Zone Moovit -->
<div id="moovitZonesModal" class="modal">
  <div class="modal-content">
    <div class="modal-header">üìã Zone Moovit Salvate</div>
    <div style="padding:20px">
      <div id="moovitZonesList"></div>
      <div class="modal-buttons">
        <button class="btn btn-ghost" onclick="closeMoovitZonesModal()">‚ùå Chiudi</button>
      </div>
    </div>
  </div>
</div>

<!-- Modal Guida Completa -->
<div id="guideModal" class="modal guide-modal">
  <div class="modal-content">
    <div class="modal-header">üìñ Guida Completa - App Mobilit√† e Orientamento</div>
    <div style="padding: 30px;">
      
      <p style="font-size: 1.1em; line-height: 1.8; margin-bottom: 30px;">
        Questa applicazione √® stata progettata per aiutarti nell'esplorazione urbana e nell'orientamento, 
        fornendo informazioni dettagliate su indirizzi, percorsi e direzioni. Questa guida ti accompagner√† 
        passo-passo nell'uso di tutte le funzionalit√†.
      </p>

      <!-- ============ SETUP INIZIALE ============ -->
      <div class="guide-section">
        <h3>üîß 1. Setup Iniziale - Configurazione API Key Google Maps</h3>
        
        <h4>Perch√© serve una API Key?</h4>
        <p>
          L'app utilizza i servizi Google Maps (mappe, Street View, percorsi, ricerca luoghi) che richiedono 
          una chiave API personale. La tua chiave verr√† salvata <strong>solo nel tuo browser</strong> 
          (localStorage) e <strong>mai condivisa</strong>.
        </p>

        <h4>Come ottenere la API Key (5-10 minuti):</h4>
        <div class="guide-step">
          <strong>Passo 1:</strong> Vai su 
          <a href="https://console.cloud.google.com/google/maps-apis" target="_blank" rel="noopener">
            Google Cloud Console
          </a> (serve account Google)
        </div>
        
        <div class="guide-step">
          <strong>Passo 2:</strong> Crea un nuovo progetto:
          <ul style="margin-top: 8px;">
            <li>Clicca su "Seleziona progetto" in alto</li>
            <li>Clicca "Nuovo progetto"</li>
            <li>Dai un nome (es: "App Mobilit√†")</li>
            <li>Clicca "Crea"</li>
          </ul>
        </div>

        <div class="guide-step">
          <strong>Passo 3:</strong> Abilita le API necessarie:
          <ul style="margin-top: 8px;">
            <li>Vai su "API e servizi" ‚Üí "Libreria"</li>
            <li>Cerca e abilita <strong>Maps JavaScript API</strong></li>
            <li>Cerca e abilita <strong>Places API</strong></li>
            <li>Cerca e abilita <strong>Directions API</strong></li>
            <li>Cerca e abilita <strong>Geocoding API</strong></li>
          </ul>
        </div>

        <div class="guide-step">
          <strong>Passo 4:</strong> Crea la chiave API:
          <ul style="margin-top: 8px;">
            <li>Vai su "API e servizi" ‚Üí "Credenziali"</li>
            <li>Clicca "Crea credenziali" ‚Üí "Chiave API"</li>
            <li>Copia la chiave (inizia con <span class="guide-kbd">AIzaSy...</span>)</li>
          </ul>
        </div>

        <div class="guide-step">
          <strong>Passo 5:</strong> Inserisci la chiave nell'app:
          <ul style="margin-top: 8px;">
            <li>Incolla la chiave nel campo "Inserisci la tua API Key"</li>
            <li>Clicca "üíæ Salva e Avvia App"</li>
            <li>L'app si avvier√† automaticamente!</li>
          </ul>
        </div>

        <div class="guide-tip">
          <strong>üí∞ Costi:</strong> Google offre quote gratuite mensili generose per ogni API 
          (es: 28.000 caricamenti mappa, 5.000 chiamate Places, 10.000 Geocoding). 
          Per uso personale normale, non pagherai nulla!
        </div>

        <div class="guide-warning">
          <strong>‚ö†Ô∏è Importante:</strong> La chiave √® salvata solo nel TUO browser. 
          Se cambi browser o dispositivo, dovrai reinserirla. Puoi gestirla cliccando 
          sull'icona ‚öôÔ∏è in basso a destra.
        </div>
      </div>

      <!-- ============ SEZIONE 1 ============ -->
      <div class="guide-section">
        <h3>üìç 2. Sezione 1: Punto di Partenza</h3>
        
        <h4>Cosa fa:</h4>
        <p>
          Imposta la tua posizione di partenza, fondamentale per tutte le altre funzioni 
          (percorsi, ricerca nelle vicinanze, orientamento).
        </p>

        <h4>Come usarla:</h4>
        
        <div class="guide-step">
          <strong>Inserisci indirizzo:</strong>
          <ul style="margin-top: 8px;">
            <li>Scrivi l'indirizzo completo nel campo (es: "Via Roma 1, Milano")</li>
            <li>L'autocomplete ti suggerir√† indirizzi mentre scrivi</li>
            <li>I suggerimenti sono ordinati per vicinanza se hai gi√† impostato una posizione</li>
            <li>Seleziona dalla lista o premi <span class="guide-kbd">Invio</span></li>
            <li>Clicca "üîç Cerca"</li>
          </ul>
        </div>

        <div class="guide-tip">
          <strong>üí° Suggerimento:</strong> Scrivi sempre indirizzo completo con via, numero civico e citt√† 
          per risultati pi√π precisi. Es: "Corso Vittorio Emanuele II 12, Torino" invece di solo "Corso Vittorio".
        </div>

        <h4>Cosa succede dopo:</h4>
        <ul>
          <li>‚úÖ La mappa si centra sulla posizione</li>
          <li>‚úÖ Street View mostra il punto pi√π vicino disponibile</li>
          <li>‚úÖ Calcolo automatico dell'orientamento (verso dove guardi quando esci)</li>
          <li>‚úÖ Rapporto di trasparenza che spiega come √® stato trovato il punto</li>
        </ul>

        <div class="guide-tip">
          <strong>üí° Suggerimento:</strong> L'autocomplete ordina i suggerimenti per vicinanza. 
          Se hai gi√† impostato una posizione, i suggerimenti per luoghi vicini appariranno per primi!
        </div>

        <div class="guide-warning">
          <strong>üî¨ Expert Mode:</strong> Il raggio di ricerca Street View pu√≤ essere regolato 
          (30-100m). Valori pi√π alti trovano pi√π punti ma possono essere meno precisi. 
          Consigliato: 50-70m.
        </div>
      </div>

      <!-- ============ SEZIONE 2 ============ -->
      <div class="guide-section">
        <h3>üó∫Ô∏è 3. Sezione 2: Mappa e Street View</h3>
        
        <h4>Cosa fa:</h4>
        <p>Visualizza la posizione su mappa interattiva e Street View panoramico.</p>

        <h4>Controlli Mappa:</h4>
        <ul>
          <li><strong>Zoom:</strong> Rotellina mouse o pulsanti +/-</li>
          <li><strong>Sposta:</strong> Trascina con il mouse</li>
          <li><strong>Marker rosso:</strong> Tua posizione cercata</li>
          <li><strong>Marker blu:</strong> Punto Street View trovato</li>
        </ul>

        <h4>Controlli Street View:</h4>
        <ul>
          <li><strong>Ruota vista:</strong> Trascina lateralmente</li>
          <li><strong>Guarda su/gi√π:</strong> Trascina verticalmente</li>
          <li><strong>Zoom:</strong> Rotellina mouse</li>
          <li><strong>Sposta:</strong> Clicca sulle frecce bianche sulla strada</li>
        </ul>

        <div class="guide-tip">
          <strong>üí° A cosa serve:</strong> Street View ti permette di "vedere" virtualmente 
          il luogo prima di andarci, verificare l'aspetto degli edifici, vedere i punti di riferimento.
        </div>
      </div>

      <!-- ============ SEZIONE 3 ============ -->
      <div class="guide-section">
        <h3>üîé 4. Sezione 3: Cerca nelle Vicinanze</h3>
        
        <h4>Cosa fa:</h4>
        <p>
          Trova luoghi d'interesse (negozi, servizi, ristoranti) vicino alla tua posizione. 
          Include oltre 100 categorie diverse!
        </p>

        <h4>Come usarla:</h4>
        
        <div class="guide-step">
          <strong>Passo 1:</strong> Seleziona una categoria dal menu a tendina:
          <ul style="margin-top: 8px;">
            <li><strong>Uso Quotidiano:</strong> Le pi√π comuni (bancomat, farmacie, supermercati, ecc.)</li>
            <li><strong>Tutte le Categorie:</strong> Lista completa alfabetica</li>
          </ul>
        </div>

        <div class="guide-step">
          <strong>Passo 2:</strong> Imposta il raggio di ricerca:
          <ul style="margin-top: 8px;">
            <li>100m - 5km (regola con lo slider)</li>
            <li>Raggi piccoli (100-500m): pi√π precisi, a piedi</li>
            <li>Raggi grandi (1-5km): pi√π opzioni, servono mezzi</li>
          </ul>
        </div>

        <div class="guide-step">
          <strong>Passo 3:</strong> Clicca "üîç Cerca"
        </div>

        <h4>Risultati mostrati (Sezione 4):</h4>
        <ul>
          <li><strong>Nome</strong> del luogo</li>
          <li><strong>Distanza</strong> dalla tua posizione</li>
          <li><strong>Indirizzo</strong> completo</li>
          <li><strong>Marker sulla mappa</strong> cliccabili</li>
        </ul>

        <div class="guide-tip">
          <strong>üí° Suggerimento:</strong> I risultati sono ordinati per distanza (pi√π vicini prima). 
          Clicca su un marker per vedere i dettagli del luogo!
        </div>
      </div>

      <!-- ============ SEZIONE 5 ============ -->
      <div class="guide-section">
        <h3>üéØ 5. Sezione 5: Percorso Personalizzato</h3>
        
        <h4>Cosa fa:</h4>
        <p>
          Calcola il percorso dalla tua posizione (Sezione 1) a una destinazione che scegli, 
          con diverse modalit√† di trasporto.
        </p>

        <h4>Come usarla:</h4>
        
        <div class="guide-step">
          <strong>Passo 1:</strong> Inserisci la destinazione:
          <ul style="margin-top: 8px;">
            <li>Scrivi l'indirizzo o il nome del luogo</li>
            <li>L'autocomplete suggerisce indirizzi ordinati per vicinanza</li>
            <li>Puoi inserire anche punti di interesse (es: "Colosseo", "Stazione Termini")</li>
          </ul>
        </div>

        <div class="guide-step">
          <strong>Passo 2:</strong> Scegli il modo di trasporto:
          <ul style="margin-top: 8px;">
            <li><strong>üöó Auto:</strong> Percorso stradale, tempo stimato, traffico</li>
            <li><strong>üö∂ A piedi:</strong> Percorso pedonale, distanza a piedi</li>
            <li><strong>üö¥ Bicicletta:</strong> Piste ciclabili quando disponibili</li>
            <li><strong>üöç Trasporto pubblico:</strong> Bus, metro, tram con orari</li>
          </ul>
        </div>

        <div class="guide-step">
          <strong>Passo 3:</strong> Clicca "üß≠ Calcola Percorso"
        </div>

        <h4>Risultati mostrati:</h4>
        <ul>
          <li>üìè <strong>Distanza</strong> totale</li>
          <li>‚è±Ô∏è <strong>Tempo stimato</strong></li>
          <li>üó∫Ô∏è <strong>Percorso sulla mappa</strong> (linea blu)</li>
          <li>üìù <strong>Istruzioni passo-passo</strong> (svolte, direzioni)</li>
        </ul>

        <h4>Azioni disponibili:</h4>
        <ul>
          <li><strong>üó∫Ô∏è Apri in Google Maps:</strong> Apre Google Maps con navigazione attiva</li>
          <li><strong>üîä Leggi Istruzioni:</strong> Sintesi vocale delle istruzioni (accessibilit√†)</li>
        </ul>

        <h4>üöç Trasporto Pubblico con Moovit:</h4>
        
        <p style="margin-top: 15px;">
          Quando selezioni "Trasporto Pubblico", appare un'opzione aggiuntiva per usare Moovit:
        </p>

        <div class="guide-step">
          <strong>Prima volta - Configura zona Moovit:</strong>
          <ul style="margin-top: 8px;">
            <li>Appare un box azzurro con menu a tendina</li>
            <li>Clicca "‚ûï Aggiungi Nuova Zona"</li>
            <li>Inserisci nome zona (es: "Roma e Lazio")</li>
            <li>Inserisci link base Moovit della tua zona</li>
            <li>Il link lo trovi su moovitapp.com per la tua citt√†</li>
            <li>Clicca "üíæ Salva Zona"</li>
          </ul>
        </div>

        <div class="guide-step">
          <strong>Visite successive:</strong>
          <ul style="margin-top: 8px;">
            <li>Seleziona la zona dal menu a tendina</li>
            <li>Clicca "‚úÖ Usa Questa Zona"</li>
            <li>Il pulsante "üöç Apri in Moovit" diventa attivo</li>
          </ul>
        </div>

        <div class="guide-step">
          <strong>Generazione link Moovit:</strong>
          <ul style="margin-top: 8px;">
            <li>L'app genera automaticamente il link completo</li>
            <li>Usa coordinate esatte di partenza e arrivo</li>
            <li>Si apre Moovit con il percorso gi√† impostato!</li>
          </ul>
        </div>

        <div class="guide-tip">
          <strong>üí° Gestione zone:</strong> Puoi salvare pi√π zone (Roma, Milano, Torino, ecc.) 
          e passare da una all'altra. Clicca "üìã Gestisci Zone" per vedere, selezionare o 
          rimuovere zone salvate.
        </div>

        <div class="guide-warning">
          <strong>‚ö†Ô∏è Link base Moovit:</strong> Ogni citt√† ha il suo link specifico. 
          Non usare lo stesso link per citt√† diverse! Esempio Roma: 
          <span class="guide-kbd">https://moovitapp.com/index/it-it/trasporto_pubblico-roma_e_lazio-61</span>
        </div>
      </div>

      <!-- ============ SEZIONE 6 ============ -->
      <div class="guide-section">
        <h3>‚öñÔ∏è 6. Sezione 6: Confronto Civici (Avanzato)</h3>
        
        <h4>Cosa fa:</h4>
        <p>
          Confronta scientificamente due numeri civici sulla <strong>stessa via</strong> per 
          determinare se sono sullo stesso marciapiede o su lati opposti della strada.
        </p>

        <h4>Quando usarla:</h4>
        <ul>
          <li><strong>Scenario A:</strong> Sei al civico 20 (con Street View) e devi andare al 24 
          (senza Street View). Vuoi sapere se devi attraversare.</li>
          <li><strong>Scenario B:</strong> Street View √® ambiguo e vuoi una conferma matematica.</li>
          <li><strong>Scenario C:</strong> Pianifichi a tavolino e vuoi capire la conformazione 
          di una via.</li>
        </ul>

        <h4>Come usarla:</h4>
        
        <div class="guide-step">
          <strong>Passo 1:</strong> Inserisci Civico A (riferimento):
          <ul style="margin-top: 8px;">
            <li>Indirizzo completo: Via, numero, citt√†</li>
            <li>Es: "Via Po 18, Torino"</li>
            <li>Questo sar√† il punto di riferimento</li>
          </ul>
        </div>

        <div class="guide-step">
          <strong>Passo 2:</strong> Inserisci Civico B (destinazione):
          <ul style="margin-top: 8px;">
            <li>DEVE essere sulla stessa via di A!</li>
            <li>Es: "Via Po 25, Torino"</li>
            <li>Pu√≤ essere prima o dopo del civico A</li>
          </ul>
        </div>

        <div class="guide-step">
          <strong>Passo 3:</strong> Clicca "üìê Calcola Posizione"
        </div>

        <h4>I 3 metodi scientifici usati:</h4>
        
        <div class="guide-step">
          <strong>1. Check Precisione (Google):</strong>
          <ul style="margin-top: 8px;">
            <li><strong>ROOFTOP:</strong> Google conosce esattamente il civico ‚Üí Alta affidabilit√†</li>
            <li><strong>RANGE_INTERPOLATED:</strong> Google ha "indovinato" la posizione ‚Üí 
            Media affidabilit√†</li>
            <li><strong>GEOMETRIC_CENTER:</strong> Solo centro strada ‚Üí Bassa affidabilit√†</li>
          </ul>
        </div>

        <div class="guide-step">
          <strong>2. Calcolo Geometrico (OpenStreetMap):</strong>
          <ul style="margin-top: 8px;">
            <li>Recupera la geometria reale della strada da OSM</li>
            <li>Usa il prodotto vettoriale per determinare matematicamente il lato</li>
            <li>Molto preciso se OSM ha dati accurati della strada</li>
          </ul>
        </div>

        <div class="guide-step">
          <strong>3. Validazione Street View (Google):</strong>
          <ul style="margin-top: 8px;">
            <li>Controlla gli angoli di vista di Street View nei due punti</li>
            <li>Se si "guardano" parallelamente ‚Üí Stesso lato</li>
            <li>Se si "guardano" in modo opposto ‚Üí Lati opposti</li>
          </ul>
        </div>

        <h4>Risultato finale:</h4>
        <ul>
          <li><strong>Score 0-100:</strong> Confidenza del risultato</li>
          <li><strong>Verdetto:</strong> "Stesso lato" o "Lati opposti"</li>
          <li><strong>Dettagli:</strong> Risultato di ogni singolo metodo</li>
          <li><strong>Avvisi:</strong> Se i metodi non concordano</li>
        </ul>

        <div class="guide-tip">
          <strong>üí° Interpretazione score:</strong>
          <ul style="margin-top: 8px;">
            <li><strong>80-100:</strong> Altissima confidenza, puoi fidarti</li>
            <li><strong>60-79:</strong> Buona confidenza, probabile corretto</li>
            <li><strong>40-59:</strong> Media confidenza, verifica con Street View</li>
            <li><strong>0-39:</strong> Bassa confidenza, dati insufficienti</li>
          </ul>
        </div>

        <div class="guide-warning">
          <strong>‚ö†Ô∏è Limitazioni:</strong>
          <ul style="margin-top: 8px;">
            <li>Funziona SOLO con civici sulla stessa via</li>
            <li>OpenStreetMap potrebbe non avere geometria per tutte le strade</li>
            <li>In caso di piazze o vie molto larghe, la precisione pu√≤ calare</li>
          </ul>
        </div>
      </div>

      <!-- ============ FUNZIONI AGGIUNTIVE ============ -->
      <div class="guide-section">
        <h3>üîß 7. Funzioni Aggiuntive</h3>
        
        <h4>üîÑ Ricalcola Orientamento:</h4>
        <p>
          Se il calcolo automatico dell'orientamento (Sezione 1) sembra strano o vuoi 
          riprovare, clicca questo pulsante per ricalcolare usando il sistema intelligente 
          a 4 tentativi.
        </p>

        <h4>‚öôÔ∏è Gestisci API Key:</h4>
        <p>
          Icona in basso a destra. Permette di:
        </p>
        <ul>
          <li>Vedere la chiave API attualmente attiva</li>
          <li>Aggiornarla se cambi chiave</li>
          <li>Rimuoverla (dovrai reinserirla al prossimo uso)</li>
        </ul>

        <h4>üß≠ Esplora Incroci (OSM):</h4>
        <p>
          Nella Sezione 5, trova gli incroci stradali nelle vicinanze usando dati OpenStreetMap. 
          Utile per orientarsi identificando incroci noti.
        </p>

        <h4>üó∫Ô∏è Esplora POI (OSM):</h4>
        <p>
          Nella Sezione 5, trova punti di interesse (negozi, monumenti, servizi) usando 
          OpenStreetMap come fonte alternativa a Google Places.
        </p>

        <div class="guide-tip">
          <strong>üí° OpenStreetMap vs Google:</strong> OSM √® una mappa collaborativa open source. 
          A volte ha dati diversi o pi√π aggiornati di Google Maps, quindi vale la pena provarla!
        </div>
      </div>

      <!-- ============ ACCESSIBILIT√Ä ============ -->
      <div class="guide-section">
        <h3>‚ôø 8. Accessibilit√†</h3>
        
        <h4>L'app √® progettata per essere accessibile:</h4>
        
        <ul>
          <li><strong>Screen reader:</strong> Tutti i controlli hanno etichette ARIA appropriate</li>
          <li><strong>Navigazione tastiera:</strong> Tutti i pulsanti sono accessibili con Tab</li>
          <li><strong>Sintesi vocale:</strong> Pulsante "üîä Leggi Istruzioni" per le indicazioni percorso</li>
          <li><strong>Contrasti:</strong> Colori scelti per buona leggibilit√†</li>
          <li><strong>Skip links:</strong> In alto per saltare a sezioni specifiche</li>
        </ul>

        <h4>Scorciatoie tastiera:</h4>
        <ul>
          <li><span class="guide-kbd">Enter</span> nei campi di input: Esegue ricerca</li>
          <li><span class="guide-kbd">Tab</span>: Naviga tra i controlli</li>
          <li><span class="guide-kbd">Esc</span>: Chiude i modal aperti</li>
        </ul>
      </div>

      <!-- ============ RISOLUZIONE PROBLEMI ============ -->
      <div class="guide-section">
        <h3>üîß 9. Risoluzione Problemi</h3>
        
        <h4>‚ùå "Errore caricamento Maps":</h4>
        <ul>
          <li>Verifica che la API Key sia corretta (inizia con AIzaSy)</li>
          <li>Controlla di aver abilitato tutte le API necessarie in Google Cloud</li>
          <li>Verifica di avere connessione internet</li>
        </ul>

        <h4>‚ùå "Street View non disponibile":</h4>
        <ul>
          <li>Non tutti i luoghi hanno copertura Street View</li>
          <li>Prova ad aumentare il raggio di ricerca (slider Expert Mode)</li>
          <li>L'app cerca automaticamente il punto Street View pi√π vicino</li>
        </ul>

        <h4>‚ùå "OSM non fornisce geometria strada":</h4>
        <ul>
          <li>OpenStreetMap potrebbe non avere dati per quella specifica strada</li>
          <li>Prova con un indirizzo leggermente diverso o pi√π generico</li>
          <li>Funziona meglio con strade principali</li>
        </ul>

        <h4>‚ùå Autocomplete non suggerisce indirizzi:</h4>
        <ul>
          <li>Aspetta 1-2 secondi dopo aver iniziato a scrivere</li>
          <li>Assicurati di aver abilitato Places API</li>
          <li>Scrivi almeno 3-4 caratteri</li>
        </ul>

        <h4>‚ùå "Errore 429" (Troppi richieste):</h4>
        <ul>
          <li>Hai superato le quote gratuite mensili</li>
          <li>Aspetta qualche minuto tra le richieste</li>
          <li>Verifica le quote nel Google Cloud Console</li>
        </ul>

        <div class="guide-tip">
          <strong>üí° Suggerimento generale:</strong> Se qualcosa non funziona, prova a:
          <ol style="margin-top: 8px;">
            <li>Ricaricare la pagina (<span class="guide-kbd">F5</span>)</li>
            <li>Svuotare la cache del browser</li>
            <li>Aprire la console (<span class="guide-kbd">F12</span>) per vedere errori dettagliati</li>
          </ol>
        </div>
      </div>

      <!-- ============ PRIVACY E SICUREZZA ============ -->
      <div class="guide-section">
        <h3>üîí 10. Privacy e Sicurezza</h3>
        
        <h4>Dati salvati localmente (nel tuo browser):</h4>
        <ul>
          <li><strong>API Key Google Maps:</strong> Salvata in localStorage</li>
          <li><strong>Zone Moovit:</strong> Link e nomi zone salvati in localStorage</li>
        </ul>

        <h4>Cosa NON viene mai condiviso:</h4>
        <ul>
          <li>‚ùå La tua API Key NON viene mai inviata a server esterni (solo a Google)</li>
          <li>‚ùå Le tue ricerche NON vengono registrate</li>
          <li>‚ùå I tuoi percorsi NON vengono tracciati</li>
          <li>‚ùå Nessun dato personale viene raccolto</li>
        </ul>

        <h4>Servizi esterni utilizzati:</h4>
        <ul>
          <li><strong>Google Maps API:</strong> Per mappe, percorsi, luoghi</li>
          <li><strong>OpenStreetMap/Overpass API:</strong> Per geometrie strade e POI</li>
          <li><strong>Moovit:</strong> Solo quando clicchi il pulsante (apre il sito Moovit)</li>
        </ul>

        <div class="guide-warning">
          <strong>‚ö†Ô∏è Importante:</strong> L'app √® completamente client-side (gira solo nel tuo browser). 
          Non abbiamo server che raccolgono dati. Tutto rimane sul TUO dispositivo!
        </div>
      </div>

      <!-- ============ CREDITS ============ -->
      <div class="guide-section">
        <h3>üìù 11. Crediti e Tecnologie</h3>
        
        <h4>Servizi utilizzati:</h4>
        <ul>
          <li><strong>Google Maps Platform:</strong> Mappe, Street View, Directions, Places, Geocoding</li>
          <li><strong>OpenStreetMap:</strong> Geometrie strade, POI, incroci</li>
          <li><strong>Overpass API:</strong> Query dati OpenStreetMap</li>
          <li><strong>Moovit:</strong> Trasporto pubblico</li>
        </ul>

        
      </div>

      <div class="modal-buttons">
        <button class="btn btn-ghost" onclick="closeGuideModal()">‚ùå Chiudi Guida</button>
      </div>

    </div>
  </div>
</div>

</body>
</html>